// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0 OR MIT
//! Utilities to extract examples from The Rust Reference, run them through RMC,
//! and display their results.

use pulldown_cmark::{Parser, Tag};
use std::io::{BufRead, BufReader};
use std::process::Stdio;
use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    process::Command,
};
use std::{env, fs};

use crate::dashboard;

/// Parses the chapter/section hierarchy in the markdown file specified by
/// `summary_path` and returns a mapping from markdown files containing rust
/// code to corresponding directories where the extracted rust code should
/// reside.
fn parse_hierarchy(summary_path: &Path) -> HashMap<PathBuf, PathBuf> {
    let summary = fs::read_to_string(summary_path).unwrap();
    // Skip the title and introduction.
    let parser = Parser::new(&summary).skip(8);
    // Set "ref" as the root of the hierarchical path.
    let mut hierarchy = PathBuf::from("ref");
    let mut map = HashMap::new();
    // Introduction is a especial case, so handle it separately.
    map.insert(PathBuf::from("introduction.md"), hierarchy.join("Introduction"));
    for event in parser {
        match event {
            pulldown_cmark::Event::End(Tag::Item) => {
                // Pop the current chapter/section from the hierarchy once
                // we are done processing it and its subsections.
                hierarchy.pop();
            }
            pulldown_cmark::Event::End(Tag::Link(_, path, _)) => {
                // At the start of the link tag, the hierarchy does not yet
                // contain the title of the current chapter/section. So, we wait
                // for the end of the link tag before adding the path and
                // hierarchy of the current chapter/section to the map.
                map.insert(path.split('/').collect(), hierarchy.clone());
            }
            pulldown_cmark::Event::Text(text) => {
                // Add the current chapter/section title to the hierarchy.
                hierarchy.push(text.to_string());
            }
            _ => (),
        }
    }
    map
}

/// Extracts examples from the given relative `paths` in the `book_dir` and
/// saves them in `gen_dir`.
fn extract_examples(paths: Vec<&PathBuf>, book_dir: &Path, gen_dir: &Path) {
    for path in paths {
        let mut cmd = Command::new("rustdoc");
        cmd.args([
            "+nightly",
            "--test",
            "-Z",
            "unstable-options",
            book_dir.join(path).to_str().unwrap(),
            "--test-builder",
            &["src", "tools", "dashboard", "print.sh"]
                .iter()
                .collect::<PathBuf>()
                .to_str()
                .unwrap(),
            "--persist-doctests",
            gen_dir.to_str().unwrap(),
            "--no-run",
        ]);
        cmd.stdout(Stdio::null());
        cmd.spawn()
            .expect(&format!("Error: failed to spawn process:\n{:?}", cmd))
            .wait()
            .expect(&format!("Error: spawned process did not run:\n{:?}", cmd));
    }
}

/// Copies the extracted rust code in `from_dir` to `src/test` following the
/// hierarchy specified by `rel_map`.
fn organize_examples(rel_map: &HashMap<PathBuf, PathBuf>, book_dir: &Path, from_dir: &Path) {
    let to_dir: PathBuf = ["src", "test"].iter().collect();
    // The names of the extracted examples generated by `rustdoc` have the
    // format `<path>_<line-num>_<test-num>` where occurrences of '/', '-', and
    // '.' in <path> are replaced by '_'. This translation is not injective, so
    // we cannot map those names to the original markdown file path. Instead, we
    // create a new map that does the same translation.
    let mut abs_map = HashMap::new();
    for (path, hierarchy) in rel_map.iter() {
        abs_map.insert(
            book_dir.join(path).to_str().unwrap().replace(&['\\', '/', '-', '.'][..], "_"),
            to_dir.join(hierarchy),
        );
    }
    for dir in from_dir.read_dir().unwrap() {
        let dir = dir.unwrap().path();
        // Some directories do not contain tests because the markdown file
        // instructs `rustdoc` to ignore those tests.
        if let Some(example) = dir.read_dir().unwrap().next() {
            let example = example.unwrap().path();
            copy(&example, &abs_map);
        }
    }
}

/// Copy the file specified by `from` to the corresponding location specified by
/// `map`.
fn copy(from: &Path, map: &HashMap<String, PathBuf>) {
    // First, get the name of the directory where `rustdoc` saved the extracted
    // code.
    let file_name = from.parent().unwrap().file_name().unwrap().to_str().unwrap();
    // Remove `_<line-num>_<test-num>` suffix from the name to lookup the name
    // in the map.
    let i = file_name.find("_md").unwrap() + 3;
    // All extracted examples have different `<path>_<line-num>`, so we can just
    // ignore the test number.
    let j = file_name.rfind("_0").unwrap();
    // The name of the copied file will be `<line-num>.rs`.
    let to = map[&file_name[..i]].join(format!("{}.rs", &file_name[i + 1..j]));
    fs::create_dir_all(to.parent().unwrap()).expect(&format!(
        "Error: failed to create hierarchical directory for extracted test: {:?}",
        &to
    ));
    fs::copy(&from, &to).expect(&format!("Error: failed to copy {:?} to {:?}", &from, &to));
}

/// Pre-processes the tests in the specified `paths` before running them with
/// `compiletest`.
fn preprocess_examples(_paths: Vec<&PathBuf>) {
    // For now, we will only pre-process the tests that cause infinite loops.
    // TODO: properly implement this step.
    let loop_tests: [PathBuf; 4] = [
        ["src", "test", "ref", "Appendices", "Glossary", "263.rs"].iter().collect(),
        ["src", "test", "ref", "Linkage", "190.rs"].iter().collect(),
        [
            "src",
            "test",
            "ref",
            "Statements and expressions",
            "Expressions",
            "Loop expressions",
            "133.rs",
        ]
        .iter()
        .collect(),
        [
            "src",
            "test",
            "ref",
            "Statements and expressions",
            "Expressions",
            "Method call expressions",
            "10.rs",
        ]
        .iter()
        .collect(),
    ];

    for test in loop_tests {
        let code = fs::read_to_string(&test).unwrap();
        let code = format!("// cbmc-flags: --unwind 1 --unwinding-assertions\n{}", code);
        fs::write(&test, code).unwrap();
    }
}

/// Runs `compiletest` on the `suite` and logs the results to `log_path`.
fn run_examples(suite: &str, log_path: &Path) {
    // Before executing this program, `cargo` populates the environment with
    // build configs. `x.py` respects those configs, causing a recompilation
    // of `rustc`. This is not a desired behavior, so we remove those configs.
    let filtered_env: HashMap<String, String> = env::vars()
        .filter(|&(ref k, _)| {
            !(k.contains("CARGO") || k.contains("LD_LIBRARY_PATH") || k.contains("RUST"))
        })
        .collect();
    let mut cmd = Command::new([".", "x.py"].iter().collect::<PathBuf>());
    cmd.args([
        "test",
        suite,
        "-i",
        "--stage",
        "1",
        "--test-args",
        "--logfile",
        "--test-args",
        log_path.to_str().unwrap(),
    ]);
    cmd.env_clear().envs(filtered_env);
    cmd.stdout(Stdio::null());

    cmd.spawn()
        .expect(&format!("Error: failed to spawn process:\n{:?}", cmd))
        .wait()
        .expect(&format!("Error: spawned process did not run:\n{:?}", cmd));
}

/// Creates a new [`Tree`] from a path, `ns`, and a test result, `p`.
fn tree_from_path(mut ns: Vec<String>, p: bool) -> dashboard::Tree {
    assert!(ns.len() > 0, "Error: `ns` must contain at least 1 element.");
    let mut tree = dashboard::Tree::new(
        dashboard::Node::new(ns.pop().unwrap(), if p { 1 } else { 0 }, if p { 0 } else { 1 }),
        vec![],
    );
    for _ in 0..ns.len() {
        tree = dashboard::Tree {
            data: dashboard::Node {
                name: ns.pop().unwrap(),
                num_pass: tree.data.num_pass,
                num_fail: tree.data.num_fail,
            },
            children: vec![tree],
        };
    }
    tree
}

/// Parses and generates a dashboard from the log output of `compiletest` in
/// `path`.
fn parse_log(path: &Path) -> dashboard::Tree {
    let file = fs::File::open(path).expect(&format!("Error: failed to open log file: {:?}", path));
    let reader = BufReader::new(file);
    let mut tests = dashboard::Tree {
        data: dashboard::Node { name: String::from("ref"), num_pass: 0, num_fail: 0 },
        children: vec![],
    };
    for line in reader.lines() {
        let (ns, l) = parse_log_line(&line.unwrap());
        tests = dashboard::Tree::merge(tests, tree_from_path(ns, l)).unwrap();
    }
    tests
}

/// Parses a line in the log output of `compiletest` and returns a pair containing
/// the path to a test and its result.
fn parse_log_line(line: &str) -> (Vec<String>, bool) {
    // Each line has the format `<result> [rmc] <path>`. Extract <result> and
    // <path>.
    let splits: Vec<_> = line.split(" [rmc] ").map(String::from).collect();
    let l = match splits[0].as_str() {
        "ok" => true,
        _ => false,
    };
    let mut ns: Vec<_> = splits[1].split(&['/', '.'][..]).map(String::from).collect();
    // Remove unnecessary `.rs` suffix.
    ns.pop();
    (ns, l)
}

/// Display the dashboard in the terminal.
fn display_dashboard(dashboard: dashboard::Tree) {
    println!(
        "# of tests: {}\t✔️ {}\t❌ {}",
        dashboard.data.num_pass + dashboard.data.num_fail,
        dashboard.data.num_pass,
        dashboard.data.num_fail
    );
    println!("{}", dashboard);
}

/// Extracts examples from The Rust Reference, run them through RMC, and
/// displays their results in a terminal dashboard.
pub fn display_reference_dashboard() {
    let summary_path: PathBuf = ["src", "doc", "reference", "src", "SUMMARY.md"].iter().collect();
    let ref_dir: PathBuf = ["src", "doc", "reference", "src"].iter().collect();
    let gen_dir: PathBuf = ["src", "tools", "dashboard", "target", "ref"].iter().collect();
    let log_path: PathBuf = ["src", "tools", "dashboard", "target", "ref.log"].iter().collect();
    // Parse the chapter/section hierarchy from the table of contents in The
    // Rust Reference.
    let map = parse_hierarchy(&summary_path);
    // Extract examples from The Rust Reference.
    extract_examples(map.keys().collect(), &ref_dir, &gen_dir);
    // Reorganize those examples following the The Rust Reference hierarchy.
    organize_examples(&map, &ref_dir, &gen_dir);
    // Pre-process the examples before running them through `compiletest`.
    preprocess_examples(map.values().collect());
    // Run `compiletest` on the reference examples.
    run_examples("ref", &log_path);
    // Parse `compiletest` log file.
    let dashboard = parse_log(&log_path);
    // Display the reference dashboard.
    display_dashboard(dashboard);
}
