// Copyright Kani Contributors
// SPDX-License-Identifier: Apache-2.0 OR MIT
//! This module contains methods handling the data needed
//! for the instrumentation of a single function body with updates from the
//! stacked borrows calculus. These data ensure that each of the original
//! locals is instrumented, that each of the original instructions
//! are instrumented, and that no code that is added by the instrumentation
//! pass itself is instrumented or analyzed.

use crate::kani_middle::transform::body::InsertPosition;
use rustc_middle::ty::TyCtxt;
use stable_mir::mir::{
    BasicBlock, Body, ConstOperand, Local, MirVisitor, Mutability, Operand, Place, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, UnwindAction
};
use stable_mir::ty::{GenericArgKind, MirConst, Span, Ty};
use std::collections::HashMap;

use super::super::body::{MutableBody, SourceInstruction};
use super::{Action, Cache, CollectActions, MirError, MirInstance, Signature};

type Result<T> = std::result::Result<T, MirError>;

pub struct InstrumentationData<'tcx, 'cache> {
    /// Compilation context, used to fetch resolved generic functions
    tcx: TyCtxt<'tcx>,
    /// Cache of resolved generic functions,
    /// potentially populated by previous passes
    cache: &'cache mut Cache,
    /// Map associating each local with a local storing
    /// its address on the stack, which is used to associate
    /// the metadata.
    meta_stack: HashMap<Local, Local>,
    /// The count of the number of locals in the original
    /// body
    local_count: usize,
    /// A local storing the unit value
    unit: Local,
    /// A local storing whether the stack is still in a valid
    /// state
    valid: Local,
    /// A map associating resolved generic functions with
    /// locals in the body that can be used to call them
    fn_pointers: HashMap<MirInstance, Local>,
    /// The span of the body
    span: Span,
    /// The body being instrumented
    body: MutableBody,
    /// The code actions for the instruction
    actions: Option<Vec<(SourceInstruction, Vec<Action>)>>,
}

impl<'tcx, 'cache> InstrumentationData<'tcx, 'cache> {
    /// Using a (potentially) pre-populated cache of resolved generic
    /// functions, and the StableMir body "body", initialize the instrumentation
    /// pass data.
    pub fn new(tcx: TyCtxt<'tcx>, cache: &'cache mut Cache, body: Body) -> Self {
        let mut visitor = CollectActions::new(body.locals());
        visitor.visit_body(&body);
        let actions = Some(visitor.finalize());
        let span = body.span;
        let mut body = MutableBody::from(body);
        let meta_stack = HashMap::new();
        let local_count = body.locals().len();
        let fn_pointers = HashMap::new();
        let unit = body.new_local(Ty::new_tuple(&[]), span, Mutability::Not);
        let valid = body.new_local(
            Ty::from_rigid_kind(stable_mir::ty::RigidTy::Bool),
            span,
            Mutability::Mut,
        );
        InstrumentationData {
            tcx,
            cache,
            meta_stack,
            local_count,
            unit,
            valid,
            fn_pointers,
            span,
            body,
            actions,
        }
    }

    /// Register the function described by the diagnostic
    /// and generic arguments in "Signature".
    fn register_fn(&mut self, callee: Signature) -> Result<Local> {
        let span = self.span;
        let instance = self.cache.register(&self.tcx, callee)?;
        let func_local = self
            .fn_pointers
            .entry(*instance)
            .or_insert_with(|| self.body.new_local(instance.ty(), span, Mutability::Not));
        Ok(*func_local)
    }

    /// Call at source and insert position, using the arguments
    /// in args and returning into "dest".
    /// This differs from Mutable Body's call in that the
    /// function name is cached.
    pub fn call(
        &mut self,
        callee: Signature,
        args: Vec<Local>,
        dest: Local,
        source: &SourceInstruction,
    ) -> Result<Terminator> {
        let fn_local = self.register_fn(callee)?;
        let func = Operand::Copy(Place::from(fn_local));
        let args = args.into_iter().map(|local| Operand::Copy(Place::from(local))).collect();
        let destination = Place::from(self.unit);
        let target = Some(0); // doesn't matter, updated later
        let unwind = UnwindAction::Terminate;
        let kind = TerminatorKind::Call { func, args, destination, target, unwind };
        let span = source.span(self.body.blocks());
        Ok(Terminator { kind, span })
    }

    /// Instrument the call generated by "call" for these parameters.
    pub fn instrument_call(
        &mut self,
        callee: Signature,
        args: Vec<Local>,
        dest: Local,
        source: &mut SourceInstruction) -> Result<()> {
        let terminator = self.call(callee, args, dest, source)?;
        let bb = BasicBlock { statements: vec![], terminator };
        self.body.insert_bb(bb, source, InsertPosition::Before);
        Ok(())
    }

    /// Instrument an assignment to a local
    pub fn assign_pointer(
        &mut self,
        lvalue: Local,
        rvalue: Local,
        source: &SourceInstruction,
    ) -> Statement {
        let span = source.span(&self.body.blocks());
        let rvalue = Rvalue::AddressOf(Mutability::Not, Place::from(rvalue));
        Statement { kind: StatementKind::Assign(Place::from(lvalue), rvalue), span }
    }

    pub fn first_instruction(&self) -> SourceInstruction {
        if self.body.blocks()[0].statements.is_empty() {
            SourceInstruction::Terminator { bb: 0 }
        } else {
            SourceInstruction::Statement { idx: 0, bb: 0 }
        }
    }

    /// For some local, say let x: T;
    /// instrument it with the functions that initialize the stack:
    /// let ptr_x: *const T = &raw const x;
    /// initialize_local(ptr_x);
    pub fn instrument_local(&mut self, local: Local) -> Result<()> {
        let ty = self.body.locals()[local].ty;
        let local_ptr = *self.meta_stack.get(&local).unwrap();
        let statement = self.assign_pointer(local_ptr, local, &self.first_instruction());
        let statements = vec![statement];
        let terminator = self.call(
            Signature::new("KaniInitializeLocal", &[GenericArgKind::Type(ty)]),
            vec![local_ptr],
            self.unit,
            &self.first_instruction(),
        )?;
        let bb = BasicBlock { statements, terminator };
        self.body.insert_bb(bb, &mut self.first_instruction(), InsertPosition::Before);
        Ok(())
    }

    /// Instrument a stack reference of the fo
    /// lvalue = &rvalue
    /// with an update to the stacked borrows state,
    /// at the code index source.
    pub fn instrument_new_stack_reference(
        &mut self,
        source: &mut SourceInstruction,
        lvalue: Local,
        rvalue: Local,
    ) -> Result<()> {
        // Initialize the constants
        let ty = self.body.locals()[rvalue].ty;
        let lvalue_ref = self.meta_stack.get(&lvalue).unwrap();
        let rvalue_ref = self.meta_stack.get(&rvalue).unwrap();
        self.instrument_call(
            Signature::new("KaniNewMutRefFromValue", &[GenericArgKind::Type(ty)]),
            vec![*lvalue_ref, *rvalue_ref],
            self.unit,
            source,
        )?;
        Ok(())
    }

    /// Instrument with stack violated / not violated
    pub fn instrument_stack_check(&mut self, source: &mut SourceInstruction) -> Result<()> {
        self.instrument_call(Signature::new("KaniStackValid", &[]), vec![], self.valid, source)?;
        let assert = self.register_fn(Signature::new("KaniAssert", &[]))?;
        let msg = "Stacked borrows aliasing model violated.";
        self.body.insert_check_with_local(
            self.tcx,
            assert,
            source,
            InsertPosition::Before,
            self.valid,
            &msg,
        );
        Ok(())
    }

    /// Instrument a validity assertion on the stacked borrows state
    /// at idx for (place: &mut T).
    pub fn instrument_stack_update_ref(
        &mut self,
        source: &mut SourceInstruction,
        place: Local,
        ty: Ty,
    ) -> Result<()> {
        // Initialize the constants
        let place_ref = self.meta_stack.get(&place).unwrap();
        self.instrument_call(
            Signature::new("KaniStackCheckRef", &[GenericArgKind::Type(ty)]),
            vec![*place_ref],
            self.unit,
            source,
        )?;
        Ok(())
    }

    /// Instrument a validity assertion on the stacked borrows state
    /// at idx for (place: *const T).
    pub fn instrument_stack_update_ptr(
        &mut self,
        source: &mut SourceInstruction,
        place: Local,
        ty: Ty,
    ) -> Result<()> {
        // Initialize the constants
        let place_ref = self.meta_stack.get(&place).unwrap();
        self.instrument_call(
            Signature::new("KaniStackCheckPtr", &[GenericArgKind::Type(ty)]),
            vec![*place_ref],
            self.unit,
            source,
        )?;
        Ok(())
    }

    /// Instrument code of the form
    /// created = &mut *(raw: const *T).
    pub fn instrument_new_mut_ref_from_raw(
        &mut self,
        source: &mut SourceInstruction,
        created: Local,
        raw: Local,
        ty: Ty,
    ) -> Result<()> {
        // Initialize the constants
        let created_ref = self.meta_stack.get(&created).unwrap();
        let reference_ref = self.meta_stack.get(&raw).unwrap();
        self.instrument_call(
            Signature::new("KaniNewMutRefFromRaw", &[GenericArgKind::Type(ty)]),
            vec![*created_ref, *reference_ref],
            self.unit,
            source,
        )?;
        Ok(())
    }

    /// Instrument code of the form
    /// created = (ref: &mut T) as *mut T
    pub fn instrument_new_mut_raw_from_ref(
        &mut self,
        source: &mut SourceInstruction,
        created: Local,
        reference: Local,
        ty: Ty,
    ) -> Result<()> {
        // Initialize the constants
        let created_ref = self.meta_stack.get(&created).unwrap();
        let reference_ref = self.meta_stack.get(&reference).unwrap();
        self.instrument_call(
            Signature::new("KaniNewMutRawFromRef", &[GenericArgKind::Type(ty)]),
            vec![*created_ref, *reference_ref],
            self.unit,
            source,
        )?;
        Ok(())
    }

    /// Instrument each of the locals collected into values with
    /// initialization data.
    pub fn instrument_locals(&mut self) -> Result<()> {
        for local in ((self.body.arg_count() + 1)..self.local_count).rev() {
            self.instrument_local(local)?
        }
        Ok(())
    }

    /// Instrument the action given in "action" with the appropriate
    /// update to the stacked borrows state.
    fn instrument_action(&mut self, source: &mut SourceInstruction, action: Action) -> Result<()> {
        match action {
            Action::StackCheck => {
                self.instrument_stack_check(source);
                Ok(())
            },
            Action::NewStackReference { lvalue, rvalue } => {
                eprintln!("instrumenting stack ref");
                self.instrument_new_stack_reference(source, lvalue, rvalue)
            },
            Action::StackUpdateReference { place, ty } => {
                self.instrument_stack_update_ref(source, place, ty)
            },
            Action::NewMutRefFromRaw { lvalue, rvalue, ty } => {
                self.instrument_new_mut_ref_from_raw(source, lvalue, rvalue, ty)
            },
            Action::StackUpdatePointer { place, ty } => {
                self.instrument_stack_update_ptr(source, place, ty)
            },
            Action::NewMutRawFromRef { lvalue, rvalue, ty } => {
                self.instrument_new_mut_raw_from_ref(source, lvalue, rvalue, ty)
            },
        }
    }

    /// Instrument all of the instructions and terminators in the function body
    /// with appropriate updates to the stacked borrows state
    /// and with validity assertions on the stacked borrows state.
    pub fn instrument_instructions(&mut self) -> Result<()> {
        let to_instrument = self.actions.take().unwrap();
        for (mut source, actions) in to_instrument.into_iter().rev() {
            for action in actions.into_iter() {
                self.instrument_action(&mut source, action)?;
            }
        }
        Ok(())
    }

    pub fn instrument_initialize_stack_check(&mut self) {
        let mut source = self.first_instruction();
        let span = self.first_instruction().span(self.body.blocks());
        let lvalue = Place::from(0);
        let user_ty = None;
        let const_ = MirConst::from_bool(true);
        let operand = Operand::Constant(ConstOperand { span, user_ty, const_ });
        let statement = Statement { kind: StatementKind::Assign(Place::from(self.valid), Rvalue::Use(operand)), span };
        self.body.insert_stmt(statement, &mut source, InsertPosition::Before);
    }

    /// Run the passes and retrieve the mutable body
    pub fn finalize(mut self) -> Result<MutableBody> {
        for local in ((self.body.arg_count() + 1)..self.local_count).rev() {
            let ty = self.body.locals()[local].ty;
            let ptr_ty = Ty::new_ptr(ty, Mutability::Not);
            let local_ptr = self.body.new_local(ptr_ty, self.span, Mutability::Not);
            self.meta_stack.insert(local, local_ptr);
        }
        eprintln!("instrumenting instructions");
        self.instrument_instructions()?;
        self.instrument_locals()?;
        self.instrument_initialize_stack_check();
        Ok(self.body)
    }
}
