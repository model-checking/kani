// Copyright Kani Contributors
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! This module is the central location for handling assertions and assumptions in Kani.
//!
//! There are a few patterns we see with CBMC:
//!
//! 1. A Kani `check` is a CBMC `assert`, which allows execution to proceed if it fails.
//! 2. A Kani `assume` is a CBMC `assume`, thankfully.
//! 3. A Kani `assert` is a CBMC `assert-assume`, first checking the property, then terminating the trace if it fails.
//!
//! Kani further offers a few special cases:
//!
//! 4. `codegen_unimplemented` : `assert(false)` but recorded specially
//! 5. `codegen_sanity` : `assert` but not normally displayed as failure would be a Kani bug
//!

use crate::codegen_cprover_gotoc::utils;
use crate::codegen_cprover_gotoc::GotocCtx;
use cbmc::goto_program::{Expr, Location, Stmt, Type};
use cbmc::InternedString;
use rustc_span::Span;
use std::convert::AsRef;
use strum_macros::{AsRefStr, EnumString};
use tracing::debug;

/// Classifies the type of CBMC `assert`, as different assertions can have different semantics (e.g. cover)
///
/// Each property class should justify its existence with a note about the special handling it recieves.
#[derive(Debug, Clone, EnumString, AsRefStr)]
#[strum(serialize_all = "snake_case")]
pub enum PropertyClass {
    /// Overflow panics that can be generated by Intrisics.
    /// NOTE: Not all uses of this are found by rust-analyzer because of the use of macros. Try grep instead.
    ///
    /// SPECIAL BEHAVIOR: None TODO: Why should this exist?
    ArithmeticOverflow,
    /// The Rust `assume` instrinsic is `assert`'d by Kani, and gets this property class.
    ///
    /// SPECIAL BEHAVIOR: None? Possibly confusing to customers that a Rust assume is a Kani assert.
    Assume,
    /// See [GotocCtx::codegen_cover] below. Generally just an `assert(false)` that's not an error.
    ///
    /// SPECIAL BEHAVIOR: "Errors" for this type of assertion just mean "reachable" not failure.
    Cover,
    /// Ordinary (Rust) assertions and panics.
    ///
    /// SPECIAL BEHAVIOR: None, this is the default type of assertion.
    Assertion,
    /// Another instrinsic check.
    ///
    /// SPECIAL BEHAVIORL None TODO: Why should this exist?
    ExactDiv,
    /// The `kani::expect_fail` assertion.
    ///
    /// SPECIAL BEHAVIOR: Inverted interpretation of success/failure.
    /// (Note: Possibly this should be the same as Cover, or perhaps an ExplicitCover?)
    ExpectFail,
    /// Another instrinsic check.
    ///
    /// SPECIAL BEHAVIOR: None TODO: Why should this exist?
    FiniteCheck,
    /// Checks added by Kani compiler to detect safety conditions violation.
    /// E.g., things that trigger UB or unstable behavior.
    ///
    /// SPECIAL BEHAVIOR: None, but UB is perhaps interesting? Maybe rename this?
    SafetyCheck,
    /// Checks to ensure that Kani's code generation is correct.
    ///
    /// SPECIAL BEHAVIOR: Should not be normally rendered as a checked assertion, as it's expected to succeed.
    SanityCheck,
    /// See `codegen_unimplemented`. Used to indicate an unsupported construct was reachable.
    ///
    /// SPECIAL BEHAVIOR: Reachability is notable to measure Kani support. Also makes other properties UNDETERMINED.
    UnsupportedConstruct,
    /// When Rust determines code is unreachable, this is the `assert(false)` we emit.
    ///
    /// SPECIAL BEHAVIOR: None TODO: Why should this exist?
    Unreachable,
}

#[allow(dead_code)]
impl PropertyClass {
    pub fn as_str(&self) -> &str {
        self.as_ref()
    }
}

impl<'tcx> GotocCtx<'tcx> {
    /// Generates a CBMC assertion. Note: Does _NOT_ assume.
    pub fn codegen_assert(
        &self,
        cond: Expr,
        property_class: PropertyClass,
        message: &str,
        loc: Location,
    ) -> Stmt {
        assert!(cond.typ().is_bool());
        let property_name = property_class.as_str();
        Stmt::assert(cond, property_name, message, loc)
    }

    /// Generates a CBMC assertion, followed by an assumption of the same condition.
    pub fn codegen_assert_assume(
        &self,
        cond: Expr,
        property_class: PropertyClass,
        message: &str,
        loc: Location,
    ) -> Stmt {
        assert!(cond.typ().is_bool());
        let property_name = property_class.as_str();
        Stmt::block(
            vec![Stmt::assert(cond.clone(), property_name, message, loc), Stmt::assume(cond, loc)],
            loc,
        )
    }

    /// A shorthand for generating a CBMC assert-false. TODO: This should probably be eliminated!
    pub fn codegen_assert_false(
        &self,
        property_class: PropertyClass,
        message: &str,
        loc: Location,
    ) -> Stmt {
        // Convert Property Class to String
        let property_name = property_class.as_str();
        Stmt::assert_false(property_name, message, loc)
    }

    /// Kani hooks function calls to `panic` and calls this intead.
    pub fn codegen_panic(&self, span: Option<Span>, fargs: Vec<Expr>) -> Stmt {
        // CBMC requires that the argument to the assertion must be a string constant.
        // If there is one in the MIR, use it; otherwise, explain that we can't.
        assert!(!fargs.is_empty(), "Panic requires a string message");
        let msg = utils::extract_const_message(&fargs[0]).unwrap_or(String::from(
            "This is a placeholder message; Kani doesn't support message formatted at runtime",
        ));

        self.codegen_fatal_error(PropertyClass::Assertion, &msg, span)
    }

    /// Generate code for fatal error which should trigger an assertion failure and abort the
    /// execution.
    pub fn codegen_fatal_error(
        &self,
        property_class: PropertyClass,
        msg: &str,
        span: Option<Span>,
    ) -> Stmt {
        let loc = self.codegen_caller_span(&span);
        self.codegen_assert_assume(Expr::bool_false(), property_class, msg, loc)
    }

    /// Generate code to cover the given condition at the current location
    pub fn codegen_cover(&self, cond: Expr, msg: &str, span: Option<Span>) -> Stmt {
        let loc = self.codegen_caller_span(&span);
        // Should use Stmt::cover, but currently this doesn't work with CBMC
        // unless it is run with '--cover cover' (see
        // https://github.com/diffblue/cbmc/issues/6613). So for now use
        // assert(!cond).
        self.codegen_assert(cond.not(), PropertyClass::Cover, msg, loc)
    }

    /// Generate code to cover the current location
    pub fn codegen_cover_loc(&self, msg: &str, span: Option<Span>) -> Stmt {
        self.codegen_cover(Expr::bool_true(), msg, span)
    }

    /// Kani does not currently support all MIR constructs.
    ///
    /// This action will
    ///
    /// 1. Fail verification in a machine-detectable manner if reachable
    /// 2. Warn about unsupported features at compile-time
    pub fn codegen_unimplemented_expr(
        &mut self,
        operation_name: &str,
        t: Type,
        loc: Location,
        url: &str,
    ) -> Expr {
        let body = vec![
            self.codegen_unimplemented_stmt(operation_name, loc, url),
            t.nondet().as_stmt(loc).with_location(loc),
        ];

        Expr::statement_expression(body, t).with_location(loc)
    }

    /// Kani does not currently support all MIR constructs.
    ///
    /// This action will
    ///
    /// 1. Fail verification in a machine-detectable manner if reachable
    /// 2. Warn about unsupported features at compile-time
    pub fn codegen_unimplemented_stmt(
        &mut self,
        operation_name: &str,
        loc: Location,
        url: &str,
    ) -> Stmt {
        debug!("codegen_unimplemented: {} at {}", operation_name, loc.short_string());

        // Save this occurrence so we can emit a warning in the compilation report.
        let key: InternedString = operation_name.into();
        let entry = self.unsupported_constructs.entry(key).or_default();
        entry.push(loc);

        self.codegen_assert_assume(
            Expr::bool_false(),
            PropertyClass::UnsupportedConstruct,
            &GotocCtx::unsupported_msg(operation_name, Some(url)),
            loc,
        )
    }

    /// There are a handful of location where we want to codegen unimplemented... but also
    /// not really report these statically to the user on compilation. This does exactly
    /// the same thing as `codegen_unimplemented_stmt` but doesn't add it to the list
    /// of `unsupported_constructs`
    ///
    /// TODO: Ideally we'd eliminate this. Currently used in two places:
    ///
    /// 1. Functions where we skip codegen. Will eventually go away (we hope?)
    /// 2. TerminatorKind::Resume and TK::Abort. Related to unwind support.
    pub fn codegen_mimic_unimplemented(
        &mut self,
        operation_name: &str,
        loc: Location,
        url: &str,
    ) -> Stmt {
        debug!("codegen_mimic_unimplemented: {} at {}", operation_name, loc.short_string());

        self.codegen_assert_assume(
            Expr::bool_false(),
            PropertyClass::UnsupportedConstruct,
            &GotocCtx::unsupported_msg(operation_name, Some(url)),
            loc,
        )
    }

    /// Assertion that should always be true unless there is a bug in Kani.
    ///
    /// Not normally rendered as a property being checked to the user, and
    /// includes a bug-filing link for Kani if it fails.
    pub fn codegen_sanity(&self, cond: Expr, message: &str, loc: Location) -> Stmt {
        pub const BUG_REPORT_URL: &str =
            "https://github.com/model-checking/kani/issues/new?template=bug_report.md";

        let assert_msg = format!(
            "Kani-internal sanity check: {}. Please report failures:\n{}",
            message, BUG_REPORT_URL
        );

        self.codegen_assert_assume(cond, PropertyClass::SanityCheck, &assert_msg, loc)
    }
}
