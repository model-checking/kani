<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kani Rust Verifier</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-361bd844.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-23873f8a.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kani Rust Verifier</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Kani is an open-source verification tool that uses <a href="#comparison-with-other-tools">model checking</a> to analyze Rust programs.
Kani is useful for checking both safety and correctness of Rust code.</p>
<ul>
<li><em>Safety</em>: Kani automatically checks for many kinds of <a href="#undefined-behaviour">undefined behavior</a>.
This makes it particularly useful for verifying unsafe code blocks in Rust, where the “<a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#unsafe-superpowers">unsafe superpowers</a>” are unchecked by the compiler.</li>
<li><em>Correctness</em>: Kani automatically checks panics (e.g. <code>unwrap()</code> on <code>None</code>), arithmetic overflows, and custom correctness properties, either in the form of assertions (<code>assert!(...)</code>) or <a href="https://model-checking.github.io/kani/reference/experimental/contracts.html">function contracts</a>.</li>
</ul>
<p>Since Kani uses model checking, Kani will either prove the property, disprove the property (with a counterexample), or may run out of resources.</p>
<p>Kani uses proof harnesses to analyze programs.
Proof harnesses are similar to test harnesses, especially property-based test harnesses.</p>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p>Kani is currently under active development.
Releases are published <a href="https://github.com/model-checking/kani/releases">here</a>.
Major changes to Kani are documented in the <a href="https://model-checking.github.io/kani/rfc">RFC Book</a>.
We also publish updates on Kani use cases and features on our <a href="https://model-checking.github.io/kani-verifier-blog/">blog</a>.</p>
<p>There is support for a fair amount of Rust language features, but not all (e.g., concurrency).
Please see <a href="#limitations-8">Limitations</a> for a detailed list of supported features.</p>
<p>Kani releases every month.
As part of every release, Kani will synchronize with a recent nightly release of Rust, and so is generally up-to-date with the latest Rust language features.</p>
<p>If you encounter issues when using Kani, we encourage you to <a href="https://github.com/model-checking/kani/issues/new/choose">report them to us</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Kani offers an easy installation option on three platforms:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code> (Most Linux distributions)</li>
<li><code>x86_64-apple-darwin</code> (Intel Mac OS)</li>
<li><code>aarch64-apple-darwin</code> (Apple Silicon Mac OS)</li>
</ul>
<p>Other platforms are either not yet supported or require instead that
you <a href="#installing-from-source-code">build from source</a>. To use Kani in your
GitHub CI workflows, see <a href="#github-action">GitHub CI Action</a>.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>The following must already be installed:</p>
<ul>
<li>Rust 1.58 or newer installed via <code>rustup</code>.</li>
</ul>
<h2 id="installing-the-latest-version"><a class="header" href="#installing-the-latest-version">Installing the latest version</a></h2>
<p>Installing the latest version of Kani is a two step process.</p>
<p>First, download and build Kani’s installer package using:</p>
<pre><code class="language-bash">cargo install --locked kani-verifier
</code></pre>
<p>This will build and place in <code>~/.cargo/bin</code> (in a typical environment) the <code>kani</code> and <code>cargo-kani</code> binaries.</p>
<p>Next, run the installer to download and install the prebuilt binaries as well as supporting libraries and data:</p>
<pre><code class="language-bash">cargo kani setup
</code></pre>
<p>The second step will download the Kani compiler and other necessary dependencies, and place them under <code>~/.kani/</code> by default.
A custom path can be specified using the <code>KANI_HOME</code> environment variable.</p>
<h2 id="installing-an-older-version"><a class="header" href="#installing-an-older-version">Installing an older version</a></h2>
<pre><code class="language-bash">cargo install --locked kani-verifier --version &lt;VERSION&gt;
cargo kani setup
</code></pre>
<h2 id="checking-your-installation"><a class="header" href="#checking-your-installation">Checking your installation</a></h2>
<p>After you’ve installed Kani,
you can try running it by creating a test file:</p>
<pre><code class="language-rust">// File: test.rs
#[kani::proof]
fn main() {
    assert!(1 == 2);
}</code></pre>
<p>Run Kani on the single file:</p>
<pre><code>kani test.rs
</code></pre>
<p>You should get a result like this one:</p>
<pre><code>[...]
RESULTS:
Check 1: main.assertion.1
         - Status: FAILURE
         - Description: "assertion failed: 1 == 2"
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Fix the test and you should see a result like this one:</p>
<pre><code>[...]
VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>If you’re learning Kani for the first time, you may be interested in our <a href="#tutorial">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installing-from-source-code"><a class="header" href="#installing-from-source-code">Installing from source code</a></h1>
<blockquote>
<p>If you were able to <a href="#installation">install Kani</a> normally, you do not need to build Kani from source.
You probably want to proceed to the <a href="#tutorial">Kani tutorial</a>.</p>
</blockquote>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>In general, the following dependencies are required to build Kani from source.</p>
<blockquote>
<p><strong>NOTE</strong>: These dependencies may be installed by running the scripts shown
below and don’t need to be manually installed.</p>
</blockquote>
<ol>
<li>Cargo installed via <a href="https://rustup.rs/">rustup</a></li>
<li><a href="https://github.com/diffblue/cbmc">CBMC</a> (latest release)</li>
<li><a href="https://github.com/arminbiere/kissat">Kissat</a> (Release 4.0.1)</li>
<li><a href="https://github.com/Z3Prover/z3">Z3</a></li>
<li><a href="https://github.com/cvc5/cvc5">cvc5</a></li>
</ol>
<p>Kani has been tested in <a href="#install-dependencies-on-ubuntu">Ubuntu</a> and <a href="##install-dependencies-on-macos">macOS</a> platforms.</p>
<h3 id="install-dependencies-on-ubuntu"><a class="header" href="#install-dependencies-on-ubuntu">Install dependencies on Ubuntu</a></h3>
<p>Support is available for Ubuntu 20.04, 22.04, and 24.04.
The simplest way to install dependencies (especially if you’re using a fresh VM)
is following our CI scripts:</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
 # For Ubuntu 20.04, use: `./scripts/setup/ubuntu-20.04/install_deps.sh`
./scripts/setup/ubuntu/install_deps.sh
# If you haven't already (or from https://rustup.rs/):
./scripts/setup/install_rustup.sh
source $HOME/.cargo/env
</code></pre>
<h3 id="install-dependencies-on-macos"><a class="header" href="#install-dependencies-on-macos">Install dependencies on macOS</a></h3>
<p>Support is available for macOS 11. You need to have <a href="https://brew.sh/">Homebrew</a> installed already.</p>
<pre><code># git clone git@github.com:model-checking/kani.git
git clone https://github.com/model-checking/kani.git
cd kani
git submodule update --init
./scripts/setup/macos/install_deps.sh
# If you haven't already (or from https://rustup.rs/):
./scripts/setup/install_rustup.sh
source $HOME/.cargo/env
</code></pre>
<h2 id="build-and-test-kani"><a class="header" href="#build-and-test-kani">Build and test Kani</a></h2>
<p>Build the Kani package using:</p>
<pre><code>cargo build-dev -- --release
</code></pre>
<p>to compile with optimizations turned on or using:</p>
<pre><code>cargo build-dev
</code></pre>
<p>to compile in debug/development mode.</p>
<p>Then, optionally, run the regression tests:</p>
<pre><code>./scripts/kani-regression.sh
</code></pre>
<p>This script has a lot of noisy output, but on a successful run you’ll see at the end of the execution:</p>
<pre><code>All Kani regression tests completed successfully.
</code></pre>
<h2 id="adding-kani-to-your-path"><a class="header" href="#adding-kani-to-your-path">Adding Kani to your path</a></h2>
<p>To use a locally-built Kani from anywhere, add the Kani scripts to your path:</p>
<pre><code class="language-bash">export PATH=$(pwd)/scripts:$PATH
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<p>If you’re learning Kani for the first time, you may be interested in our <a href="#tutorial">tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="github-action"><a class="header" href="#github-action">GitHub Action</a></h1>
<p>Kani offers a GitHub Action for running Kani in CI.
As of now, only Ubuntu 20.04 with <code>x86_64-unknown-linux-gnu</code> is supported for Kani in CI.</p>
<h2 id="using-kani-in-your-github-workflow"><a class="header" href="#using-kani-in-your-github-workflow">Using Kani in your GitHub workflow</a></h2>
<p>Our GitHub Action is available in the <a href="https://github.com/marketplace/actions/kani-rust-verifier">GitHub Marketplace</a>.</p>
<p>The following workflow snippet will checkout your repository and run <code>cargo kani</code> on it whenever a push or pull request occurs.
Replace <code>&lt;MAJOR&gt;.&lt;MINOR&gt;</code> with the version of Kani you want to run with.</p>
<pre><code class="language-yaml">name: Kani CI
on:
  pull_request:
  push:
jobs:
  run-kani:
    runs-on: ubuntu-20.04
    steps:
      - name: 'Checkout your code.'
        uses: actions/checkout@v3

      - name: 'Run Kani on your code.'
        uses: model-checking/kani-github-action@v&lt;MAJOR&gt;.&lt;MINOR&gt;
</code></pre>
<p>This will run <code>cargo kani</code> on the code you checked out.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>The action takes the following optional parameters:</p>
<ul>
<li><code>command</code>: The command to run.
Defaults to <code>cargo kani</code>.
Most often, you will not need to change this.</li>
<li><code>working-directory</code>: The directory to execute the command in.
Defaults to <code>.</code>.
Useful if your repository has multiple crates, and you only want to run on one of them.</li>
<li><code>args</code>: The arguments to pass to the given <code>${command}</code>.
See <code>cargo kani --help</code> for a full list of options.
Useful options include:
<ul>
<li><code>--output-format=terse</code> to generate terse output.</li>
<li><code>--sarif &lt;path&gt;</code> to write a SARIF report that can be uploaded to GitHub Code Scanning.</li>
<li><code>--tests</code> to run on proofs inside the <code>test</code> module (needed for running Bolero).</li>
<li><code>--workspace</code> to run on all crates within your repository.</li>
</ul>
</li>
</ul>
<h3 id="uploading-sarif-to-github-code-scanning"><a class="header" href="#uploading-sarif-to-github-code-scanning">Uploading SARIF to GitHub Code Scanning</a></h3>
<p>If you run Kani with <code>--sarif</code>, you can upload the report so results show up as Code Scanning alerts.</p>
<pre><code class="language-yaml">      - name: 'Run Kani on your code.'
        uses: model-checking/kani-github-action@v&lt;MAJOR&gt;.&lt;MINOR&gt;
        with:
          args: --sarif kani.sarif

      - name: 'Upload SARIF'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: kani.sarif
</code></pre>
<p>Your workflow must grant <code>security-events: write</code> permissions to upload SARIF results.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<ul>
<li><strong>Kani takes too long for my CI</strong>: Try running Kani on a
<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">schedule</a>
with desired frequency.</li>
<li><strong>Kani Silently Crashes with no logs</strong>: Few possible reasons:
<ul>
<li>Kani ran out of RAM. GitHub offers up to 7GB of RAM, but Kani may
use more. Run locally to confirm.</li>
<li>GitHub terminates jobs longer than 6 hours.</li>
<li>Otherwise, consider filing an issue <a href="https://github.com/model-checking/kani/issues">here</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-kani"><a class="header" href="#using-kani">Using Kani</a></h1>
<p>At present, Kani can used in two ways:</p>
<ul>
<li><a href="#usage-on-a-single-crate">On a single crate</a> with the <code>kani</code> command.</li>
<li><a href="#usage-on-a-package">On a Cargo package</a> with the <code>cargo kani</code> command.</li>
</ul>
<p>If you plan to integrate Kani in your projects, the recommended approach is to use <code>cargo kani</code>.
If you’re already using cargo, this will handle dependencies automatically, and it can be configured (if needed) in <code>Cargo.toml</code>.
But <code>kani</code> is useful for small examples/tests.</p>
<h2 id="usage-on-a-package"><a class="header" href="#usage-on-a-package">Usage on a package</a></h2>
<p>Kani is integrated with <code>cargo</code> and can be invoked from a package as follows:</p>
<pre><code class="language-bash">cargo kani [OPTIONS]
</code></pre>
<p>This works like <code>cargo test</code> except that it will analyze all proof harnesses instead of running all test harnesses.</p>
<h2 id="common-command-line-flags"><a class="header" href="#common-command-line-flags">Common command line flags</a></h2>
<p>Common to both <code>kani</code> and <code>cargo kani</code> are many command-line flags:</p>
<ul>
<li>
<p><code>--concrete-playback=[print|inplace]</code>: <em>Experimental</em> feature that generates a Rust unit test case
that plays back a failing proof harness using a concrete counterexample.
If used with <code>print</code>, Kani will only print the unit test to stdout.
If used with <code>inplace</code>, Kani will automatically add the unit test to the user’s source code, next to the proof harness. For more detailed instructions, see the <a href="experimental/concrete-playback.html">concrete playback</a> section.</p>
</li>
<li>
<p><code>--tests</code>: Build in “<a href="https://doc.rust-lang.org/rustc/tests/index.html">test mode</a>”, i.e. with <code>cfg(test)</code> set and <code>dev-dependencies</code> available (when using <code>cargo kani</code>).</p>
</li>
<li>
<p><code>--harness &lt;name&gt;</code>: By default, Kani checks all proof harnesses it finds.
You can switch to checking a single harness using this flag.</p>
</li>
<li>
<p><code>--default-unwind &lt;n&gt;</code>: Set a default global upper <a href="#loops-unwinding-and-bounds">loop unwinding</a> bound for proof harnesses.
This can force termination when CBMC tries to unwind loops indefinitely.</p>
</li>
</ul>
<p>Run <code>cargo kani --help</code> to see a complete list of arguments.</p>
<h2 id="usage-on-a-single-crate"><a class="header" href="#usage-on-a-single-crate">Usage on a single crate</a></h2>
<p>For small examples or initial learning, it’s very common to run Kani on just one source file.
The command line format for invoking Kani directly is the following:</p>
<pre><code>kani filename.rs [OPTIONS]
</code></pre>
<p>This will build <code>filename.rs</code> and run all proof harnesses found within.</p>
<h2 id="configuration-in-cargotoml"><a class="header" href="#configuration-in-cargotoml">Configuration in <code>Cargo.toml</code></a></h2>
<p>Users can add a default configuration to the <code>Cargo.toml</code> file for running harnesses in a package.
Kani will extract any arguments from these sections:</p>
<ul>
<li><code>[workspace.metadata.kani.flags]</code></li>
<li><code>[package.metadata.kani.flags]</code></li>
</ul>
<p>For example, if you want to set a default loop unwinding bound (when it’s not otherwise specified), you can achieve this by adding the following lines to the package’s <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.kani.flags]
default-unwind = "1"
</code></pre>
<p>The options here are the same as on the command line (<code>cargo kani --help</code>), and flags (that is, command line arguments that don’t take a value) are enabled by setting them to <code>true</code>.</p>
<p>Starting with Rust 1.80 (or nightly-2024-05-05), every reachable #[cfg] will be automatically checked that they match the expected config names and values.
To avoid warnings on <code>cfg(kani)</code>, we recommend adding the <code>check-cfg</code> lint config in your crate’s <code>Cargo.toml</code> as follows:</p>
<pre><code class="language-toml">[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(kani)'] }
</code></pre>
<p>For more information please consult this <a href="https://blog.rust-lang.org/2024/05/06/check-cfg.html">blog post</a>.</p>
<h2 id="the-build-process"><a class="header" href="#the-build-process">The build process</a></h2>
<p>When Kani builds your code, it does three important things:</p>
<ol>
<li>It sets <code>cfg(kani)</code> for target crate compilation (including dependencies).</li>
<li>It injects the <code>kani</code> crate.</li>
<li>It sets <code>cfg(kani_host)</code> for host build targets such as any build script and procedural macro crates.</li>
</ol>
<p>A proof harness (which you can <a href="#tutorial">learn more about in the tutorial</a>), is a function annotated with <code>#[kani::proof]</code> much like a test is annotated with <code>#[test]</code>.
But you may experience a similar problem using Kani as you would with <code>dev-dependencies</code>: if you try writing <code>#[kani::proof]</code> directly in your code, <code>cargo build</code> will fail because it doesn’t know what the <code>kani</code> crate is.</p>
<p>This is why we recommend the same conventions as are used when writing tests in Rust: wrap your proof harnesses in <code>cfg(kani)</code> conditional compilation:</p>
<pre><code class="language-rust">#[cfg(kani)]
mod verification {
    use super::*;

    #[kani::proof]
    pub fn check_something() {
        // ....
    }
}</code></pre>
<p>This will ensure that a normal build of your code will be completely unaffected by anything Kani-related.</p>
<p>This conditional compilation with <code>cfg(kani)</code> (as seen above) is still required for Kani proofs placed under <code>tests/</code>.
When this code is built by <code>cargo test</code>, the <code>kani</code> crate is not available, and so it would otherwise cause build failures.
(Whereas the use of <code>dev-dependencies</code> under <code>tests/</code> does not need to be gated with <code>cfg(test)</code> since that code is already only built when testing.)</p>
<h2 id="rust-analyzer-setup"><a class="header" href="#rust-analyzer-setup">Rust Analyzer Setup</a></h2>
<p>If you are using Rust Analyzer (e.g. in VS Code), we recommend using the following setup to allow Rust Analyzer to analyze Kani-specific code (e.g. Kani annotations, APIs, etc.) and get proper code completion and error:</p>
<ol>
<li>Add the following to your package’s <code>Cargo.toml</code>:</li>
</ol>
<pre><code class="language-toml">[target.'cfg(kani_ra)'.dependencies]
kani = { git = "https://github.com/model-checking/kani" }
</code></pre>
<p>This adds Kani as a dependency that is conditional on <code>kani_ra</code>.</p>
<ol start="2">
<li>Add the following to your Rust Analyzer configuration file (e.g. <code>settings.json</code> for VS Code):</li>
</ol>
<pre><code>    "rust-analyzer.cargo.extraEnv": {
        "RUSTFLAGS": "--cfg kani_ra --cfg kani",
        "RUSTUP_TOOLCHAIN": "nightly"
    },
</code></pre>
<p>Explanation:</p>
<ul>
<li>Enabling the <code>kani_ra</code> configuration allows Rust Analyzer to see the Kani definitions in the crate added in the <code>Cargo.toml</code> file.</li>
<li>Enabling the <code>kani</code> configuration enables blocks guarded by <code>#[cfg(kani)]</code>.</li>
<li>Finally, using the nightly toolchain is necessary for Rust Analyzer to be able to handle the code in the Kani dependency, many of which requires nightly features.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="verification-results"><a class="header" href="#verification-results">Verification results</a></h1>
<p>Running Kani on a harness produces an output that includes a set of checks as
follows:</p>
<pre><code>RESULTS:
Check 1: example.assertion.1
         - Status: &lt;status&gt;
         - Description: &lt;description&gt;
         - Location: &lt;location&gt;
[...]
</code></pre>
<p>Kani determines the verification result for the harness based on the
result (i.e., <code>&lt;status&gt;</code>) of each individual check (also known as “properties”). If all
checks are successful then the overall verification result of the harness is successful. Otherwise the
verification fails, which indicates issues with the code under verification.</p>
<h2 id="check-results"><a class="header" href="#check-results">Check results</a></h2>
<p>The result (or <code>Status</code>) of a check in Kani can be one of the following:</p>
<ol>
<li><code>SUCCESS</code>: This indicates that the check passed (i.e., the property holds).
Note that in some cases, the property may hold <em>vacuously</em>. This can occur
because the property is unreachable, or because the harness is
<em>over-constrained</em>.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn success_example() {
    let mut sum = 0;
    for i in 1..4 {
        sum += i;
    }
    assert_eq!(sum, 6);
}</code></pre>
<p>The output from Kani indicates that the assertion holds:</p>
<pre><code>Check 4: success_example.assertion.4
         - Status: SUCCESS
         - Description: "assertion failed: sum == 6"
</code></pre>
<ol start="2">
<li><code>FAILURE</code>: This indicates that the check failed (i.e., the property doesn’t
hold). In this case, please see the <a href="experimental/concrete-playback.html">concrete playback</a>
section for more help.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn failure_example() {
    let arr = [1, 2, 3];
    assert_ne!(arr.len(), 3);
}</code></pre>
<p>The assertion doesn’t hold as Kani’s output indicates:</p>
<pre><code>Check 2: failure_example.assertion.2
         - Status: FAILURE
         - Description: "assertion failed: arr.len() != 3"
</code></pre>
<ol start="3">
<li><code>UNREACHABLE</code>: This indicates that the check is unreachable (i.e., the
property holds <em>vacuously</em>). This occurs when there is no possible execution
trace that can reach the check’s line of code.
This may be because the function that contains the check is unused, or because
the harness does not trigger the condition under which the check is invoked.
Kani currently checks reachability for the following assertion types:
<ol>
<li>Assert macros (e.g. <code>assert</code>, <code>assert_eq</code>, etc.)</li>
<li>Arithmetic overflow checks</li>
<li>Negation overflow checks</li>
<li>Index out-of-bounds checks</li>
<li>Divide/remainder-by-zero checks</li>
</ol>
</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn unreachable_example() {
    let x = 5;
    let y = x + 2;
    if x &gt; y {
        assert!(x &lt; 8);
    }
}</code></pre>
<p>The output from Kani indicates that the assertion is unreachable:</p>
<pre><code>Check 2: unreachable_example.assertion.2
         - Status: UNREACHABLE
         - Description: "assertion failed: x &lt; 8"
</code></pre>
<ol start="4">
<li><code>UNDETERMINED</code>: This indicates that Kani was not able to conclude whether the
property holds or not. This can occur when the Rust program contains a construct
that is not currently supported by Kani. See
<a href="#rust-feature-support">Rust feature support</a> for Kani’s current support of the
Rust language features.</li>
</ol>
<p>Example:</p>
<pre><code class="language-rust">fn undetermined_example() {
    let mut x = 0;
    unsupp(&amp;mut x);
    assert!(x == 0);
}

#[feature(asm)]
fn unsupp(x: &amp;mut u8) {
    unsafe {
        std::arch::asm!("nop");
    }
}
</code></pre>
<p>The output from Kani indicates that the assertion is undetermined due to the
missing support for inline assembly in Kani:</p>
<pre><code>Check 2: undetermined_example.assertion.2
         - Status: UNDETERMINED
         - Description: "assertion failed: x == 0"
</code></pre>
<h2 id="cover-property-results"><a class="header" href="#cover-property-results">Cover property results</a></h2>
<p>Kani provides a <a href="https://model-checking.github.io/kani/crates/doc/kani/macro.cover.html"><code>kani::cover</code></a> macro that can be used for checking whether a condition may occur at a certain point in the code.</p>
<p>The result of a cover property can be one of the following:</p>
<ol>
<li><code>SATISFIED</code>: This indicates that Kani found an execution that triggers the specified condition.</li>
</ol>
<p>The following example uses <code>kani::cover</code> to check if it’s possible for <code>x</code> and <code>y</code> to hold the values 24 and 72, respectively, after 3 iterations of the <code>while</code> loop, which turns out to be the case.</p>
<pre><code class="language-rust">#[kani::unwind(256)]
fn cover_satisfied_example() {
    let mut x: u8 = kani::any();
    let mut y: u8 = kani::any();
    y /= 2;
    let mut i = 0;
    while x != 0 &amp;&amp; y != 0 {
        kani::cover!(i &gt; 2 &amp;&amp; x == 24 &amp;&amp; y == 72);
        if x &gt;= y { x -= y; }
        else { y -= x; }
        i += 1;
    }
}</code></pre>
<p>Results:</p>
<pre><code>Check 1: cover_satisfied_example.cover.1
         - Status: SATISFIED
         - Description: "cover condition: i &gt; 2 &amp;&amp; x == 24 &amp;&amp; y == 72"
         - Location: src/main.rs:60:9 in function cover_satisfied_example
</code></pre>
<ol start="2">
<li><code>UNSATISFIABLE</code>: This indicates that Kani <em>proved</em> that the specified condition is impossible.</li>
</ol>
<p>The following example uses <code>kani::cover</code> to check if it’s possible to have a UTF-8 encoded string consisting of 5 bytes that correspond to a string with a single character.</p>
<pre><code class="language-rust">#[kani::unwind(6)]
fn cover_unsatisfiable_example() {
    let bytes: [u8; 5] = kani::any();
    let s = std::str::from_utf8(&amp;bytes);
    if let Ok(s) = s {
        kani::cover!(s.chars().count() &lt;= 1);
    }
}</code></pre>
<p>which is not possible as such string will contain at least two characters.</p>
<pre><code>Check 46: cover_unsatisfiable_example.cover.1
         - Status: UNSATISFIABLE
         - Description: "cover condition: s.chars().count() &lt;= 1"
         - Location: src/main.rs:75:9 in function cover_unsatisfiable_example
</code></pre>
<ol start="3">
<li><code>UNREACHABLE</code>: This indicates that the <code>cover</code> property itself is unreachable (i.e. it is <em>vacuously</em> unsatisfiable).</li>
</ol>
<p>In contrast to an <code>UNREACHABLE</code> result for assertions, an unreachable (or an unsatisfiable) cover property may indicate an incomplete proof.</p>
<p>Example:
In this example, a <code>kani::cover</code> call is unreachable because if the outer <code>if</code> condition holds, then the non-empty range <code>r2</code> is strictly larger than the non-empty range <code>r1</code>, in which case, the condition in the inner <code>if</code> condition is impossible.</p>
<pre><code class="language-rust">#[kani::unwind(6)]
fn cover_unreachable_example() {
    let r1: std::ops::Range&lt;i32&gt; = kani::any()..kani::any();
    let r2: std::ops::Range&lt;i32&gt; = kani::any()..kani::any();
    kani::assume(!r1.is_empty());
    kani::assume(!r2.is_empty());
    if r2.start &gt; r1.end {
        if r2.end &lt; r1.end {
            kani::cover!(r2.contains(&amp;0));
        }
    }
}</code></pre>
<pre><code>Check 3: cover_unreachable_example.cover.1
         - Status: UNREACHABLE
         - Description: "cover condition: r2.contains(&amp;0)"
         - Location: src/main.rs:90:13 in function cover_unreachable_example
</code></pre>
<ol start="4">
<li><code>UNDETERMINED</code>: This is the same as the <code>UNDETERMINED</code> result for normal checks (see [check_results]).</li>
</ol>
<h2 id="verification-summary"><a class="header" href="#verification-summary">Verification summary</a></h2>
<p>Kani reports a summary at the end of the verification report, which includes the overall results of all checks, the overall results of cover properties (if the package includes cover properties), and the overall verification result, e.g.:</p>
<pre><code>SUMMARY:
 ** 0 of 786 failed (41 unreachable)

 ** 0 of 1 cover properties satisfied


VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="sarif-output"><a class="header" href="#sarif-output">SARIF output</a></h2>
<p>Kani can emit SARIF (Static Analysis Results Interchange Format) for integration with tools such as GitHub Code Scanning.</p>
<p>Generate a SARIF report:</p>
<pre><code class="language-bash">cargo kani --sarif kani.sarif
</code></pre>
<p>In GitHub Actions, upload the SARIF file:</p>
<pre><code class="language-yaml">- uses: github/codeql-action/upload-sarif@v3
  with:
    sarif_file: kani.sarif
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crates-documentation"><a class="header" href="#crates-documentation">Crates documentation</a></h1>
<p>Kani currently ships with a <code>kani</code> crate that provide APIs to allow users to
write and configure their harnesses.
These APIs are tightly coupled with each Kani version, so they are not
published yet at <a href="https://crates.io">https://crates.io</a>.</p>
<p>You can find their latest documentation here:</p>
<ul>
<li><a href="https://model-checking.github.io/kani/crates/doc/kani">kani</a>: This crate
provide APIs to write Kani harnesses.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<blockquote>
<p><strong>NOTE</strong>: This tutorial expects you to have followed the Kani <a href="#installation">installation instructions</a> first.</p>
</blockquote>
<p>This tutorial will step you through a progression from simple to moderately complex tasks with Kani.
It’s meant to ensure you can get started, and see at least some simple examples of how typical proofs are structured.
It will also teach you the basics of “debugging” proof harnesses, which mainly consists of diagnosing and resolving non-termination issues with the solver.</p>
<p>For a more in-depth overview of Kani’s features, see the <a href="#reference">Reference</a> section.</p>
<p>You may also want to read the <a href="#application">Application</a> section to better
understand what Kani is and how it can be applied on real code.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="first-steps"><a class="header" href="#first-steps">First steps</a></h1>
<p>Kani is unlike the testing tools you may already be familiar with.
Much of testing is concerned with thinking of new corner cases that need to be covered.
With Kani, all the corner cases are covered from the start, and the new concern is narrowing down the scope to something manageable for the verifier.</p>
<p>Consider this first program (which can be found under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v1/"><code>first-steps-v1</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            panic!("Oh no, a failing corner case!");
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}</code></pre>
<p>Think about the test harness you would need to write to test this function.
You would need figure out a whole set of arguments to call the function with that would exercise each branch.
You would also need to keep that test harness up-to-date with the code, in case some of the branches change.
And if this function was more complicated—for example, if some of the branches depended on global state—the test harness would be even more onerous to write.</p>
<p>We can try to property test a function like this, but if we’re naive about it (and consider all possible <code>u32</code> inputs), then it’s unlikely we’ll ever find the bug.</p>
<pre><code class="language-rust">    proptest! {
        #![proptest_config(ProptestConfig::with_cases(10000))]
        #[test]
        fn doesnt_crash(x: u32) {
            estimate_size(x);
        }
    }</code></pre>
<pre><code># cargo test
[...]
test tests::doesnt_crash ... ok
</code></pre>
<p>There’s only 1 in 4 billion inputs that fail, so it’s vanishingly unlikely the property test will find it, even with a million samples.</p>
<p>Let’s write a Kani <a href="#kaniproof"><em>proof harness</em></a> for <code>estimate_size</code>.
This is a lot like a test harness, but now we can use <code>kani::any()</code> to represent all possible <code>u32</code> values:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn check_estimate_size() {
    let x: u32 = kani::any();
    estimate_size(x);
}</code></pre>
<pre><code># cargo kani
[...]
Runtime decision procedure: 0.00116886s

RESULTS:
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: "Oh no, a failing corner case!"
[...]
VERIFICATION:- FAILED
</code></pre>
<p>Kani has immediately found a failure.
Notably, we haven’t had to write explicit assertions in our proof harness: by default, Kani will find a host of erroneous conditions which include a reachable call to <code>panic</code> or a failing <code>assert</code>.
If Kani had run successfully on this harness, this amounts to a mathematical proof that there is no input that could cause a panic in <code>estimate_size</code>.</p>
<blockquote>
<p>By default, Kani only reports failures, not how the failure happened.
In this example, it would be nice to get a concrete example of a value of <code>x</code> that triggers the failure.
Kani offers an (experimental) <a href="#concrete-playback">concrete playback</a> feature that serves this purpose.
As an exercise, try applying concrete playback to this example and see what Kani outputs.</p>
</blockquote>
<h3 id="exercise-try-other-failures"><a class="header" href="#exercise-try-other-failures">Exercise: Try other failures</a></h3>
<p>We put an explicit panic in this function, but it’s not the only kind of failure Kani will find.
Try a few other types of errors.</p>
<p>For example, instead of panicking we could try explicitly dereferencing a null pointer:</p>
<pre><code class="language-rust">unsafe { return *(0 as *const u32) };</code></pre>
<p>Notably, however, the Rust compiler emits a warning here:</p>
<pre><code>warning: dereferencing a null pointer
  --&gt; src/lib.rs:10:29
   |
10 |    unsafe { return *(0 as *const u32) };
   |                    ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed
   |
   = note: `#[warn(deref_nullptr)]` on by default
</code></pre>
<p>Still, it’s just a warning, and we can run the code without test failures just as before.
But Kani still catches the issue:</p>
<pre><code>[...]
RESULTS:
[...]
Check 2: estimate_size.pointer_dereference.1
         - Status: FAILURE
         - Description: "dereference failure: pointer NULL"
[...]
VERIFICATION:- FAILED
</code></pre>
<p><strong>Exercise: Can you find an example where the Rust compiler will not complain, and Kani will?</strong></p>
<details>
<summary>Click to show one possible answer</summary>
<pre><code>return 1 &lt;&lt; x;
</code></pre>
<p>Overflow (in addition, multiplication or, in this case, <a href="https://github.com/rust-lang/rust/issues/10183">bit-shifting by too much</a>) is also caught by Kani:</p>
<pre><code>RESULTS:
[...]
Check 1: estimate_size.assertion.1
         - Status: FAILURE
         - Description: "attempt to shift left with overflow"

Check 3: estimate_size.undefined-shift.1
         - Status: FAILURE
         - Description: "shift distance too large"
[...]
VERIFICATION:- FAILED
</code></pre>
</details>
<h2 id="assertions-assumptions-and-harnesses"><a class="header" href="#assertions-assumptions-and-harnesses">Assertions, Assumptions, and Harnesses</a></h2>
<p>It seems a bit odd that our example function is tested against billions of possible inputs, when it really only seems to be designed to handle a few thousand.
Let’s encode this fact about our function by asserting some reasonable upper bound on our input, after we’ve fixed our bug.
(New code available under <a href="https://github.com/model-checking/kani/tree/main/docs/src/tutorial/first-steps-v2/"><code>first-steps-v2</code></a>):</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    assert!(x &lt; 4096);

    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            return 4;
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}</code></pre>
<p>Now we’ve explicitly stated our previously implicit expectation: this function should never be called with inputs that are too big.
But if we attempt to verify this modified function, we run into a problem:</p>
<pre><code>[...]
RESULTS:
[...]
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: "assertion failed: x &lt; 4096"
[...]
VERIFICATION:- FAILED
</code></pre>
<p>What we want is a <em>precondition</em> for <code>estimate_size</code>.
That is, something that should always be true every time we call the function.
By putting the assertion at the beginning, we ensure the function immediately fails if that expectation is not met.</p>
<p>But our proof harness will still call this function with any integer, even ones that just don’t meet the function’s preconditions.
That’s… not a useful or interesting result.
We know that won’t work already.
How do we go back to successfully verifying this function?</p>
<p>This is the purpose of writing a proof harness.
Much like property testing (which would also fail in this assertion), we need to set up our preconditions, call the function in question, then assert our postconditions.
Here’s a revised example of the proof harness, one that now succeeds:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn verify_success() {
    let x: u32 = kani::any();
    kani::assume(x &lt; 4096);
    let y = estimate_size(x);
    assert!(y &lt; 10);
}</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani find panics, assertion failures, and even some other failures like unsafe dereferencing of null pointers.</li>
<li>We saw Kani find failures that testing could not easily find.</li>
<li>We saw how to write a proof harness and use <code>kani::any()</code>.</li>
<li>We saw how proof harnesses are used to set up preconditions with <code>kani::assume()</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="failures-that-kani-can-spot"><a class="header" href="#failures-that-kani-can-spot">Failures that Kani can spot</a></h1>
<p>In the <a href="#first-steps">last section</a>, we saw Kani spot two major kinds of failures: assertions and panics.
If the proof harness allows some program execution that results in a panic, then Kani will report that as a failure.
In addition, we saw (very briefly) a couple of other kinds of failures: null pointer dereferences and overflows.
In this section, we’re going to expand on these additional checks, to give you an idea of what other problems Kani will find.</p>
<h2 id="bounds-checking-and-pointers"><a class="header" href="#bounds-checking-and-pointers">Bounds checking and pointers</a></h2>
<p>Rust is safe by default, and so includes dynamic (run-time) bounds checking where needed.
Consider this Rust code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/bounds_check.rs">here</a>):</p>
<pre><code class="language-rust">/// Wrap "too-large" indexes back into a valid range for the array
fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    if a.len() == 0 {
        return 0;
    }
    return a[i % a.len() + 1];
}</code></pre>
<p>We can again write a simple property test against this code:</p>
<pre><code class="language-rust">    proptest! {
        #[test]
        fn doesnt_crash(i: usize, a: Vec&lt;u32&gt;) {
            get_wrapped(i, &amp;a);
        }
    }</code></pre>
<p>This property test will immediately find a failing case, thanks to Rust’s built-in bounds checking.</p>
<p>But what if we change this function to use unsafe Rust?</p>
<pre><code class="language-rust">return unsafe { *a.as_ptr().add(i % a.len() + 1) };</code></pre>
<p>Now the error becomes invisible to this test:</p>
<pre><code># cargo test
[...]
test bounds_check::tests::doesnt_crash ... ok
</code></pre>
<p>The property test still causes an out-of-bounds access, but this undefined behavior does not necessarily cause an immediate crash.
(This is part of why undefined behavior is so difficult to debug.)
Through the use of unsafe code, we removed the runtime check for an out of bounds access.
It just turned out that none of the randomly generated tests triggered behavior that actually crashed.
But if we write a Kani proof harness:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn bound_check() {
    let size: usize = kani::any();
    kani::assume(size &lt; 4096);
    let index: usize = kani::any();
    let array: Vec&lt;u32&gt; = vec![0; size];
    get_wrapped(index, &amp;array);
}</code></pre>
<p>And run this proof with:</p>
<pre><code class="language-bash">cargo kani --harness bound_check
</code></pre>
<p>We still see a failure from Kani, even without Rust’s runtime bounds checking.</p>
<blockquote>
<p>Also, notice there were many checks in the verification output.
(At time of writing, 345.)
This is a result of using the standard library <code>Vec</code> implementation, which means our harness actually used quite a bit of code, short as it looks.
Kani is inserting a lot more checks than appear as asserts in our code, so the output can be large.</p>
</blockquote>
<p>We get the following summary at the end:</p>
<pre><code>SUMMARY: 
 ** 1 of 345 failed (8 unreachable)
Failed Checks: dereference failure: pointer outside object bounds
 File: "./src/bounds_check.rs", line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
<p>Notice that, for Kani, this has gone from a simple bounds-checking problem to a pointer-checking problem.
Kani will check operations on pointers to ensure they’re not potentially invalid memory accesses.
Any unsafe code that manipulates pointers will, as we see here, raise failures if its behavior is actually a problem.</p>
<p>Consider trying a few more small exercises with this example:</p>
<ol>
<li>Exercise: Switch back to the normal/safe indexing operation and re-try Kani.
How does Kani’s output change, compared to the unsafe operation?
(Try predicting the answer, then seeing if you got it right.)</li>
<li>Exercise: Try Kani’s experimental <a href="#concrete-playback">concrete playback</a> feature on this example.</li>
<li>Exercise: Fix the error, run Kani, and see a successful verification.</li>
<li>Exercise: Try switching back to the unsafe code (now with the error fixed) and re-run Kani. Does it still verify successfully?</li>
</ol>
<details>
<summary>Click to see explanation for exercise 1</summary>
<p>Having switched back to the safe indexing operation, Kani reports a bounds check failure:</p>
<pre><code>SUMMARY:
 ** 1 of 343 failed (8 unreachable)
Failed Checks: index out of bounds: the length is less than or equal to the given index
 File: "src/bounds_check.rs", line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
</details>
<details>
<summary>Click to see explanation for exercise 2</summary>
<p><code>cargo kani -Z concrete-playback --concrete-playback=inplace --harness bound_check</code> produces the following test:</p>
<pre><code>rust
#[test]
fn kani_concrete_playback_bound_check_4752536404478138800() {
    let concrete_vals: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        // 1ul
        vec![1, 0, 0, 0, 0, 0, 0, 0],
        // 18446744073709551615ul
        vec![255, 255, 255, 255, 255, 255, 255, 255],
    ];
    kani::concrete_playback_run(concrete_vals, bound_check);
}
</code></pre>
<p>which indicates that substituting the concrete values <code>size = 1</code> and <code>index = 2^64</code> in our proof harness will produce the out of bounds access.</p>
</details>
<h2 id="overflow-and-math-errors"><a class="header" href="#overflow-and-math-errors">Overflow and math errors</a></h2>
<p>Consider a different variant on the function above:</p>
<pre><code class="language-rust">fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    return a[i % a.len()];
}</code></pre>
<p>We’ve corrected the out-of-bounds access, but now we’ve omitted the “base case”: what to return on an empty list.
Kani will spot this not as a bound error, but as a mathematical error: on an empty list the modulus operator (<code>%</code>) will cause a division by zero.</p>
<ol>
<li>Exercise: Try to run Kani on this version of <code>get_wrapped</code>, to see what this kind of failure looks like.</li>
</ol>
<p>Rust can also perform runtime safety checks for integer overflows, much like it does for bounds checks.
(<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">Though Rust disables this by default in <code>--release</code> mode, it can be re-enabled.</a>)
Consider this code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow.rs">here</a>):</p>
<pre><code class="language-rust">fn simple_addition(a: u32, b: u32) -&gt; u32 {
    return a + b;
}</code></pre>
<p>A trivial function, but if we write a property test for it, we immediately find inputs where it fails, thanks to Rust’s dynamic checks.
Kani will find these failures as well.
Here’s the output from Kani:</p>
<pre><code># cargo kani --harness add_overflow
[...]
SUMMARY: 
 ** 1 of 2 failed
Failed Checks: attempt to add with overflow
 File: "./src/overflow.rs", line 7, in overflow::simple_addition

VERIFICATION:- FAILED
</code></pre>
<p>This issue can be fixed using Rust’s alternative mathematical functions with explicit overflow behavior.
For instance, if the wrapping behavior is intended, you can write <code>a.wrapping_add(b)</code> instead of <code>a + b</code>.
Kani will then report no issues.</p>
<h3 id="exercise-classic-overflow-failure"><a class="header" href="#exercise-classic-overflow-failure">Exercise: Classic overflow failure</a></h3>
<p>A classic example of a subtle bug that persisted in many implementations for a very long time is “finding the midpoint” in quick sort.
This often naively looks like this (code available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow_quicksort.rs">here</a>):</p>
<pre><code class="language-rust">fn find_midpoint(low: u32, high: u32) -&gt; u32 {
    return (low + high) / 2;
}</code></pre>
<pre><code>cargo kani --harness midpoint_overflow
</code></pre>
<p>Kani immediately spots the bug in the above code.</p>
<ol>
<li>Exercise: Fix this function so it no longer overflows.
(Hint: depending on which approach you take, you may need to add the assumption that <code>high &gt; low</code> to your proof harness.
Don’t add that right away, see what happens if you don’t. Just keep it in mind.)</li>
<li>Exercise: Prove your new implementation actually finds the midpoint correctly by adding an assertion to the test harness.</li>
</ol>
<details>
<summary>Click to see solutions for these exercises</summary>
<p>A very common approach for resolving the overflow issue looks like this:</p>
<pre><code class="language-rust">return low + (high - low) / 2;</code></pre>
<p>But if you naively try this (try it!), you’ll find a new underflow error: <code>high - low</code> might result in a negative number, but has type <code>u32</code>.
Hence, the need to add the assumption we suggested above, to make that impossible.
(Adding an assumption, though, means there’s a new way to “use it wrong.” Perhaps we’d like to avoid that! Can you avoid the assumption?)</p>
<p>After that, you might wonder how to “prove your new implementation correct.”
After all, what does “correct” even mean?
Often we’re using a good approximation of correct, such as the equivalence of two implementations (often one much “simpler” than the other somehow).
Here’s one possible assertion we could write in the proof harness:</p>
<pre><code class="language-rust">assert!(result as u64 == (a as u64 + b as u64) / 2);</code></pre>
<p>You might have even come up with this approach to avoiding the overflow issue in the first place!
Having two different implementations, using different approaches, but proven to yield the same results, gives us greater confidence that we compute the correct result.</p>
</details>
<h2 id="failures-that-kani-cannot-spot"><a class="header" href="#failures-that-kani-cannot-spot">Failures that Kani cannot spot</a></h2>
<p>Check out <a href="#limitations-8">Limitations</a> for information on the checks that Kani does not perform.
Notably, Kani is not prioritizing all Rust-specific notions of undefined behavior.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani spot out-of-bounds accesses.</li>
<li>We saw Kani spot actually-unsafe dereferencing of a raw pointer to invalid memory.</li>
<li>We saw Kani spot a division by zero error and an overflowing addition.</li>
<li>As an exercise, we tried proving an assertion (finding the midpoint) that was not completely trivial.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loops-unwinding-and-bounds"><a class="header" href="#loops-unwinding-and-bounds">Loops, unwinding, and bounds</a></h1>
<p>Consider code like this (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/loops-unwinding/src/lib.rs">here</a>):</p>
<pre><code class="language-rust">fn initialize_prefix(length: usize, buffer: &amp;mut [u8]) {
    // Let's just ignore invalid calls
    if length &gt; buffer.len() {
        return;
    }

    for i in 0..=length {
        buffer[i] = 0;
    }
}</code></pre>
<p>This code has an off-by-one error that only occurs on the last iteration of the loop (when called with an input that will trigger it).
We can try to find this bug with a proof harness like this:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
#[kani::unwind(1)] // deliberately too low
fn check_initialize_prefix() {
    const LIMIT: usize = 10;
    let mut buffer: [u8; LIMIT] = [1; LIMIT];

    let length = kani::any();
    kani::assume(length &lt;= LIMIT);

    initialize_prefix(length, &amp;mut buffer);
}</code></pre>
<p>But we’ve just used a <a href="#kaniunwindnumber">new attribute</a> (<code>#[kani::unwind(1)]</code>) that requires some explanation.
When we run <code>cargo kani</code> on this code as we have written it, we see an odd verification failure:</p>
<pre><code>SUMMARY:
 ** 1 of 67 failed (66 undetermined)
Failed Checks: unwinding assertion loop 0

VERIFICATION:- FAILED
</code></pre>
<p>If we try removing this “unwind” annotation and re-running Kani, the result is worse: non-termination.
Kani simply doesn’t produce a result.</p>
<p>The problem we’re struggling with is the technique Kani uses to verify code.
We’re not able to handle code with “unbounded” loops, and what “bounded” means can be quite subtle.
It has to have a constant number of iterations that’s <em>“obviously constant”</em> enough for the verifier to actually figure this out.
In practice, very few loops are like this.</p>
<p>To verify programs like this with Kani as it exists today, we need to do two things:</p>
<ol>
<li>Set an upper bound on the size of the problem.
We’ve actually already done part of this: our proof harness above seems to be trying to set an upper <code>LIMIT</code> of 10.</li>
<li>Tell Kani about this limit if (or when) it’s not able to figure it out on its own.
This is the purpose of the <code>kani::unwind</code> annotation.</li>
</ol>
<p>Bounding proofs like this means we may no longer be proving as much as we originally hoped.
Who’s to say, if we prove everything works up to size 10, that there isn’t a novel bug lurking, reachable only with problems of size 11+?
Perhaps!
But, let’s get back to the issue at hand.</p>
<p>By putting <code>#[kani::unwind(1)]</code> on the proof harness, we’ve placed an upper bound of 1 loop iteration.
The “unwinding assertion” failure that Kani reports is because this bound is not high enough.
The code tries to execute more than 1 loop iteration.
(And, because the unwinding isn’t high enough, many of the other properties Kani is verifying become “undetermined”: we don’t really know if they’re true or false, because we can’t get far enough.)</p>
<p><strong>Exercise</strong>: Try increasing the bound. Where might you start? How high do you need to go to get rid of the “unwinding assertion” failure?</p>
<details>
<summary>Click to see explanation for the exercise</summary>
<p>Since the proof harness is trying to limit the array to size 10, an initial unwind value of 10 seems like the obvious place to start.
But that’s not large enough for Kani, and we still see the “unwinding assertion” failure.</p>
<p>At size 11, the “unwinding assertion” goes away, and now we can see the actual failure we’re trying to find too.
We’ll explain why we see this behavior in a moment.</p>
</details>
<p>Once we have increased the unwinding limit high enough, we’re left with these failures:</p>
<pre><code>SUMMARY:
 ** 1 of 68 failed
Failed Checks: index out of bounds: the length is less than or equal to the given index
 File: "./src/lib.rs", line 12, in initialize_prefix

VERIFICATION:- FAILED
</code></pre>
<p><strong>Exercise</strong>: Fix the off-by-one error, and get the (bounded) proof to go through.</p>
<p>We now return to the question: why is 11 the unwinding bound?</p>
<p>Kani needs the unwinding bound to be “one more than” the number of loop iterations.
We previously had an off-by-one error that tried to do 11 iterations on an array of size 10.
So… the unwinding bound needed to be 11, then.</p>
<blockquote>
<p><strong>NOTE</strong>: Presently, there are some situations where “number of iterations of a loop” can be less obvious than it seems.
This can be easily triggered with use of <code>break</code> or <code>continue</code> within loops.
Often this manifests itself as needing “two more” or “three more” iterations in the unwind bound than seems like it would actually run.
In those situations, we might still need a bound like <code>kani::unwind(13)</code>, despite looking like a loop bounded to 10 iterations.</p>
</blockquote>
<p>The approach we’ve taken here is a general method for getting a bounded proof to go through:</p>
<ol>
<li>Put an actual upper bound on the problem itself.
Here that’s accomplished via <code>LIMIT</code> in our proof harness.
We don’t create a slice any bigger than that, and that’s what we loop over.</li>
<li>Start at a reasonable guess for a <code>kani::unwind</code> bound, and increase until the unwinding assertion failure goes away.</li>
<li>Or, if that starts to take too long to verify, decrease your problem’s bound, to accommodate the verifier’s performance.</li>
</ol>
<h2 id="unwinding-value-specification"><a class="header" href="#unwinding-value-specification">Unwinding value specification</a></h2>
<p>The best approach to supplying Kani with unwind bounds is using the annotation <code>kani::unwind</code>, as we show above.</p>
<p>You might want to supply one via command line when experimenting, however.
In that case you can either use <code>--default-unwind x</code> to set an unwind bound for every proof harness that <strong>does not</strong> have an explicit bound.</p>
<p>Or you can <em>override</em> a harness’s bound, but only when running a specific harness:</p>
<pre><code>cargo kani --harness check_initialize_prefix --unwind 11
</code></pre>
<p>Finally, you might be interested in defaulting the unwind bound to 1, to force termination (and force supplying a bound) on all your proof harnesses.
You can do this by putting this into your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[workspace.metadata.kani.flags]
default-unwind = "1"
</code></pre>
<h2 id="bounded-proof"><a class="header" href="#bounded-proof">Bounded proof</a></h2>
<p>Before we finish, it’s worth revisiting the implications of what we’ve done here.
Kani frequently needs to do “bounded proof”, which contrasts with unbounded or full verification.</p>
<p>We’ve written a proof harness that shows <code>initialize_prefix</code> has no errors on input slices of size 10, but no higher.
The particular size we choose is usually determined by balancing the level of assurance we want, versus runtime of Kani.
It’s often not worth running proofs for large numbers of iterations, unless either very high assurance is necessary, or there’s reason to suspect larger problems will contain novel failure modes.</p>
<p><strong>Exercise</strong>: Try increasing the problem size (both the unwind and the <code>LIMIT</code> constant). When does it start to take more than a few seconds?</p>
<details>
<summary>Click to see explanation for the exercise</summary>
<p>On your friendly neighborhood author’s machine, a <code>LIMIT</code> of 100 takes about 3.8 seconds end-to-end.
This is a relatively simple bit of code, though, and it’s not uncommon for some proofs to scale poorly even to 5 iterations.</p>
</details>
<p>One consequence of this, however, is that Kani often scales poorly to “big string problems” like parsing.
Often a parser will need to consume inputs larger than 10-20 characters to exhibit strange behaviors.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani fail to terminate.</li>
<li>We saw how <code>#[kani::unwind(1)]</code> can help force Kani to terminate (with a verification failure).</li>
<li>We saw “unwinding assertions” verify that we’ve set the unwinding limit high enough.</li>
<li>We saw how to put a practical bound on problem size in our proof harness.</li>
<li>We saw how to pick an unwinding size large enough to successfully verify that bounded proof.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nondeterministic-variables"><a class="header" href="#nondeterministic-variables">Nondeterministic variables</a></h1>
<p>Kani is able to reason about programs and their execution paths by allowing users to create nondeterministic (also called symbolic) values using <code>kani::any()</code>.
Kani is a “bit-precise” model checker, which means that Kani considers all the possible bit-value combinations <em>that would be valid</em> if assigned to a variable’s memory contents.
In other words, <code>kani::any()</code> should not produce values that are invalid for the type (which would lead to Rust undefined behavior).</p>
<p>Out of the box, Kani includes <code>kani::any()</code> implementations for most primitive and some <code>std</code> types.
In this tutorial, we will show how to use <code>kani::any()</code> to create symbolic values for other types.</p>
<h2 id="safe-nondeterministic-variables"><a class="header" href="#safe-nondeterministic-variables">Safe nondeterministic variables</a></h2>
<p>Let’s say you’re developing an inventory management tool, and you would like to start verifying properties about your API.
Here is a simple example (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/arbitrary-variables/src/inventory.rs">here</a>):</p>
<pre><code class="language-rust">use std::num::NonZeroU32;
use vector_map::VecMap;

pub type ProductId = u32;

pub struct Inventory {
    /// Every product in inventory must have a non-zero quantity
    pub inner: VecMap&lt;ProductId, NonZeroU32&gt;,
}

impl Inventory {
    pub fn update(&amp;mut self, id: ProductId, new_quantity: NonZeroU32) {
        self.inner.insert(id, new_quantity);
    }

    pub fn get(&amp;self, id: &amp;ProductId) -&gt; Option&lt;NonZeroU32&gt; {
        self.inner.get(id).cloned()
    }
}</code></pre>
<p>Let’s write a fairly simple proof harness, one that just ensures we successfully <code>get</code> the value we inserted with <code>update</code>:</p>
<pre><code class="language-rust">    #[kani::proof]
    #[kani::unwind(3)]
    pub fn safe_update() {
        // Empty to start
        let mut inventory = Inventory { inner: VecMap::new() };

        // Create non-deterministic variables for id and quantity.
        let id: ProductId = kani::any();
        let quantity: NonZeroU32 = kani::any();
        assert!(quantity.get() != 0, "NonZeroU32 is internally a u32 but it should never be 0.");

        // Update the inventory and check the result.
        inventory.update(id, quantity);
        assert!(inventory.get(&amp;id).unwrap() == quantity);
    }</code></pre>
<p>We use <code>kani::any()</code> twice here:</p>
<ol>
<li><code>id</code> has type <code>ProductId</code> which was actually just a <code>u32</code>, and so any value is fine.</li>
<li><code>quantity</code>, however, has type <code>NonZeroU32</code>.
In Rust, it would be undefined behavior to have a value of <code>0</code> for this type.</li>
</ol>
<p>We included an extra assertion that the value returned by <code>kani::any()</code> here was actually non-zero.
If we run this, you’ll notice that verification succeeds.</p>
<pre><code class="language-bash">cargo kani --harness safe_update
</code></pre>
<p><code>kani::any()</code> is safe Rust, and so Kani only implements it for types where type invariants are enforced.
For <code>NonZeroU32</code>, this means we never return a <code>0</code> value.
The assertion we wrote in this harness was just an extra check we added to demonstrate this fact, not an essential part of the proof.</p>
<h2 id="custom-nondeterministic-types"><a class="header" href="#custom-nondeterministic-types">Custom nondeterministic types</a></h2>
<p>While <code>kani::any()</code> is the only method Kani provides to inject non-determinism into a proof harness, Kani only ships with implementations for a few <code>std</code> types where we can guarantee safety.
When you need nondeterministic variables of types that don’t have a <code>kani::any()</code> implementation available, you have the following options:</p>
<ol>
<li>Implement the <code>kani::Arbitrary</code> trait for your type, so you and downstream crates can use <code>kani::any()</code> with your type. See <a href="#arbitrary-trait">the Arbitrary trait documentation</a> for details.</li>
<li>Implement the <a href="https://docs.rs/bolero-generator/0.8.0/bolero_generator/trait.TypeGenerator.html"><code>bolero_generator::TypeGenerator</code> trait</a>.
This will enable you and downstream crates to use Kani via <a href="https://camshaft.github.io/bolero/">Bolero</a>.</li>
<li>Write a function that builds an object from non-deterministic variables.</li>
</ol>
<p>We recommend the first approach for most cases.
The first approach is simple and conventional. This option will also enable you to use it with parameterized types, such as <code>Option&lt;MyType&gt;</code> and arrays.
Kani includes a derive macro that allows you to automatically derive <code>kani::Arbitrary</code> for structures and enumerations as long as all its fields also implement the <code>kani::Arbitrary</code> trait.
One downside of this approach today is that the <code>kani</code> crate ships with Kani, but it’s not yet available on <a href="https://crates.io">crates.io</a>.
So you need to annotate the Arbitrary implementation with a <code>#[cfg(kani)]</code> attribute.
For the derive macro, use <code>#[cfg_attr(kani, derive(kani::Arbitrary))]</code>.</p>
<p>The second approach is recommended for cases where you would also like to be able to apply fuzzing or property testing.
The benefits of doing so were described in <a href="https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html">this blog post</a>.
Like <code>kani::Arbitrary</code>, this trait can also be used with a <code>derive</code> macro.
One thing to be aware of is that this type allow users to generate arbitrary values that include pointers.
In those cases, <strong>only the values pointed to are arbitrary</strong>, not the pointers themselves.</p>
<p>Finally, the last approach is recommended when you need to pass in parameters, like bounds on the size of the data structure.
(Which we’ll discuss more in the next section.)
This approach is also necessary when you need to generate a nondeterministic variable of a type that you’re importing from another crate, since Rust doesn’t allow you to implement a trait defined in an external crate for a type that you don’t own.</p>
<p>Either way, inside this function you would simply return an arbitrary value by generating arbitrary values for its components.
To generate a nondeterministic struct, you would just generate nondeterministic values for each of its fields.
For complex data structures like vectors or other containers, you can start with an empty one and add a (bounded) nondeterministic number of entries.</p>
<p>For example, for a simple enum you can just annotate it with the Arbitrary derive attribute:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
#[cfg_attr(kani, derive(kani::Arbitrary))]
pub enum Rating {
    One,
    Two,
    Three,
}</code></pre>
<p>But if the same enum is defined in an external crate, you can use a simple trick:</p>
<pre><code class="language-rust">    pub fn any_rating() -&gt; Rating {
        match kani::any() {
            0 =&gt; Rating::One,
            1 =&gt; Rating::Two,
            _ =&gt; Rating::Three,
        }
    }</code></pre>
<p>All we’re doing here is making use of a nondeterministic integer to decide which variant of <code>Rating</code> to return.</p>
<blockquote>
<p><strong>NOTE</strong>: If we thought of this code as generating a random value, this function looks heavily biased.
We’d overwhelmingly generate a <code>Three</code> because it’s matching “all other integers besides 1 and 2.”
But Kani just see 3 meaningful possibilities, each of which is not treated any differently from each other.
The “proportion” of integers does not matter.</p>
</blockquote>
<h2 id="bounding-nondeterministic-variables"><a class="header" href="#bounding-nondeterministic-variables">Bounding nondeterministic variables</a></h2>
<p>You can use <code>kani::any()</code> for <code>[T; N]</code> (if implemented for <code>T</code>) because this array type has an exact and constant size.
But if you wanted a slice (<code>[T]</code>) up to size <code>N</code>, you can no longer use <code>kani::any()</code> for that.
Likewise, there is no implementation of <code>kani::any()</code> for more complex data structures like <code>Vec</code>.</p>
<p>The trouble with a nondeterministic vector is that you usually need to <em>bound</em> the size of the vector, for the reasons we investigated in the <a href="#loops-unwinding-and-bounds">last chapter</a>.
The <code>kani::any()</code> function does not have any arguments, and so cannot be given an upper bound.</p>
<p>This does not mean you cannot have a nondeterministic vector.
It just means you have to construct one.
Our example proof harness above constructs a nondeterministic <code>Inventory</code> of size <code>1</code>, simply by starting with the empty <code>Inventory</code> and inserting a nondeterministic entry. Alternatively, you can implement or derive <code>BoundedArbitrary</code> for your type, which behaves like <code>Arbitrary</code>, except it accepts a fixed bound for the collection. See the <a href="#bounded-non-deterministic-variables">bounded arbitrary</a> documentation for details.</p>
<h3 id="exercise"><a class="header" href="#exercise">Exercise</a></h3>
<p>Try writing a function to generate a (bounded) nondeterministic inventory (from the first example:)</p>
<pre><code class="language-rust">fn any_inventory(bound: u32) -&gt; Inventory {
   // fill in here
}</code></pre>
<p>One thing you’ll quickly find is that the bounds must be very small.
Kani does not (yet!) scale well to nondeterministic-size data structures involving heap allocations.
A proof harness like <code>safe_update</code> above, but starting with <code>any_inventory(2)</code> will probably take a couple of minutes to prove.</p>
<p>A hint for this exercise: you might choose two different behaviors, “size of exactly <code>bound</code>” or “size up to <code>bound</code>”.
Try both!</p>
<p>A solution can be found in <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/arbitrary-variables/src/exercise_solution.rs"><code>exercise_solution.rs</code></a>.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw how <code>kani::any()</code> will return “safe” values for each of the types Kani implements it for.</li>
<li>We saw how to implement <code>kani::Arbitrary</code> or just write a function to create nondeterministic values for other types.</li>
<li>We noted that some types cannot implement <code>kani::any()</code> as they need a bound on their size.</li>
<li>We did an exercise to generate nondeterministic values of bounded size for <code>Inventory</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section is the main reference for Kani.
It contains sections that informally describe its main features.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arbitrary-trait"><a class="header" href="#arbitrary-trait">Arbitrary Trait</a></h1>
<p>The <code>Arbitrary</code> trait is the foundation for generating non-deterministic values in Kani proof harnesses. It allows you to create symbolic values that represent all possible values of a given type.</p>
<p>For a type to implement <code>Arbitrary</code>, Kani must be able to represent every possible value of it, so unbounded types cannot implement it. For nondeterministic representations of unbounded types, e.g., <code>Vec</code>, see the <a href="#bounded-non-deterministic-variables"><code>BoundedArbitrary</code> trait</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <code>Arbitrary</code> trait defines methods for generating arbitrary (nondeterministic) values:</p>
<pre><code class="language-rust">pub trait Arbitrary
where
    Self: Sized,
{
    fn any() -&gt; Self;
    fn any_array&lt;const MAX_ARRAY_LENGTH: usize&gt;() -&gt; [Self; MAX_ARRAY_LENGTH] {
        [(); MAX_ARRAY_LENGTH].map(|_| Self::any())
    }
}</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Use <code>kani::any()</code> to generate arbitrary values in proof harnesses:</p>
<pre><code class="language-rust">#[kani::proof]
fn verify_function() {
    let x: u32 = kani::any();
    let y: bool = kani::any();
    let z: [char; 10] = kani::any();
    
    // x represents all possible u32 values
    // y represents both true and false
    // z represents an array of length 10 where each element can hold all possible char values
    my_function(x, y, z);
}</code></pre>
<p>Kani implements <code>Arbitrary</code> for primitive types and some standard library types. See the <a href="https://model-checking.github.io/kani/crates/doc/kani/trait.Arbitrary.html#foreign-impls">crate trait documentation</a> for a full list of implementations.</p>
<h2 id="constrained-values"><a class="header" href="#constrained-values">Constrained Values</a></h2>
<p>Use <code>any_where</code> or <code>kani::assume()</code> to add constraints to arbitrary values:</p>
<pre><code class="language-rust">#[kani::proof]
fn verify_with_constraints() {
    let x: u32 = kani::any_where(|t| *t &lt; 1000); // Constrain x to be less than 1000
    kani::assume(x % 2 == 0); // Constrain x to be even
    
    // Now x represents all even numbers from 0 to 998
    my_function(x);
}

# Derive Implementations

Kani can automatically derive `Arbitrary` implementations for structs and enums when all their fields/variants implement `Arbitrary`:

## Structs

```rust
#[derive(kani::Arbitrary)]
struct Point {
    x: i32,
    y: i32,
}

#[kani::proof]
fn verify_point() {
    let point: Point = kani::any();
    // point.x and point.y can be any i32 values
    process_point(point);
}</code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<pre><code class="language-rust">#[derive(kani::Arbitrary)]
enum Status {
    Ready,
    Processing(u32),
    Error { code: (char, i32) },
}

#[kani::proof]
fn verify_status() {
    let status: Status = kani::any();
    // `status` can be any of the variants
    match status {
        Status::Ready =&gt; { /* ... */ }
        Status::Processing(id) =&gt; { /* id can be any u32 */ }
        Status::Error { code } =&gt; { /* code can be any (char, i32) tuple */ }
    }
}</code></pre>
<h2 id="manual-implementations"><a class="header" href="#manual-implementations">Manual Implementations</a></h2>
<p>Implement <code>Arbitrary</code> manually when you need constraints or custom logic. For example, Kani <a href="https://github.com/model-checking/kani/blob/100857e99d7506992c4589332a0d7d8dae1ee29a/library/kani_core/src/arbitrary.rs#L48-L60">manually implements <code>Arbitrary</code> for <code>NonZero</code> types</a> to exclude zero values, e.g:</p>
<pre><code class="language-rust">impl Arbitrary for NonZeroU8 {
    fn any() -&gt; Self {
        let val = u8::any();
        kani::assume(val != 0);
        unsafe { NonZeroU8::new_unchecked(val) }
    }
}</code></pre>
<p>An alternative means to add value constraints is provided by the <a href="https://model-checking.github.io/kani/crates/doc/kani/invariant/trait.Invariant.html">Invariant trait</a>.</p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#nondeterministic-variables">Nondeterministic Variables Tutorial</a></li>
<li><a href="#bounded-non-deterministic-variables">Bounded Non-deterministic Variables</a></li>
<li><a href="#first-steps">First Steps Tutorial</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>In Kani, attributes are used to mark functions as harnesses and control their execution.
This section explains the attributes available in Kani and how they affect the verification process.</p>
<p>At present, the available Kani attributes are the following:</p>
<ul>
<li><a href="#kaniproof"><code>#[kani::proof]</code></a></li>
<li><a href="#kanishould_panic"><code>#[kani::should_panic]</code></a></li>
<li><a href="#kaniunwindnumber"><code>#[kani::unwind(&lt;number&gt;)]</code></a></li>
<li><a href="#kanisolversolver"><code>#[kani::solver(&lt;solver&gt;)]</code></a></li>
<li><a href="#kanistuboriginal-replacement"><code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code></a></li>
<li><a href="#contract-attributes">Contract-related attributes</a></li>
</ul>
<h2 id="kaniproof"><a class="header" href="#kaniproof"><code>#[kani::proof]</code></a></h2>
<p><strong>The <code>#[kani::proof]</code> attribute specifies that a <a href="https://doc.rust-lang.org/reference/items/functions.html">function</a> is a proof harness.</strong></p>
<p>Proof harnesses are similar to test harnesses, especially property-based test harnesses,
and they may use functions from the Kani API (e.g., <code>kani::any()</code>).
A proof harness is the smallest verification unit in Kani.</p>
<p>When Kani is run, either through <code>kani</code> or <code>cargo kani</code>, it’ll first collect all proof harnesses
(i.e., functions with the attribute <code>#[kani::proof]</code>) and then attempt to verify them.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>If we run Kani on this example:</p>
<pre><code class="language-rust">#[kani::proof]
fn my_harness() {
    assert!(1 + 1 == 2);
}</code></pre>
<p>We should see a line in the output that says <code>Checking harness my_harness...</code> (assuming <code>my_harness</code> is the only harness in our code).
This will be followed by multiple messages that come from CBMC (the verification engine used by Kani) and the <a href="#verification-results">verification results</a>.</p>
<p>Using any other Kani attribute without <code>#[kani::proof]</code> will result in compilation errors.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>The <code>#[kani::proof]</code> attribute can only be added to functions without parameters.</p>
<h2 id="kanishould_panic"><a class="header" href="#kanishould_panic"><code>#[kani::should_panic]</code></a></h2>
<p><strong>The <code>#[kani::should_panic]</code> attribute specifies that a proof harness is expected to panic.</strong></p>
<p>This attribute allows users to exercise <em>negative verification</em>.
It’s analogous to how <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics"><code>#[should_panic]</code></a> allows users to exercise <a href="https://en.wikipedia.org/wiki/Negative_testing">negative testing</a> for Rust unit tests.</p>
<p>This attribute <strong>only affects the overall verification result</strong>.
In particular, using the <code>#[kani::should_panic]</code> attribute will return one of the following results:</p>
<ul>
<li><code>VERIFICATION:- FAILED (encountered no panics, but at least one was expected)</code> if there were no failed checks.</li>
<li><code>VERIFICATION:- FAILED (encountered failures other than panics, which were unexpected)</code> if there were failed checks but not all them were related to panics.</li>
<li><code>VERIFICATION:- SUCCESSFUL (encountered one or more panics as expected)</code> otherwise.</li>
</ul>
<p>At the moment, to determine if a check is related to a panic, we check if its class is <code>assertion</code>.
The class is the second member in the property name, the triple that’s printed after <code>Check X: </code>: <code>&lt;function&gt;.&lt;class&gt;.&lt;number&gt;</code>.
For example, the class in <code>Check 1: my_harness.assertion.1</code> is <code>assertion</code>, so this check is considered to be related to a panic.</p>
<blockquote>
<p><strong>NOTE</strong>: The <code>#[kani::should_panic]</code> is only recommended for writing
harnesses which complement existing harnesses that don’t use the same
attribute. In other words, it’s only recommended to write <em>negative harnesses</em>
after having written <em>positive</em> harnesses that successfully verify interesting
properties about the function under verification.</p>
</blockquote>
<h3 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h3>
<p>The <code>#[kani::should_panic]</code> attribute verifies that there are one or more failed checks related to panics.
At the moment, it’s not possible to pin it down to specific panics.
Therefore, <strong>it’s possible that the panics detected with <code>#[kani::should_panic]</code> aren’t the ones that were originally expected</strong> after a change in the code under verification.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Let’s assume we’re using the <code>Device</code> from this example:</p>
<pre><code class="language-rust">struct Device {
    is_init: bool,
}

impl Device {
    fn new() -&gt; Self {
        Device { is_init: false }
    }

    fn init(&amp;mut self) {
        assert!(!self.is_init);
        self.is_init = true;
    }
}</code></pre>
<p>We may want to verify that calling <code>device.init()</code> more than once should result in a panic.
We can do so with the following harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::should_panic]
fn cannot_init_device_twice() {
    let mut device = Device::new();
    device.init();
    device.init();
}</code></pre>
<p>Running Kani on it will produce the result <code>VERIFICATION:- SUCCESSFUL (encountered one or more panics as expected)</code></p>
<h2 id="kaniunwindnumber"><a class="header" href="#kaniunwindnumber"><code>#[kani::unwind(&lt;number&gt;)]</code></a></h2>
<p><strong>The <code>#[kani::unwind(&lt;number&gt;)]</code> attribute specifies that all loops must be unwound up to <code>&lt;number&gt;</code> times.</strong></p>
<p>By default, Kani attempts to unwind all loops automatically.
However, this unwinding process doesn’t always terminate.
The <code>#[kani::unwind(&lt;number&gt;)]</code> attribute will:</p>
<ol>
<li>Disable automatic unwinding.</li>
<li>Unwind all loops up to <code>&lt;number&gt;</code> times.</li>
</ol>
<p>After the unwinding stage, Kani will attempt to verify the harness.
If the <code>#[kani::unwind(&lt;number&gt;)]</code> attribute was specified, there’s a chance that one or more loops weren’t unwound enough times.
In that case, there will be at least one failed unwinding assertion (there’s one unwinding assertion for each loop), causing verification to fail.</p>
<p>Check the <a href="#loops-unwinding-and-bounds"><em>Loops, unwinding and bounds</em> section</a> for more information about unwinding.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>Let’s assume we’ve written this code which contains a loop:</p>
<pre><code class="language-rust">fn my_sum(vec: &amp;Vec&lt;u32&gt;) -&gt; u32 {
    let mut sum = 0;
    for elem in vec {
        sum += elem;
    }
    sum
}

#[kani::proof]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}</code></pre>
<p>Running this example on Kani will produce a successful verification result.
In this case, Kani automatically finds the required unwinding value (i.e., the number of times it needs to unwind all loops).
This means that the <code>#[kani::unwind(&lt;number&gt;)]</code> attribute isn’t needed, as we’ll see soon.
In general, the required unwinding value is equal to the maximum number of iterations for all loops, plus one.
The required unwinding value in this example is 4: the 3 iterations in the <code>for elem in vec</code> loop, plus 1.</p>
<p>Let’s see what happens if we force a lower unwinding value with <code>#[kani::unwind(3)]</code>:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(3)]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}</code></pre>
<p>As we mentioned, trying to verify this harness causes an unwinding failure:</p>
<pre><code>SUMMARY:
 ** 1 of 187 failed (186 undetermined)
Failed Checks: unwinding assertion loop 0
 File: "/home/ubuntu/devices/src/main.rs", line 32, in my_sum

VERIFICATION:- FAILED
[Kani] info: Verification output shows one or more unwinding failures.
[Kani] tip: Consider increasing the unwinding value or disabling `--unwinding-assertions`.
</code></pre>
<p>Kani cannot verify the harness because there is at least one unwinding assertion failure.
But, if we use <code>#[kani::unwind(4)]</code>, which is the right unwinding value we computed earlier:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(4)]
fn my_harness() {
    let vec = vec![1, 2, 3];
    let sum = my_sum(&amp;vec);
    assert!(sum == 6);
}</code></pre>
<p>We’ll get a successful result again:</p>
<pre><code>SUMMARY:
 ** 0 of 186 failed

VERIFICATION:- SUCCESSFUL
</code></pre>
<h2 id="kanisolversolver"><a class="header" href="#kanisolversolver"><code>#[kani::solver(&lt;solver&gt;)]</code></a></h2>
<p><strong>Changes the solver to be used by Kani’s verification engine (CBMC).</strong></p>
<p>This may change the verification time required to verify a harness.</p>
<p>At present, <code>&lt;solver&gt;</code> can be one of:</p>
<ul>
<li><code>minisat</code>: <a href="http://minisat.se/">MiniSat</a>.</li>
<li><code>cadical</code> (default): <a href="https://github.com/arminbiere/cadical">CaDiCaL</a>.</li>
<li><code>kissat</code>: <a href="https://github.com/arminbiere/kissat">kissat</a>.</li>
<li><code>z3</code>: <a href="https://github.com/Z3Prover/z3/">Z3</a>.</li>
<li><code>bitwuzla</code>: <a href="https://github.com/bitwuzla/bitwuzla">Bitwuzla</a>.</li>
<li><code>cvc5</code>: <a href="https://github.com/cvc5/cvc5">cvc5</a>.</li>
<li><code>bin="&lt;SAT_SOLVER_BINARY&gt;"</code>: A custom solver binary, <code>"&lt;SAT_SOLVER_BINARY&gt;"</code>, that must be in path.</li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>Kani will use the CaDiCaL solver in the following example:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::solver(cadical)]
fn check() {
    let mut a = [2, 3, 1];
    a.sort();
    assert_eq!(a[0], 1);
    assert_eq!(a[1], 2);
    assert_eq!(a[2], 3);
}</code></pre>
<p>Changing the solver may result in different verification times depending on the harness.</p>
<p>Note that the default solver may vary depending on Kani’s version.
We highly recommend users to annotate their harnesses if the choice of solver
has a major impact on performance, even if the solver used is the current
default one.</p>
<h2 id="kanistuboriginal-replacement"><a class="header" href="#kanistuboriginal-replacement"><code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code></a></h2>
<p><strong>Replaces the function/method with name <original> with the function/method with name <replacement> during compilation</replacement></original></strong></p>
<p>Check the <a href="#stubbing"><em>Stubbing</em> section</a> for more information about stubbing.</p>
<h2 id="contract-attributes"><a class="header" href="#contract-attributes">Contract Attributes</a></h2>
<p>There are numerous attributes for function and loop contracts. At present, these are:</p>
<ul>
<li>Proof harness for contracts: <code>#[kani::proof_for_contract(name-of-function)]</code></li>
<li>Verified stubbing: <code>#[kani::stub_verified]</code></li>
<li>Function contract specification: <code>#[kani::requires]</code>, <code>#[kani::modifies]</code>, <code>#[kani::ensures]</code>, <code>#[kani::recursion]</code></li>
<li>Loop contract specification: <code>#[kani::loop_invariant]</code>, <code>#[kani::loop_modifies]</code>.</li>
</ul>
<p>See the documentation on <a href="#contracts">function contracts</a> and <a href="#loop-contracts">loop contracts</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bounded-non-deterministic-variables"><a class="header" href="#bounded-non-deterministic-variables">Bounded Non-deterministic variables</a></h1>
<p>This is an experimental feature that allows you to bound otherwise unbounded types. For example, <code>Vec&lt;T&gt;</code> does not have an <code>Arbitrary</code> implementation because vectors can grow arbitrarily in size. One way of handling proofs about such types is to make the problem easier, and only prove a property up to some bound. Of course, the proof is only valid up to the bound, but can still be useful in providing confidence that your code is correct.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>As a toy example, let’s prove, up to some bound, that reversing a vector twice gives you back the original vector. Here’s a reversing function:</p>
<pre><code class="language-rust">fn reverse_vector&lt;T&gt;(mut input: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    let mut reversed = vec![];
    for _ in 0..input.len() {
        reversed.push(input.pop().unwrap());
    }
    reversed
}</code></pre>
<p>We can use <code>BoundedAny</code> to write a proof harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(17)]
fn check_reverse_is_its_own_inverse() {
    // We use BoundedAny to construct a vector that has at most length 16
    let input: Vec&lt;bool&gt; = kani::bounded_any::&lt;_, 16&gt;();

    let double_reversed = reverse_vector(reverse_vector(input.clone()));

    // we assert that every value in the input is the same as the value in the
    // doubly reversed list
    for i in 0..input.len() {
        assert_eq!(input[i], double_reversed[i])
    }
}</code></pre>
<p>Then, with <code>kani</code> we can prove that our reverse function is indeed its own inverse, for vectors up to size 16.</p>
<h2 id="proof-incompleteness"><a class="header" href="#proof-incompleteness">Proof Incompleteness</a></h2>
<p>It’s very important to note, that this is <strong>not</strong> a complete proof that this function is correct. To drive this point home, consider this bad implementation of <code>reverse_vector</code>:</p>
<pre><code class="language-rust">fn bad_reverse_vector&lt;T: Default&gt;(mut input: Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    let mut reversed = vec![];
    for i in 0..input.len() {
        if i &lt; 16 {
            reversed.push(input.pop().unwrap());
        } else {
            reversed.push(T::default())
        }
    }
    reversed
}</code></pre>
<p>Now the same harness as before is still successful! Even though this implementation is obviously wrong. If only we had tried a slightly bigger bound…</p>
<p>So, while bounded proofs can be useful, beware that they are also incomplete. It might be worth-while to test multiple bounds.</p>
<h2 id="custom-bounded-arbitrary-implementations"><a class="header" href="#custom-bounded-arbitrary-implementations">Custom Bounded Arbitrary implementations</a></h2>
<p>Kani provides several implementations of <code>BoundedArbitrary</code>, but you can also implement <code>BoundedArbitrary</code> for yourself.</p>
<p>We provide a derive macro that should work in most cases:</p>
<pre><code class="language-rust">#[derive(BoundedArbitrary)]
struct MyVector&lt;T&gt; {
    #[bounded]
    vector: Vec&lt;T&gt;,
    capacity: usize
}</code></pre>
<p>You must specify which fields should be bounded using the <code>#[bounded]</code> attribute. All other fields must derive <code>Arbitrary</code>.</p>
<h3 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h3>
<p>Currently you can only specify a single bound for the entire type, and all bounded fields use the same bound. If different bounds would be useful, let us know through <a href="https://github.com/model-checking/kani/issues/new/choose">filing an issue</a> and we can probably lift this restriction.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="list-command"><a class="header" href="#list-command">List Command</a></h1>
<p>The <code>list</code> subcommand provides an overview of harnesses and contracts in the provided project/file. This is useful for understanding which parts of your codebase have verification coverage and tracking verification progress.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>For basic usage, run <code>cargo kani list</code> or <code>kani list &lt;FILE&gt;</code>. The current options are:</p>
<ul>
<li><code>--format [pretty|markdown|json]</code>: Choose output format</li>
<li><code>--std</code>: List harnesses and contracts in the standard library (standalone <code>kani</code> only)</li>
</ul>
<p>The default format is <code>pretty</code>, which prints a table to the terminal, e.g:</p>
<pre><code>Kani Rust Verifier 0.65.0 (standalone)

Contracts:
+-------+----------+-------------------------------+----------------------------------------------------------------+
|       | Crate    | Function                      | Contract Harnesses (#[kani::proof_for_contract])               |
+=================================================================================================================+
|       | my_crate | example::implementation::bar  | example::verify::check_bar                                     |
|-------+----------+-------------------------------+----------------------------------------------------------------|
|       | my_crate | example::implementation::foo  | example::verify::check_foo_u32, example::verify::check_foo_u64 |
|-------+----------+-------------------------------+----------------------------------------------------------------|
|       | my_crate | example::implementation::func | example::verify::check_func                                    |
|-------+----------+-------------------------------+----------------------------------------------------------------|
|       | my_crate | example::prep::parse          | NONE                                                           |
|-------+----------+-------------------------------+----------------------------------------------------------------|
| Total |          | 4                             | 4                                                              |
+-------+----------+-------------------------------+----------------------------------------------------------------+

Standard Harnesses (#[kani::proof]):
+-------+----------+-------------------------------+
|       | Crate    | Harness                       |
+==================================================+
|       | my_crate | example::verify::check_modify |
|-------+----------+-------------------------------|
|       | my_crate | example::verify::check_new    |
|-------+----------+-------------------------------|
| Total |          | 2                             |
+-------+----------+-------------------------------+
</code></pre>
<p>The “Contracts” table shows functions that have contract attributes (<code>#[requires]</code>, <code>#[ensures]</code>, or <code>modifies</code>), and which harnesses exist for those functions.
The “Standard Harnesses” table lists all of the <code>#[kani::proof]</code> harnesses found.</p>
<p>The <code>markdown</code> and <code>json</code> options write the same information to Markdown or JSON files, respectively.</p>
<p>For <code>--std</code>, ensure that the provided path points to a local copy of the standard library, e.g. <code>kani list --std rust/library</code>. (Compiling the standard library <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std">works differently</a> than compiling a normal Rust project, hence the separate option).</p>
<p>For a full list of options, run <code>kani list --help</code>.</p>
<h2 id="autoharness"><a class="header" href="#autoharness">Autoharness</a></h2>
<p>Note that by default, this subcommand only detects manual harnesses. The <a href="#automatic-harness-generation">experimental autoharness feature</a> accepts a <code>--list</code> argument, which runs this subcommand for both manual harnesses and automatically generated harnesses.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="experimental-features"><a class="header" href="#experimental-features">Experimental Features</a></h1>
<p>We elaborate on some of the more commonly used experimental features in Kani.
This is not an exhaustive list; to see all of Kani’s experimental features, run <code>cargo kani --help</code>.
To use an experimental feature, invoke Kani with the <code>--unstable</code> or <code>-Z</code> flag followed by the name of the feature.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="automatic-harness-generation"><a class="header" href="#automatic-harness-generation">Automatic Harness Generation</a></h1>
<p>Recall the harness for <code>estimate_size</code> that we wrote in <a href="#first-steps">First Steps</a>:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn check_estimate_size() {
    let x: u32 = kani::any();
    estimate_size(x);
}</code></pre>
<p>This harness first declares a local variable <code>x</code> using <code>kani::any()</code>, then calls <code>estimate_size</code> with argument <code>x</code>.
Many proof harnesses follow this predictable format—to verify a function <code>foo</code>, we create arbitrary values for each of <code>foo</code>’s arguments, then call <code>foo</code> on those arguments.</p>
<p>The <code>autoharness</code> subcommand leverages this observation to automatically generate harnesses and run Kani against them.
Kani scans the crate for functions whose arguments all implement the <code>kani::Arbitrary</code> trait, generates harnesses for them, then runs them.
These harnesses are internal to Kani—i.e., Kani does not make any changes to your source code.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Run either:</p>
<pre><code># cargo kani autoharness -Z autoharness
</code></pre>
<p>or</p>
<pre><code># kani autoharness -Z autoharness &lt;FILE&gt;
</code></pre>
<p>If Kani detects that all of a function <code>foo</code>’s arguments implement <code>kani::Arbitrary</code>, it will generate and run a <code>#[kani::proof]</code> harness, which prints:</p>
<pre><code>Autoharness: Checking function foo against all possible inputs...
&lt;VERIFICATION RESULTS&gt;
</code></pre>
<p>However, if Kani detects that <code>foo</code> has a <a href="#contracts">function contract</a>, it will instead generate a <code>#[kani::proof_for_contract]</code> harness and verify the contract:</p>
<pre><code>Autoharness: Checking function foo's contract against all possible inputs...
&lt;VERIFICATION RESULTS&gt;
</code></pre>
<p>Similarly, Kani will detect the presence of <a href="#loop-contracts">loop contracts</a> and verify them.</p>
<p>Thus, <code>-Z autoharness</code> implies <code>-Z function-contracts</code> and <code>-Z loop-contracts</code>, i.e., opting into the experimental
autoharness feature means that you are also opting into the function contracts and loop contracts features.</p>
<p>Kani generates and runs these harnesses internally—the user only sees the verification results.</p>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<p>The <code>autoharness</code> subcommand has options <code>--include-pattern [REGEX]</code> and <code>--exclude-pattern [REGEX]</code> to include and exclude particular functions using regular expressions.
When matching, Kani prefixes the function’s path with the crate name. For example, a function <code>foo</code> in the <code>my_crate</code> crate will be matched as <code>my_crate::foo</code>.</p>
<p>The selection algorithm is as follows:</p>
<ul>
<li>If only <code>--include-pattern</code>s are provided, include a function if it matches any of the provided patterns.</li>
<li>If only <code>--exclude-pattern</code>s are provided, include a function if it does not match any of the provided patterns.</li>
<li>If both are provided, include a function if it matches an include pattern <em>and</em> does not match any of the exclude patterns. Note that this implies that the exclude pattern takes precedence, i.e., if a function matches both an include pattern and an exclude pattern, it will be excluded.</li>
</ul>
<p>Here are some examples:</p>
<pre><code class="language-bash"># Include functions containing foo but not bar
kani autoharness -Z autoharness --include-pattern 'foo' --exclude-pattern 'bar'

# Include my_crate::foo exactly
kani autoharness -Z autoharness --include-pattern '^my_crate::foo$'

# Include functions in the foo module, but not in foo::bar
kani autoharness -Z autoharness --include-pattern 'foo::.*' --exclude-pattern 'foo::bar::.*'

# Include functions starting with test_, but not if they're in a private module
kani autoharness -Z autoharness --include-pattern 'test_.*' --exclude-pattern '.*::private::.*'

# This ends up including nothing since all foo::bar matches will also contain bar.
# Kani will emit a warning that these options conflict.
kani autoharness -Z autoharness --include-pattern 'foo::bar' --exclude-pattern 'bar'
</code></pre>
<p>Note that because Kani prefixes function paths with the crate name, some patterns might match more than you expect.
For example, given a function <code>foo_top_level</code> inside crate <code>my_crate</code>, the regex <code>.*::foo_.*</code> will match <code>foo_top_level</code>, since Kani interprets it as <code>my_crate::foo_top_level</code>.
To match only <code>foo_</code> functions inside modules, use a more specific pattern, e.g. <code>.*::[^:]+::foo_.*</code>.</p>
<p>Autoharness also accepts a <code>--list</code> argument, which runs the <a href="#list-command">list subcommand</a> including automatic harnesses.</p>
<p>For a full list of options, run <code>kani autoharness --help</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>Using the <code>estimate_size</code> example from <a href="#first-steps">First Steps</a> again:</p>
<pre><code class="language-rust">fn estimate_size(x: u32) -&gt; u32 {
    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            panic!("Oh no, a failing corner case!");
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}</code></pre>
<p>We get:</p>
<pre><code># cargo kani autoharness -Z autoharness
Autoharness: Checking function estimate_size against all possible inputs...
RESULTS:
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: "Oh no, a failing corner case!"
[...]

Verification failed for - estimate_size
Complete - 0 successfully verified functions, 1 failures, 1 total.
</code></pre>
<h2 id="request-for-comments"><a class="header" href="#request-for-comments">Request for comments</a></h2>
<p>This feature is experimental and is therefore subject to change.
If you have ideas for improving the user experience of this feature,
please add them to <a href="https://github.com/model-checking/kani/issues/3832">this GitHub issue</a>.</p>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<h3 id="arguments-implementing-arbitrary"><a class="header" href="#arguments-implementing-arbitrary">Arguments Implementing Arbitrary</a></h3>
<p>Kani will only generate an automatic harness for a function if it can represent each of its arguments nondeterministically, without bounds.
In technical terms, each of the arguments needs to implement the <code>Arbitrary</code>
trait or be capable of deriving it, or be a reference (mutable or immutable)
where any of the prior requirements is fulfilled by the referenced type.
Kani will detect if a struct or enum could implement <code>Arbitrary</code> and derive it automatically.
Note that this automatic derivation feature is only available for autoharness.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>The current implementation does not generate harnesses for generic functions.
For example, given:</p>
<pre><code class="language-rust">fn foo&lt;T: Eq&gt;(x: T, y: T) {
    if x == y {
        panic!("x and y are equal");
    }
}</code></pre>
<p>Kani would report that no functions were eligible for automatic harness generation.</p>
<p>If, however, some caller of <code>foo</code> is eligible for an automatic harness, then a monomorphized version of <code>foo</code> may still be reachable during verification.
For instance, if we add <code>main</code>:</p>
<pre><code class="language-rust">fn main() {
    let x: u8 = 2;
    let y: u8 = 2;
    foo(x, y);
}</code></pre>
<p>and run the autoharness subcommand, we get:</p>
<pre><code>Autoharness: Checking function main against all possible inputs...

Failed Checks: x and y are equal
 File: "src/lib.rs", line 3, in foo::&lt;u8&gt;

VERIFICATION:- FAILED
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coverage"><a class="header" href="#coverage">Coverage</a></h1>
<p>Recall our <code>estimate_size</code> example from <a href="#first-steps">First steps</a>,
where we wrote a proof harness constraining the range of inputs to integers less than 4096:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn verify_success() {
    let x: u32 = kani::any();
    kani::assume(x &lt; 4096);
    let y = estimate_size(x);
    assert!(y &lt; 10);
}</code></pre>
<p>We must wonder if we’ve really fully tested our function.
What if we revise the function, but forget to update the assumption in our proof harness to cover the new range of inputs?</p>
<p>Fortunately, Kani is able to report a coverage metric for each proof harness.
In the <code>first-steps-v2</code> directory, try running:</p>
<pre><code>cargo kani --coverage -Z source-coverage --harness verify_success
</code></pre>
<p>which verifies the harness, then prints coverage information for each line.
In this case, we see that each line of <code>estimate_size</code> is followed by <code>FULL</code>, indicating that our proof harness provides full coverage.</p>
<p>Try changing the assumption in the proof harness to <code>x &lt; 2048</code>.
Now the harness won’t be testing all possible cases.
Rerun the command.
You’ll see this line:</p>
<pre><code>src/lib.rs, 24, NONE
</code></pre>
<p>which indicates that the proof no longer covers line 24, which addresses the case where <code>x &gt;= 2048</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stubbing"><a class="header" href="#stubbing">Stubbing</a></h1>
<p>Stubbing (or mocking) is an unstable feature which allows users to specify that certain items should be replaced with stubs (mocks) of those items during verification.
At present, the only items where stubbing can be applied are functions and methods (see <a href="#limitations-4">limitations</a> for more details).</p>
<h2 id="when-to-consider-stubbing"><a class="header" href="#when-to-consider-stubbing">When to consider stubbing</a></h2>
<p>In general, we have identified three reasons where users may consider stubbing:</p>
<ul>
<li><strong>Unsupported features:</strong> The code under verification contains features that Kani does not support, such as inline assembly.</li>
<li><strong>Bad performance:</strong> The code under verification contains features that Kani supports, but it leads to bad verification performance (for example, deserialization code).</li>
<li><strong>Compositional reasoning:</strong> The code under verification contains code that has been verified separately.
Stubbing the code that has already been verified with a less complex version that mimics its behavior can result in reduced verification workloads.</li>
</ul>
<p>In most cases, stubbing enables users to verify code that otherwise would be impractical to verify.
Although definitions for <em>mocking</em> (normally used in testing) and <em>stubbing</em> may slightly differ depending on who you ask, we often use both terms interchangeably.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The stubbing feature can be enabled by using the <code>-Z stubbing</code> option when calling Kani (the <code>-Z</code> indicates that it’s an unstable feature).</p>
<p>At present, the only component of the stubbing feature is <a href="#the-kanistub-attribute">the <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code> attribute</a>,
which allows you to specify the pair of functions/methods that must be stubbed in a harness.</p>
<!--
the other components expected to be here in the future are: the `stub_set(...)!` macro, off-the-shelf verification-friendly implementations, and automated
stubbing suggestions)
-->
<h2 id="the-kanistub-attribute"><a class="header" href="#the-kanistub-attribute">The <code>#[kani::stub(...)]</code> attribute</a></h2>
<p>The stub attribute <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code>  is the main tool of the stubbing feature.</p>
<p>It indicates to Kani that the function/method with name <code>&lt;original&gt;</code> should be replaced with the function/method with name <code>&lt;replacement&gt;</code> during the compilation step.
The names of these functions/methods are <strong>resolved using Rust’s standard name resolution rules</strong>.
This includes support for imports like <code>use foo::bar as baz</code>, as well as imports of multiple versions of the same crate.</p>
<p><strong>This attribute must be specified on a per-harness basis</strong>. This provides a high degree of flexibility for users, since they are given the option to stub the same item with different replacements (or not use stubbing at all) depending on the proof harness. In addition, <strong>the attribute can be specified multiple times per harness</strong>, so that multiple (non-conflicting) stub pairings are supported.</p>
<h3 id="an-example-stubbing-random"><a class="header" href="#an-example-stubbing-random">An example: stubbing <code>random</code></a></h3>
<p>Let’s see a simple example where we use the <a href="https://docs.rs/rand/latest/rand/fn.random.html"><code>rand::random</code></a> function
to generate an encryption key.</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn encrypt_then_decrypt_is_identity() {
    let data: u32 = kani::any();
    let encryption_key: u32 = rand::random();
    let encrypted_data = data ^ encryption_key;
    let decrypted_data = encrypted_data ^ encryption_key;
    assert_eq!(data, decrypted_data);
}
</code></pre>
<p>At present, Kani fails to verify this example due to <a href="https://github.com/model-checking/kani/issues/1781">issue #1781</a>.</p>
<p>However, we can work around this limitation thanks to the stubbing feature:</p>
<pre><code class="language-rust">use rand::random;

#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(rand::random, mock_random)]
fn encrypt_then_decrypt_is_identity() {
    let data: u32 = kani::any();
    let encryption_key: u32 = rand::random();
    let encrypted_data = data ^ encryption_key;
    let decrypted_data = encrypted_data ^ encryption_key;
    assert_eq!(data, decrypted_data);
}</code></pre>
<p>Here, the <code>#[kani::stub(rand::random, mock_random)]</code> attribute indicates to Kani that it should replace <code>rand::random</code> with the stub <code>mock_random</code>.
Note that this is a fair assumption to do: <code>rand::random</code> is expected to return any <code>u32</code> value, just like <code>kani::any</code>.</p>
<p>Now, let’s run it through Kani:</p>
<pre><code class="language-bash">cargo add rand
cargo kani -Z stubbing --harness encrypt_then_decrypt_is_identity
</code></pre>
<p>The verification result is composed of a single check: the assertion corresponding to <code>assert_eq!(data, decrypted_data)</code>.</p>
<pre><code>RESULTS:
Check 1: encrypt_then_decrypt_is_identity.assertion.1
         - Status: SUCCESS
         - Description: "assertion failed: data == decrypted_data"
         - Location: src/main.rs:18:5 in function encrypt_then_decrypt_is_identity


SUMMARY:
 ** 0 of 1 failed

VERIFICATION:- SUCCESSFUL
</code></pre>
<p>Kani shows that the assertion is successful, avoiding any issues that appear if we attempt to verify the code without stubbing.</p>
<h2 id="limitations-4"><a class="header" href="#limitations-4">Limitations</a></h2>
<p>In the following, we describe all the limitations of the stubbing feature.</p>
<h3 id="usage-restrictions"><a class="header" href="#usage-restrictions">Usage restrictions</a></h3>
<p>The usage of stubbing is limited to the verification of a single harness.
Therefore, users are <strong>required to pass the <code>--harness</code> option</strong> when using the stubbing feature.</p>
<p>In addition, this feature <strong>isn’t compatible with <a href="#concrete-playback">concrete playback</a></strong>.</p>
<h3 id="support"><a class="header" href="#support">Support</a></h3>
<p>Support for stubbing is currently <strong>limited to functions and methods</strong>. All other items aren’t supported.</p>
<p>The following are examples of items that could be good candidates for stubbing, but aren’t supported:</p>
<ul>
<li>Types</li>
<li>Macros</li>
<li>Traits</li>
<li>Intrinsics</li>
</ul>
<p>We acknowledge that support for method stubbing isn’t as ergonomic as it could be.
A common problem when attempting to define method stubs is that we don’t have access to the private fields of an object (i.e., the fields in <code>self</code>).
One workaround is to use the unsafe function <code>std::mem::transmute</code>, as in this example:</p>
<pre><code class="language-rust">struct Foo {
    x: u32,
}

impl Foo {
    pub fn m(&amp;self) -&gt; u32 {
        0
    }
}

struct MockFoo {
    pub x: u32,
}

fn mock_m(foo: &amp;Foo) -&gt; u32 {
    let mock: &amp;MockFoo = unsafe { std::mem::transmute(foo) };
    return mock.x;
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(Foo::m, mock_m)]
fn my_harness() { ... }</code></pre>
<p>However, this isn’t recommended since it’s unsafe and error-prone.
In general, we don’t recommend stubbing for private functions/methods.
Doing so can lead to brittle proofs: private functions/methods are subject to change or removal even in version minor upgrades (they aren’t part of the APIs).
Therefore, proofs that rely on stubbing for private functions/methods might incur a high maintenance burden.</p>
<h2 id="error-conditions"><a class="header" href="#error-conditions">Error conditions</a></h2>
<p>Given a set of <code>original</code>-<code>replacement</code> pairs, Kani will exit with an error if:</p>
<ol>
<li>a specified <code>original</code> function does not exist;</li>
<li>a specified <code>replacement</code> stub does not exist;</li>
<li>the user specifies conflicting stubs for the same harness (e.g., if the same <code>original</code> function is mapped to multiple <code>replacement</code> functions); or</li>
<li>the signature of the <code>replacement</code> stub is not compatible with the signature of the <code>original</code> function/method (see next section).</li>
</ol>
<h3 id="stub-compatibility-and-validation"><a class="header" href="#stub-compatibility-and-validation">Stub compatibility and validation</a></h3>
<p>We consider a stub and a function/method to be compatible if all the following conditions are met:</p>
<ul>
<li>They have the same number of parameters.</li>
<li>They have the same return type.</li>
<li>Each parameter in the stub has the same type as the corresponding parameter in the original function/method.</li>
<li>The stub must have the same number of generic parameters as the original function/method.
However, a generic parameter in the stub is allowed to have a different name than the corresponding parameter in the original function/method.
For example, the stub <code>bar&lt;A, B&gt;(x: A, y: B) -&gt; B</code> is considered to have a type compatible with the function <code>foo&lt;S, T&gt;(x: S, y: T) -&gt; T</code>.</li>
<li>The bounds for each type parameter don’t need to match; however, all calls to the original function must also satisfy the bounds of the stub.</li>
</ul>
<p>The final point is the most subtle.
We don’t require that a type parameter in the signature of the stub implements the same traits as the corresponding type parameter in the signature of the original function/method.
However, Kani will reject a stub if a trait mismatch leads to a situation where a statically dispatched call to a trait method cannot be resolved during monomorphization.
For example, this restriction rules out the following harness:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(_x: T) -&gt; bool {
    false
}

trait DoIt {
    fn do_it(&amp;self) -&gt; bool;
}

fn bar&lt;T: DoIt&gt;(x: T) -&gt; bool {
    x.do_it()
}

#[kani::proof]
#[kani::stub(foo, bar)]
fn harness() {
    assert!(foo("hello"));
}</code></pre>
<p>The call to the trait method <code>DoIt::do_it</code> is unresolvable in the stub <code>bar</code> when the type parameter <code>T</code> is instantiated with the type <code>&amp;str</code>.
On the other hand, this approach provides some flexibility, such as allowing our earlier example of mocking <code>rand::random</code>:
both <code>rand::random</code> and <code>my_random</code> have type <code>() -&gt; T</code>, but in the first case <code>T</code> is restricted such that the type <code>Standard</code> implements <code>Distribution&lt;T&gt;</code>,
whereas in the latter case <code>T</code> has to implement <code>kani::Arbitrary</code>.
This trait mismatch is allowed because at this call site <code>T</code> is instantiated with <code>u32</code>, which implements <code>kani::Arbitrary</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contracts"><a class="header" href="#contracts">Contracts</a></h1>
<p>Consider the following example:</p>
<pre><code class="language-rust">fn gcd(mut max: u8, mut min: u8) -&gt; u8 {
    if min &gt; max {
        std::mem::swap(&amp;mut max, &amp;mut min);
    }

    let rest = max % min;
    if rest == 0 { min } else { gcd(min, rest) }
}</code></pre>
<p>Let’s assume we want to verify some code that calls <code>gcd</code>.
In the <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm#Worst-case">worst case</a>, the number of steps (recursions) in <code>gcd</code> approaches 1.5 times the number of bits needed to represent the input numbers.
So, for two large 64-bit numbers, a single call to <code>gcd</code> can take almost 96 iterations.
It would be very expensive for Kani to unroll each of these iterations and then perform symbolic execution.</p>
<p>Instead, we can write <em>contracts</em> with guarantees about <code>gcd</code>’s behavior.
Once Kani verifies that <code>gcd</code>’s contracts are correct, it can replace each invocation of <code>gcd</code> with its contracts, which reduces verification time for <code>gcd</code>’s callers.
For example, perhaps we want to ensure that the returned <code>result</code> does indeed divide both <code>max</code> and <code>min</code>.
In that case, we could write contracts like these:</p>
<pre><code class="language-rust">#[kani::requires(min != 0 &amp;&amp; max != 0)]
#[kani::ensures(|result| *result != 0 &amp;&amp; max % *result == 0 &amp;&amp; min % *result == 0)]
#[kani::recursion]
fn gcd(mut max: u8, mut min: u8) -&gt; u8 { ... }</code></pre>
<p>Since <code>gcd</code> performs <code>max % min</code> (and perhaps swaps those values), passing zero as an argument could cause a division by zero.
The <code>requires</code> contract tells Kani to restrict the range of nondeterministic inputs to nonzero ones so that we don’t run into this error.
The <code>ensures</code> contract is what actually checks that the result is a correct divisor for the inputs.
(The <code>recursion</code> attribute is required when using contracts on recursive functions).</p>
<p>Then, we would write a harness to <em>verify</em> those contracts, like so:</p>
<pre><code class="language-rust">#[kani::proof_for_contract(gcd)]
fn check_gcd() {
    let max: u8 = kani::any();
    let min: u8 = kani::any();
    gcd(max, min);
}</code></pre>
<p>and verify it by running <code>kani -Z function-contracts</code>.</p>
<p>Once Kani verifies the contracts, we can use Kani’s <a href="#stubbing">stubbing feature</a> to replace all invocations to <code>gcd</code> with its contracts, for instance:</p>
<pre><code class="language-rust">// Assume foo() invokes gcd().
// By using stub_verified, we tell Kani to replace 
// invocations of gcd() with its verified contracts.
#[kani::proof]
#[kani::stub_verified(gcd)]
fn check_foo() {
    let x: u8 = kani::any();
    foo(x);
}</code></pre>
<p>By leveraging the stubbing feature, we can replace the (expensive) <code>gcd</code> call with a <em>verified abstraction</em> of its behavior, greatly reducing verification time for <code>foo</code>.</p>
<p>There is far more to learn about contracts.
We highly recommend reading our <a href="https://model-checking.github.io/kani-verifier-blog/2024/01/29/function-contracts.html">blog post about contracts</a> (from which this <code>gcd</code> example is taken). We also recommend looking at the <code>contracts</code> module in our <a href="#crates-documentation">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loop-contracts"><a class="header" href="#loop-contracts">Loop Contracts</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Loop contracts are used to specify invariants for loops for the sake of extending Kani’s <em>bounded proofs</em> to <em>unbounded proofs</em>.
A <a href="https://en.wikipedia.org/wiki/Loop_invariant">loop invariant</a> is an expression that holds upon entering a loop and after every execution of the loop body.
Loop contracts are composed of one or more loop invariants as well as optional <code>loop_modifies</code> attributes.
It captures something that does not change about every step of the loop.</p>
<p>It is worth revisiting the discussion about <a href="#bounded-proof">bounded proof</a> and
<a href="#loops-unwinding-and-bounds">loop unwinding</a>. In short, bounds on the number of times Kani unwinds loops also bound the size of inputs,
and hence result in a bounded proof.
Loop contracts are used to abstract out loops as non-loop blocks to avoid loop unwinding, and hence remove the bounds on the inputs.</p>
<p>Consider the following example:</p>
<pre><code class="language-Rust">fn simple_loop() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    while x &gt; 1 {
        x = x - 1;
    }

    assert!(x == 1);
}
</code></pre>
<p>In this program, the loop repeatedly decrements <code>x</code> until it equals <code>1</code>. Because we haven’t specified an upper bound for <code>x</code>, to verify this function,
Kani needs to unwind the loop for <code>u64::MAX</code> iterations, which is intractable. Loop contracts allow us to abstract the loop behavior, significantly reducing the verification cost.</p>
<p>With loop contracts, we can specify the loop’s behavior using invariants. For example:</p>
<pre><code class="language-Rust">#![feature(stmt_expr_attributes)]
#![feature(proc_macro_hygiene)]

fn simple_loop_with_loop_contracts() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    #[kani::loop_invariant(x &gt;= 1)]
    while x &gt; 1 {
        x = x - 1;
    }

    assert!(x == 1);
}
</code></pre>
<p>Here, the loop invariant <code>#[kani::loop_invariant(x &gt;= 1)]</code> specifies that the condition <code>x &gt;= 1</code> must hold true at the start of each iteration before the loop guard is
checked. Once Kani verifies that the loop invariant is inductive, it will use the invariant to abstract the loop and avoid unwinding.</p>
<p>Now let’s run the proof with loop contracts through kani:</p>
<pre><code class="language-bash">kani simple_loop_with_loop_contracts.rs  -Z loop-contracts
</code></pre>
<p>The output reported by Kani on the example will be</p>
<pre><code>...


Check 10: simple_loop_with_loop_contracts.loop_invariant_base.1
         - Status: SUCCESS
         - Description: "Check invariant before entry for loop simple_loop_with_loop_contracts.0"
         - Location: simple_while_loop.rs:15:5 in function simple_loop_with_loop_contracts

Check 11: simple_loop_with_loop_contracts.loop_assigns.1
         - Status: SUCCESS
         - Description: "Check assigns clause inclusion for loop simple_loop_with_loop_contracts.0"
         - Location: simple_while_loop.rs:15:5 in function simple_loop_with_loop_contracts

Check 13: simple_loop_with_loop_contracts.assigns.1
         - Status: SUCCESS
         - Description: "Check that x is assignable"
         - Location: simple_while_loop.rs:17:9 in function simple_loop_with_loop_contracts

Check 14: simple_loop_with_loop_contracts.loop_invariant_step.1
         - Status: SUCCESS
         - Description: "Check invariant after step for loop simple_loop_with_loop_contracts.0"
         - Location: simple_while_loop.rs:15:5 in function simple_loop_with_loop_contracts

Check 15: simple_loop_with_loop_contracts.loop_invariant_step.2
         - Status: SUCCESS
         - Description: "Check invariant after step for loop simple_loop_with_loop_contracts.0"
         - Location: simple_while_loop.rs:15:5 in function simple_loop_with_loop_contracts

...

SUMMARY:
 ** 0 of 99 failed

VERIFICATION:- SUCCESSFUL
Verification Time: 0.3897019s

Complete - 1 successfully verified harnesses, 0 failures, 1 total.
</code></pre>
<h2 id="syntax-and-semantics"><a class="header" href="#syntax-and-semantics">Syntax and Semantics</a></h2>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<blockquote>
<p>#[kani::loop_invariant( <a href="https://doc.rust-lang.org/reference/expressions.html"><em>Expression</em></a> )]</p>
<p><a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#grammar-LoopExpression"><em>LoopExpression</em></a></p>
</blockquote>
<p>An invariant contract <code>#[kani::loop_invariant(cond)]</code> accepts a valid Boolean expression <code>cond</code> over the variables visible at the same scope as the loop.</p>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>A loop contract expands to several assumptions and assertions:</p>
<ol>
<li>The invariant is asserted just before the first iteration.</li>
<li>The invariant is assumed on a non-deterministic state to model a non-deterministic iteration.</li>
<li>The invariant is finally asserted again to establish its inductiveness.</li>
</ol>
<p>Mathematical induction is the working principle here. (1) establishes the base case for induction, and (2) &amp; (3) establish the inductive case.
Therefore, the invariant must hold after the loop execution for any number of iterations. The invariant, together with the negation of the loop guard,
must be sufficient to establish subsequent assertions. If it is not, the abstraction is too imprecise and the user must supply a stronger invariant.</p>
<p>To illustrate the key idea, we show how Kani abstracts the loop in <code>simple_loop_with_loop_contracts</code> as a non-loop block:</p>
<pre><code class="language-Rust">assert!(x &gt;= 1) // check loop invariant for the base case.
x = kani::any();
kani::assume(x &gt;= 1);
if x &gt; 1 {
    // proof path 1:
    //   both loop guard and loop invariant are satisfied.
    x = x - 1;
    assert!(x &gt;= 1); // check that loop invariant is inductive.
    kani::assume(false) // block this proof path.
}
// proof path 2:
//   loop invariant is satisfied and loop guard is violated.
assert!(x == 1);
</code></pre>
<p>That is, we assume that we are in an arbitrary iteration after checking that the loop invariant holds for the base case. With the inductive hypothesis (<code>kani::assume(x &gt;= 1);</code>),
we will either enter the loop (proof path 1) or leave the loop (proof path 2). We prove the two paths separately by killing path 1 with <code>kani::assume(false);</code>.
Note that all assertions after <code>kani::assume(false)</code> will be ignored as <code>false =&gt; p</code> can be deduced as <code>true</code> for any <code>p</code>.</p>
<p>In proof path 1, we prove properties inside the loop and at last check that the loop contract is inductive.</p>
<p>In proof path 2, we prove properties after leaving the loop. As we leave the loop only when the loop guard is violated, the post condition of the loop can be expressed as
<code>!guard &amp;&amp; inv</code>, which is <code>x &lt;= 1 &amp;&amp; x &gt;= 1</code> in the example. The postcondition implies <code>x == 1</code>—the property we want to prove at the end of <code>simple_loop_with_loop_contracts</code>.</p>
<h2 id="historic-values-and-extra-variables"><a class="header" href="#historic-values-and-extra-variables">Historic values and extra variables</a></h2>
<h3 id="historic-values"><a class="header" href="#historic-values">Historic values</a></h3>
<p>We support two notations for historic values in loop contracts:</p>
<ol>
<li><code>on_entry(expr)</code> : The value of the <code>expr</code> before entering the loop.</li>
<li><code>prev(expr)</code> : the value of <code>expr</code> in the previous iteration. Note that Kani will assert that the loop has at least one iteration if <code>prev</code> is used in loop contracts.</li>
</ol>
<p>Example:</p>
<pre><code class="language-Rust">#[kani::proof]
pub fn loop_with_old_and_prev() {
    let mut i = 100;
    #[kani::loop_invariant((i &gt;= 2) &amp;&amp; (i &lt;= 100) &amp;&amp; (i % 2 == 0) &amp;&amp; (on_entry(i) == 100) &amp;&amp; (prev(i) == i + 2))]
    while i &gt; 2 {
        if i == 1 {
            break;
        }
        i = i - 2;
    }
    assert!(i == 2);
}
</code></pre>
<h3 id="kaniindex-variable-in-for-loop"><a class="header" href="#kaniindex-variable-in-for-loop"><code>kani::index</code> variable in <code>for</code> loop</a></h3>
<p>Kani provides an extra variable: <code>kani::index</code> that can be used in loop contracts of <code>for</code> loops.
<code>kani::index</code> presents the position (index) of the current iteration in the iterator
and is only associated with the <code>for</code> loop that immediately follows the loop contract.</p>
<p>Example:</p>
<pre><code class="language-Rust">#[kani::proof]
fn forloop() {
    let mut sum: u32 = 0;
    let a: [u8; 10] = kani::any();
    kani::assume(kani::forall!(|i in (0,10)| a[i] &lt;= 20));
    #[kani::loop_invariant(sum &lt;= (kani::index as u32 * 20) )]
    for (i, j) in a.iter().enumerate() {
        sum = sum + (i as u32) ;
    }
    assert!(sum &lt;= 200);
}
</code></pre>
<h2 id="loop-contracts-inside-functions-with-contracts"><a class="header" href="#loop-contracts-inside-functions-with-contracts">Loop contracts inside functions with contracts</a></h2>
<p>Kani supports using loop contracts together with function contracts, as demonstrated in the following example:</p>
<pre><code class="language-Rust">#![feature(proc_macro_hygiene)]
#![feature(stmt_expr_attributes)]

#[kani::requires(i&gt;=2)]
#[kani::ensures(|ret| *ret == 2)]
pub fn has_loop(mut i: u16) -&gt; u16 {
    #[kani::loop_invariant(i&gt;=2)]
    while i &gt; 2 {
        i = i - 1
    }
    i
}

#[kani::proof_for_contract(has_loop)]
fn contract_proof() {
    let i: u16 = kani::any();
    let j = has_loop(i);
}
</code></pre>
<p>When loop contracts and function contracts are both enabled (by flags <code>-Z loop-contracts -Z function-contracts</code>),
Kani automatically contracts (instead of unwinds) all loops in the functions that we want to prove contracts for.</p>
<h2 id="loop-modifies-clauses"><a class="header" href="#loop-modifies-clauses">Loop modifies clauses:</a></h2>
<p>We allow users to manually specified the <code>loop_modifies</code> clauses for memory allocated addresses which can be modified inside the loop body.
The concept is very similar to the <code>__CPROVER_assigns</code> clause of CBMC (https://diffblue.github.io/cbmc/contracts-assigns.html).
However, in Kani, the CBMC target is replaced by three Rust types which can be used in the <code>loop_modifies</code> clauses:</p>
<ol>
<li><code>RawPtr</code>: We don’t allow variable names as targets. Users must use pointers to them instead, which also allows checking modification using borrowed references and aliases.</li>
</ol>
<pre><code class="language-Rust">#[kani::proof]
fn main() {
    let mut i = 0;
    #[kani::loop_invariant(i &lt;= 20)]
    #[kani::loop_modifies(&amp;i as *const _)]
    while i &lt; 20 {
        i = i + 1;
    }
}
</code></pre>
<ol start="2">
<li><code>Reference</code>: Similar to RawPtr, but we also can use it to replace  <code>__CPROVER_object_whole(ptr-expr)</code>,
Example</li>
</ol>
<pre><code class="language-Rust">#[kani::proof]
fn main() {
    let mut i = 0;
    let mut a: [u8; 20] = kani::any();
    #[kani::loop_invariant(i &lt;= 20)]
    #[kani::loop_modifies(&amp;i, &amp;a)]
    while i &lt; 20 {
        a[i] = 1;
        i = i + 1;
    }
}
</code></pre>
<ol start="3">
<li><code>FatPtr (Slice)</code>: We use this to replace <code>__CPROVER_object_from(ptr-expr)</code>, and <code>__CPROVER_object_upto(ptr-expr, uint-expr)</code>.</li>
</ol>
<pre><code class="language-Rust">#[kani::proof]
fn main() {
    let mut i = 3;
    let mut a: [u8; 100] = kani::any();
    #[kani::loop_invariant(i &gt;=3 &amp;&amp; i &lt;= 20)]
    #[kani::loop_modifies(&amp;i , &amp;a[3..20])]
    while i &lt; 20 {
        a[i] = 1;
        i = i + 1;
    }
}
</code></pre>
<p>or</p>
<pre><code class="language-Rust">use std::ptr::slice_from_raw_parts;
#[kani::proof]
fn main() {
    let mut i = 0;
    let mut a: [u8; 100] = kani::any();
    #[kani::loop_invariant(i &lt;= 20)]
    #[kani::loop_modifies(&amp;i , slice_from_raw_parts(a.as_ptr(), 20))]
    while i &lt; 20 {
        a[i] = 1;
        i = i + 1;
    }
}
</code></pre>
<h2 id="limitations-5"><a class="header" href="#limitations-5">Limitations</a></h2>
<p>Loop contracts comes with the following limitations.</p>
<ol>
<li><code>while</code> loops, <code>loop</code> loops are supported. <code>for</code> loops are supported for array, slice, Iter, Vec, Range, StepBy, Chain, Zip, Map, and Enumerate. The other kinds of loops are not supported: <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> loops</a>.</li>
<li>Kani infers <em>loop modifies</em> with alias analysis. Loop modifies are those variables we assume to be arbitrary in the inductive hypothesis, and should cover all memory locations that are written to during
the execution of the loops. A proof will fail if the inferred loop modifies misses some targets written in the loops.
We observed this happens when some fields of structs are modified by some other functions called in the loops.</li>
<li>Kani doesn’t check if a loop will always terminate in proofs with loop contracts. So it could be that some properties are proved successfully with Kani but actually are unreachable due to the
non-termination of some loops.</li>
<li>We don’t check if loop contracts are side-effect free. A loop contract with a side effect could lead to an unsound proof result. Make sure that the specified loop contracts are side-effect free.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="concrete-playback"><a class="header" href="#concrete-playback">Concrete Playback</a></h1>
<p>When the result of a certain check comes back as a <code>FAILURE</code>, Kani offers the <code>concrete-playback</code> option to help debug. This feature generates a Rust unit test case that plays back a failing proof harness using a concrete counterexample.</p>
<p>When concrete playback is enabled, Kani will generate unit tests for assertions that failed during verification,
as well as cover statements that are reachable.</p>
<p>These tests can then be executed using Kani’s playback subcommand.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>In order to enable this feature, run Kani with the <code>-Z concrete-playback --concrete-playback=[print|inplace]</code> flag.
After getting a verification failure, Kani will generate a Rust unit test case that plays back a failing
proof harness with a concrete counterexample.
The concrete playback modes mean the following:</p>
<ul>
<li><code>print</code>: Kani will just print the unit test to stdout.
You will then need to copy this unit test into the same module as your proof harness.
This is also helpful if you just want to quickly find out which values were assigned by <code>kani::any()</code> calls.</li>
<li><code>inplace</code>: Kani will automatically copy the unit test into your source code.
Before running this mode, you might find it helpful to have your existing code committed to <code>git</code>.
That way, you can easily remove the unit test with <code>git revert</code>.
Note that Kani will not copy the unit test into your source code if it detects
that the exact same test already exists.</li>
</ul>
<p>After the unit test is in your source code, you can run it with the <code>playback</code> subcommand.
To debug it, there are a couple of options:</p>
<ul>
<li>You can try <a href="https://github.com/model-checking/kani-vscode-extension">Kani’s experimental extension</a>
provided for VSCode.</li>
<li>Otherwise, you can debug the unit test on the command line.</li>
</ul>
<p>To manually compile and run the test, you can use Kani’s <code>playback</code> subcommand:</p>
<pre><code>cargo kani playback -Z concrete-playback -- ${unit_test_func_name}
</code></pre>
<p>The output from this command is similar to <code>cargo test</code>.
The output will have a line in the beginning like
<code>Running unittests {files} ({binary})</code>.</p>
<p>You can further debug the binary with tools like <code>rust-gdb</code> or <code>lldb</code>.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<p>Running <code>kani -Z concrete-playback --concrete-playback=print</code> on the following source file:</p>
<pre><code class="language-rust">#[kani::proof]
fn proof_harness() {
    let a: u8 = kani::any();
    let b: u16 = kani::any();
    assert!(a / 2 * 2 == a &amp;&amp;
            b / 2 * 2 == b);
}</code></pre>
<p>yields a concrete playback Rust unit test similar to the one below:</p>
<pre><code class="language-rust">#[test]
fn kani_concrete_playback_proof_harness_16220658101615121791() {
    let concrete_vals: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        // 133
        vec![133],
        // 35207
        vec![135, 137],
    ];
    kani::concrete_playback_run(concrete_vals, proof_harness);
}</code></pre>
<p>Here, <code>133</code> and <code>35207</code> are the concrete values that, when substituted for <code>a</code> and <code>b</code>,
cause an assertion failure.
<code>vec![135, 137]</code> is the byte array representation of <code>35207</code>.</p>
<h2 id="request-for-comments-1"><a class="header" href="#request-for-comments-1">Request for comments</a></h2>
<p>This feature is experimental and is therefore subject to change.
If you have ideas for improving the user experience of this feature,
please add them to <a href="https://github.com/model-checking/kani/issues/1536">this GitHub issue</a>.
We are tracking the existing feature requests in
<a href="https://github.com/model-checking/kani/milestone/10">this GitHub milestone</a>.</p>
<h2 id="limitations-6"><a class="header" href="#limitations-6">Limitations</a></h2>
<ul>
<li>This feature does not generate unit tests for failing non-panic checks (e.g., UB checks).
This is because checks would not trigger runtime errors during concrete playback.
Kani generates warning messages for this.</li>
<li>This feature does not support generating unit tests for multiple assertion failures within the same harness.
This limitation might be removed in the future.
Kani generates warning messages for this.</li>
<li>This feature requires that you use the same Kani version to generate the test and to playback.
Any extra compilation option used during verification must be used during playback.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quantifiers-in-kani"><a class="header" href="#quantifiers-in-kani">Quantifiers in Kani</a></h1>
<p>Quantifiers are a powerful feature in formal verification that allow you to express properties over a range of values. Kani provides experimental support for quantifiers, enabling users to write concise and expressive specifications for their programs.</p>
<h2 id="supported-quantifiers"><a class="header" href="#supported-quantifiers">Supported Quantifiers</a></h2>
<p>Kani currently supports the following quantifiers:</p>
<ol>
<li><strong>Universal Quantifier</strong>:
<ul>
<li>Ensures that a property holds for all values in a given range.</li>
<li>Syntax: <code>kani::forall!(|variable in range| condition)</code></li>
<li>Example:</li>
</ul>
</li>
</ol>
<pre><code class="language-rust">#[kani::proof]
fn test_forall() {
    let v : [u8;10] = [10; 10];
    assert!(kani::forall!(|i in (0,10)| v[i] == 10) );
}</code></pre>
<ol start="2">
<li><strong>Existential Quantifier</strong>:
<ul>
<li>Ensures that there exists at least one value in a given range for which a property holds.</li>
<li>Syntax: <code>kani::exists!(|variable in range| condition)</code></li>
<li>Example:</li>
</ul>
</li>
</ol>
<pre><code class="language-rust">#[kani::proof]
fn test_exists() {
    let v : [u8;5] = [1, 2, 3, 4, 5];
    assert!(kani::exists!(|i in (0,v.len())| v[i] == 3));
}</code></pre>
<h3 id="limitations-7"><a class="header" href="#limitations-7">Limitations</a></h3>
<h4 id="array-indexing"><a class="header" href="#array-indexing">Array Indexing</a></h4>
<p>The performance of quantifiers can be affected by the depth of call stacks in the quantified expressions. If the call stack is too deep, Kani may not be able to evaluate the quantifier effectively, leading to potential timeouts or running out of memory. Actually, array indexing in Rust leads to a deep call stack, which can cause issues with quantifiers. To mitigate this, consider using <em>unsafe</em> pointer dereferencing instead of array indexing when working with quantifiers. For example:</p>
<pre><code class="language-rust">#[kani::proof]
fn vec_assert_forall_harness() {
    let v = vec![10 as u8; 128];
    let ptr = v.as_ptr();
    unsafe {
        kani::assert(kani::forall!(|i in (0,128)| *ptr.wrapping_byte_offset(i as isize) == 10), "");
    }
}</code></pre>
<h4 id="types-of-quantified-variables"><a class="header" href="#types-of-quantified-variables">Types of Quantified Variables</a></h4>
<p>We now assume that all quantified variables are of type <code>usize</code>. This means that the range specified in the quantifier must be compatible with <code>usize</code>.
We plan to support other types in the future, but for now, ensure that your quantifiers use <code>usize</code> ranges.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="application"><a class="header" href="#application">Application</a></h1>
<p>You may be interested in applying Kani if you’re in this situation:</p>
<ol>
<li>You’re working on a moderately important project in Rust.</li>
<li>You’ve already invested heavily in testing to ensure correctness.</li>
<li>You want to invest further, to gain a much higher degree of assurance.</li>
</ol>
<blockquote>
<p>If you haven’t already, we also recommend techniques like property testing and fuzzing (e.g. with <a href="https://github.com/camshaft/bolero/"><code>bolero</code></a>).
These yield good results, are very cheap to apply, and are often easy to adopt and debug.</p>
</blockquote>
<p>In this section, we explain <a href="#comparison-with-other-tools">how Kani compares with other tools</a>
and suggest <a href="#where-to-start-on-real-code">where to start applying Kani in real code</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with other tools</a></h1>
<p><strong>Fuzzing</strong> (for example, with <a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a>) is a unguided approach to random testing.
A fuzzer generally provides an input of random bytes, and then examines fairly generic properties (such as “doesn’t crash” or “commit undefined behavior”) about the resulting program.</p>
<p>Fuzzers generally get their power through a kind of evolutionary algorithm that rewards new mutant inputs that “discover” new branches of the program under test.
Fuzzers are excellent for testing security boundaries, precisely because they make no validity assumptions (hence, they are “unguided”) when generating the input.</p>
<p><strong>Property testing</strong> (for example, with <a href="https://github.com/AltSysrq/proptest">Proptest</a>) is a guided approach to random testing.
“Guided” in the sense that the test generally provides a strategy for generating random values that constrains their range.
The purpose of this strategy is to either focus on interesting values, or avoid failing assertions that only hold for a constrained set of inputs.
Tests in this style do actually state properties: <em>For all inputs (of some constrained kind), this condition should hold</em>.</p>
<p>Property testing is often quite effective, but the engine can’t fully prove the property: It can only sample randomly a few of those values to test (though property testing libraries frequently give interesting “edge cases” a higher probability, making them more effective at bug-finding).</p>
<p><strong>Model checking</strong> is similar to these techniques in how you use them, but it’s non-random and exhaustive (though often only up to some bound on input or problem size).
Thus, properties checked with a model checker are effectively proofs.
Instead of naively trying all possible <em>concrete</em> inputs (which could be infeasible and blow up exponentially), model checkers like Kani will cleverly encode program traces as <em>symbolic</em> “<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a>/<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>” problems, and hand them off to SAT/SMT solvers.
SAT/SMT solving is an <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-complete</a> problem, but many practical programs can be model-checked within milliseconds to seconds (with notable exceptions: you can easily try to reverse a cryptographic hash with a model checker, but good luck getting it to terminate!)</p>
<p>Model checking allows you to prove non-trivial properties about programs, and check those proofs in roughly the same amount of time as a traditional test suite would take to run.
The downside is many types of properties can quickly become “too large” to practically model-check, and so writing “proof harnesses” (very similar to property tests and fuzzer harnesses) requires some skill to understand why the solver is not terminating and fix the structure of the problem you’re giving it so that it does.
This process basically boils down to “debugging” the proof.</p>
<h2 id="looking-for-concurrency"><a class="header" href="#looking-for-concurrency">Looking for concurrency?</a></h2>
<p>At present, Kani <a href="#rust-feature-support">does not support verifying concurrent code</a>.
Two tools of immediate interest are <a href="https://github.com/tokio-rs/loom">Loom</a> and <a href="https://github.com/awslabs/shuttle">Shuttle</a>.
Loom attempts to check all possible interleavings, while Shuttle chooses interleavings randomly.
The former is sound (like Kani), but the latter is more scalable to large problem spaces (like property testing).</p>
<h2 id="other-tools"><a class="header" href="#other-tools">Other tools</a></h2>
<p>The Rust Formal Methods Interest Group maintains <a href="https://rust-formal-methods.github.io/tools.html">a list of interesting Rust verification tools</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="where-to-start-on-real-code"><a class="header" href="#where-to-start-on-real-code">Where to start on real code</a></h1>
<p>It can be daunting to find the right place to start writing proofs for a real-world project.
This section will try to help you get over that hurdle.</p>
<p>In general, you’re trying to do three things:</p>
<ol>
<li>Find a place where it’d be valuable to have a proof.</li>
<li>Find a place where it won’t be too difficult to prove something, just to start.</li>
<li>Figure out what a feasible longer-term goal might be.</li>
</ol>
<p><strong>By far, the best strategy is to follow your testing.</strong>
Places where proof will be valuable are often places where you’ve written a lot of tests, because they’re valuable there for the same reasons.
Likewise, code structure changes to make functions more unit-testable will also make functions more amenable to proof.
Often, by examining existing unit tests (and especially property tests), you can easily find a relatively self-contained function that’s a good place to start.</p>
<h2 id="where-is-proof-valuable"><a class="header" href="#where-is-proof-valuable">Where is proof valuable?</a></h2>
<ol>
<li>
<p>Where complicated things happen with untrusted user input.
These are often the critical “entry points” into the code.
These are also places where you probably want to try other techniques (e.g., fuzz testing).</p>
</li>
<li>
<p>Where <code>unsafe</code> is used extensively.
These are often places where you’ll already have concentrated a lot of tests.</p>
</li>
<li>
<p>Where you have a complicated implementation that accomplishes a much simpler abstract problem.
Ideal places for property testing, if you haven’t tried that already.
But the usual style of property tests you often write here (generate large random lists of operations, then compare between concrete and abstract model) won’t be practical to directly port to model checking.</p>
</li>
<li>
<p>Where normal testing “smells” intractable.</p>
</li>
</ol>
<h2 id="where-is-it-easier-to-start"><a class="header" href="#where-is-it-easier-to-start">Where is it easier to start?</a></h2>
<ol>
<li>
<p>Find crates or files with smaller lists of dependencies.
Dependencies can sometimes blow up the tractability of proofs.
This can usually be handled, but requires a lot more investment to make it happen, and so isn’t a good place to start.</p>
</li>
<li>
<p>Don’t forget to consider starting with your dependencies.
Sometimes the best place to start won’t be your code, but the code that you depend on.
If it’s used by more projects that just yours, it will be valuable to more people, too!</p>
</li>
<li>
<p>Find well-tested code.
When you make changes to improve the unit-testability of code, that also makes it more amenable to proof, too.</p>
</li>
</ol>
<p>Here are some things to avoid, when starting out:</p>
<ol>
<li>
<p>Lots of loops, or at least nested loops.
As we saw in the <a href="#loops-unwinding-and-bounds">tutorial</a>, right now we often need to put upper bounds on loops to make more limited claims.</p>
</li>
<li>
<p>Inductive data structures.
These are data structures with unbounded size (e.g., linked lists or trees.)
These can be hard to model since you need to set bounds on their size, similar to what happens with loops.</p>
</li>
<li>
<p>Input/Output code.
Kani doesn’t model I/O, so if your code depends on behavior like reading/writing to a file, you won’t be able to prove anything.
This is one obvious area where testability helps provability: often we separate I/O and “pure” computation into different functions, so we can unit-test the latter.</p>
</li>
<li>
<p>Deeper call graphs.
Functions that call a lot of other functions can require more investment to make tractable.
They may not be a good starting point.</p>
</li>
<li>
<p>Significant global state.
Rust tends to discourage this, but it still exists in some forms.</p>
</li>
</ol>
<h2 id="your-first-proof"><a class="header" href="#your-first-proof">Your first proof</a></h2>
<p>A first proof will likely start in the following form:</p>
<ol>
<li>Nondeterministically initialize variables that will correspond to function inputs, with as few constraints as possible.</li>
<li>Call the function in question with these inputs.</li>
<li>Don’t (yet) assert any post-conditions.</li>
</ol>
<p>Running Kani on this simple starting point will help figure out:</p>
<ol>
<li>What unexpected constraints might be needed on your inputs (using <code>kani::assume</code>) to avoid “expected” failures.</li>
<li>Whether you’re over-constrained. Check the coverage report using <code>--coverage -Z source-coverage</code>. Ideally you’d see 100% coverage, and if not, it’s usually because you’ve assumed too much (thus over-constraining the inputs).</li>
<li>Whether Kani will support all the Rust features involved.</li>
<li>Whether you’ve started with a tractable problem.
(Remember to try setting <code>#[kani::unwind(1)]</code> to force early termination and work up from there.)</li>
</ol>
<p>Once you’ve got something working, the next step is to prove more interesting properties than just what Kani covers by default.
You accomplish this by adding new assertions (not just in your harness, but also to the code being run).
Even if a proof harness has no post-conditions being asserted directly, the assertions encountered along the way can be meaningful proof results by themselves.</p>
<h2 id="examples-of-the-use-of-kani"><a class="header" href="#examples-of-the-use-of-kani">Examples of the use of Kani</a></h2>
<p>On the <a href="https://model-checking.github.io/kani-verifier-blog/">Kani blog</a>, we’ve documented worked examples of applying Kani:</p>
<ol>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/05/04/announcing-the-kani-rust-verifier-project.html">The <code>Rectangle</code> example of the Rust Book</a></li>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/06/01/using-the-kani-rust-verifier-on-a-rust-standard-library-cve.html">A Rust standard library CVE</a></li>
<li><a href="https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html">Verifying a part of Firecracker</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debugging-slow-proofs"><a class="header" href="#debugging-slow-proofs">Debugging Slow Proofs</a></h1>
<p>Kani uses SAT/SMT solvers to verify code, which can sometimes result in slow or non-terminating proofs. This chapter outlines common causes of slowness and strategies to debug and improve proof performance.</p>
<h2 id="common-causes-of-slow-proofs"><a class="header" href="#common-causes-of-slow-proofs">Common Causes of Slow Proofs</a></h2>
<h3 id="complexlarge-non-deterministic-types"><a class="header" href="#complexlarge-non-deterministic-types">Complex/Large Non-deterministic Types</a></h3>
<p>Some types are inherently more expensive to represent symbolically, e.g. strings, which have complex validation rules for UTF-8 encoding,
or large bounded collections, like a vector with a large size.</p>
<h3 id="large-value-operations"><a class="header" href="#large-value-operations">Large Value Operations</a></h3>
<p>Mathematical operations on large values can be expensive, e.g., multiplication/division/modulo, especially with larger types (e.g., <code>u64</code>).</p>
<h3 id="unbounded-loops"><a class="header" href="#unbounded-loops">Unbounded Loops</a></h3>
<p>If Kani cannot determine a loop bound, it will unwind forever, c.f. <a href="#loops-unwinding-and-bounds">the loop unwinding tutorial</a>.</p>
<h2 id="debugging-strategies"><a class="header" href="#debugging-strategies">Debugging Strategies</a></h2>
<p>These are some strategies to debug slow proofs, ordered roughly in terms of in the order you should try them:</p>
<h3 id="limit-loop-iterations"><a class="header" href="#limit-loop-iterations">Limit Loop Iterations</a></h3>
<p>First, identify whether (unbounded) loop unwinding may be the root cause. Try the <code>#[kani::unwind]</code> attribute or the <code>--unwind</code> option to limit <a href="#loops-unwinding-and-bounds">loop unwinding</a>. If the proof fails because the unwind value is too low, but raising it causing the proof to be too slow, try specifying a <a href="#loop-contracts">loop contract</a> instead.</p>
<h3 id="use-different-solvers"><a class="header" href="#use-different-solvers">Use Different Solvers</a></h3>
<p>Kani supports multiple SAT/SMT solvers that may perform differently on your specific problem. Try out different solvers with the <code>#[kani::solver]</code> <a href="#attributes">attribute</a> or <code>--solver</code> option.</p>
<h3 id="remove-sources-of-nondeterminism"><a class="header" href="#remove-sources-of-nondeterminism">Remove Sources of Nondeterminism</a></h3>
<p>Start by replacing <code>kani::any()</code> calls with concrete values to isolate the problem:</p>
<pre><code class="language-rust">#[kani::proof]
fn slow_proof() {
    // Instead of this:
    // let x: u64 = kani::any();
    // let y: u64 = kani::any();
    
    // Try this:
    let x: u64 = 42;
    let y: u64 = 100;
    
    let result = complex_function(x, y);
    assert!(result &gt; 0);
}</code></pre>
<p>If the proof becomes fast with concrete values, the issue is likely with the symbolic representation of your inputs. In that case, see you can <a href="#partition-the-input-space">partition the proof</a> to cover different ranges of possible values, or restrict the proof to a smaller range of values if that is acceptable for your use case.</p>
<h3 id="reduce-collection-sizes"><a class="header" href="#reduce-collection-sizes">Reduce Collection Sizes</a></h3>
<p>Similarly, if smaller values are acceptable for your proof, use those instead:</p>
<pre><code class="language-rust">#[kani::proof]
fn test_with_small_collection() {
    // Instead of a large Vec
    // let vec: Vec&lt;u8&gt; = kani::bounded_any::&lt;_, 100&gt;();
    
    // Start with a small size
    let vec: Vec&lt;u8&gt; = kani::bounded_any::&lt;_, 2&gt;();
    
    process_collection(&amp;vec);
}</code></pre>
<h3 id="partition-the-input-space"><a class="header" href="#partition-the-input-space">Partition the Input Space</a></h3>
<p>Break down complex proofs by partitioning the input space:</p>
<pre><code class="language-rust">// Instead of one slow proof with large inputs
#[kani::proof]
fn test_multiplication_slow() {
    let x: u64 = kani::any();
    let y: u64 = kani::any();
    
    // This might be too slow for the solver
    let result = x.saturating_mul(y);
    assert!(result &gt;= x || x == 0);
}

// Split into multiple proofs with bounded inputs
#[kani::proof]
fn test_multiplication_small_values() {
    let x: u64 = kani::any_where(|x| *x &lt;= 100);
    let y: u64 = kani::any_where(|y| *y &lt;= 100);
    
    let result = x.saturating_mul(y);
    assert!(result &gt;= x || x == 0);
}

// Insert harnesses for other ranges of `x` and `y`</code></pre>
<p>See this <a href="https://github.com/model-checking/kani/issues/3006">tracking issue</a> for adding support for such partitioning automatically.</p>
<h3 id="use-stubs"><a class="header" href="#use-stubs">Use Stubs</a></h3>
<p>If a function has a complex body, consider using a <a href="#stubbing">stub</a> or a <a href="#contracts">verified stub</a> to stub the body with a simpler abstraction.</p>
<h3 id="disable-unnecessary-checks"><a class="header" href="#disable-unnecessary-checks">Disable Unnecessary Checks</a></h3>
<p>If you’re focusing on functional correctness rather than safety, you may disable memory safety checks (run <code>kani --help</code> for a list of options to do so). Note that disabling these checks may cause Kani to miss undefined behavior, so use it with caution.</p>
<p>Alternatively, to assume that all assertions succeed and only focus on finding safety violations, use the <code>--prove-safety-only</code> option.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="developer-documentation"><a class="header" href="#developer-documentation">Developer documentation</a></h1>
<p>Kani is an open source project open to external contributions.</p>
<p>The easiest way to contribute is to <a href="https://github.com/model-checking/kani/issues/new/choose">report any
issue</a> you encounter
while using the tool. If you want to contribute to its development,
we recommend looking into <a href="https://github.com/model-checking/kani/contribute">these issues</a>.</p>
<p>In this chapter, we provide documentation that might be helpful for Kani
developers (including external contributors):</p>
<ol>
<li><a href="#coding-conventions">Coding conventions</a>.</li>
<li><a href="#command-cheat-sheets">Useful command-line instructions for Kani/CBMC/Git</a>.</li>
<li><a href="#working-with-cbmc">Development setup recommendations for working with <code>cbmc</code></a>.</li>
<li><a href="#working-with-rustc">Development setup recommendations for working with <code>rustc</code></a>.</li>
<li><a href="#testing">Guide for testing in Kani</a>.</li>
<li><a href="#transition-to-stablemir">Transition to StableMIR</a>.</li>
<li><a href="#profiling-kanis-performance">Profiling Kani’s performance</a></li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: The developer documentation is intended for Kani developers and not
users. At present, the project is under heavy development and some items
discussed in this documentation may stop working without notice (e.g., commands
or configurations). Therefore, we recommend users to not rely on them.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coding-conventions"><a class="header" href="#coding-conventions">Coding conventions</a></h1>
<h2 id="formatting"><a class="header" href="#formatting">Formatting</a></h2>
<p>We automate most of our formatting preferences. Our CI will run format checkers for PRs and pushes.
These checks are required for merging any PR.</p>
<p>For Rust, we use <a href="https://github.com/rust-lang/rustfmt">rustfmt</a>
which is configured via the <a href="https://github.com/model-checking/kani/blob/main/rustfmt.toml">rustfmt.toml</a> file.
We are also in the process of enabling <code>clippy</code>.
Because of that, we still have a couple of lints disabled (see <a href="https://github.com/model-checking/kani/blob/main/.cargo/config.toml">.cargo/config</a> for the updated list).</p>
<p>We also have a bit of C and Python code in our repository.
For C we use <code>clang-format</code> and for Python scripts we use <code>autopep8</code>.
See <a href="https://githubcom/model-checking/kani/blob/main/.clang-format">.clang-format</a>
and <a href="https://github.com/model-checking/kani/blob/main/scripts/pyproject.toml">pyproject.toml</a>
for their configuration.</p>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<p>We recognize that in some cases, the formatting and lints automation may not be applicable to a specific code.
In those cases, we usually prefer explicitly allowing exceptions by locally disabling the check.
E.g., use <code>#[allow]</code> annotation instead of disabling a link on a crate or project level.</p>
<h3 id="copyright-notice"><a class="header" href="#copyright-notice">Copyright notice</a></h3>
<p>All source code files begin with a copyright and license notice. If this is a new file, please add the following notice:</p>
<pre><code class="language-rust">// Copyright Kani Contributors
// SPDX-License-Identifier: Apache-2.0 OR MIT</code></pre>
<p>When modifying a file from another project, please keep their headers as is and append the following notice after them:</p>
<pre><code class="language-rust">// ... existing licensing headers ...

// Modifications Copyright Kani Contributors
// See GitHub history for details.</code></pre>
<p>Note: The comment escape characters will depend on the type of file you are working with. E.g.: For rust start the
header with <code>//</code>, but for python start with <code>#</code>.</p>
<p>We also have automated checks for the copyright notice.
There are a few file types where this rule doesn’t apply.
You can see that list in the <a href="https://github.com/model-checking/kani/blob/main/scripts/ci/copyright-exclude">copyright-exclude</a> file.</p>
<h2 id="code-for-soundness"><a class="header" href="#code-for-soundness">Code for soundness</a></h2>
<p>We are developing Kani to provide assurance that critical Rust components are verifiably free of certain classes of
security and correctness issues.
Thus, it is critical that we provide a verification tool that is sound.
For the class of errors that Kani can verify, we should not produce a “No Error” result if there was in fact an
error in the code being verified, i.e., it has no
“False Negatives”.</p>
<p>Because of that, we bias on the side of correctness.
Any incorrect modeling
that may trigger an unsound analysis that cannot be fixed in the short term should be mitigated.
Here are a few ways how we do that.</p>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation errors</a></h3>
<p>Make sure to add user-friendly errors for constructs that we can’t handle.
For example, Kani cannot handle the panic unwind strategy, and it will fail compilation if the crate uses this
configuration.</p>
<p>In general, it’s preferred that error messages follow <a href="https://rustc-dev-guide.rust-lang.org/diagnostics.html#diagnostic-output-style-guide">these guidelines</a> used for <code>rustc</code> development.
If the errors are being emitted from <code>kani-compiler</code>, you should use the compiler error message utilities (e.g., the <code>Session::span_err</code> method). However, if the
errors are being emitted from <code>kani-driver</code>, you should use the functions provided in the <code>util</code> module in <code>kani-driver</code>.</p>
<h3 id="internal-compiler-errors"><a class="header" href="#internal-compiler-errors">Internal compiler errors</a></h3>
<p>Even though this doesn’t provide users the best experience, you are encouraged to add checks in the compiler for any
assumptions you make during development.
Those checks can be on the form of <code>assert!()</code> or <code>unreachable!()</code>
statement.
Please provide a meaningful message to help user understand why something failed, and try to explain, at least with
a comment, why this is the case.</p>
<p>We don’t formally use any specific formal representation of <a href="https://en.wikipedia.org/wiki/Design_by_contract">function contract</a>,
but whenever possible we do instrument the code with assertions that may represent the function pre- and
post-conditions to ensure we are modeling the user code correctly.</p>
<h3 id="verification-errors"><a class="header" href="#verification-errors">Verification errors</a></h3>
<p>In cases where Kani fails to model a certain instruction or local construct that doesn’t have a global effect,
we encode this failure as a verification error.
I.e., we generate an assertion failure instead of the construct we are modeling using
<a href="https://github.com/model-checking/kani/blob/f719b565968568335d9be03ef27c5d05bb8fd0b7/kani-compiler/src/codegen_cprover_gotoc/utils/utils.rs#L50"><code>codegen_unimplemented()</code></a>,
which blocks the execution whenever this construct is reached.</p>
<p>This will allow users to verify their crate successfully as long as
that construct is not reachable in any harness. If a harness has at least one possible execution path that reaches
such construct, Kani will fail the verification, and it will mark all checks, other than failed checks, with
<code>UNDETERMINED</code> status.</p>
<h3 id="create-detailed-issues-for-todo-tasks"><a class="header" href="#create-detailed-issues-for-todo-tasks">Create detailed issues for “TODO” tasks</a></h3>
<p>It is OK to add “TODO” comments as long as they don’t compromise user experience or the tool correctness.
When doing so, please create an issue that captures the task.
Add details about the task at hand including any impact to the user.
Finally, add the link to the issue that captures the “TODO” task as part of your comment.</p>
<p>E.g.:</p>
<pre><code class="language-rust">// TODO: This function assumes type cannot be ZST. Check if that's always the case.
// https://github.com/model-checking/kani/issues/XXXX
assert!(!typ.is_zst(), "Unexpected ZST type");</code></pre>
<h2 id="performant-but-readable"><a class="header" href="#performant-but-readable">Performant but readable</a></h2>
<p>We aim at writing code that is performant but also readable and easy to maintain.
Avoid compromising the code quality if the performance gain is not significant.</p>
<p>Here are few tips that can help the readability of your code:</p>
<ul>
<li>Sort match arms, enum variants, and struct fields alphabetically.</li>
<li>Prefer concise but meaningful names.</li>
<li>Prefer exhaustive matches.</li>
<li>Prefer declarative over imperative programming.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="working-with-cbmc"><a class="header" href="#working-with-cbmc">Working with CBMC</a></h1>
<p>This section describes how to access more advanced CBMC options from Kani.</p>
<h2 id="cbmc-arguments"><a class="header" href="#cbmc-arguments">CBMC arguments</a></h2>
<p>Kani is able to handle common CBMC arguments as if they were its own (e.g.,
<code>--default-unwind &lt;n&gt;</code>), but sometimes it may be necessary to use CBMC arguments which
are not handled by Kani.</p>
<p>To pass additional arguments for CBMC, you pass <code>--cbmc-args</code> to Kani. Note that
this “switches modes” from Kani arguments to CBMC arguments: Any arguments that
appear after <code>--cbmc-args</code> are considered to be CBMC arguments, so all Kani
arguments must be placed before it.</p>
<p>Thus, the command line format to invoke <code>cargo kani</code> with CBMC arguments is:</p>
<pre><code class="language-bash">cargo kani [&lt;kani-args&gt;]* --cbmc-args [&lt;cbmc-args&gt;]*
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: In cases where CBMC is not expected to emit a verification output,
you have to use Kani’s argument <code>--output-format old</code> to turn off the
post-processing of output from CBMC.</p>
</blockquote>
<h3 id="individual-loop-bounds"><a class="header" href="#individual-loop-bounds">Individual loop bounds</a></h3>
<p>Setting <code>--default-unwind &lt;n&gt;</code> affects every loop in a harness.
Once you know a particular loop is causing trouble, sometimes it can be helpful to provide a specific bound for it.</p>
<p>In the general case, specifying just the highest bound globally for all loops
shouldn’t cause any problems, except that the solver may take more time because
<em>all</em> loops will be unwound to the specified bound.</p>
<p>In situations where you need to optimize for the solver, individual bounds for
each loop can be provided on the command line. To do so, we first need to know
the labels assigned to each loop with the CBMC argument <code>--show-loops</code>:</p>
<pre><code># kani src/lib.rs --output-format old --cbmc-args --show-loops
[...]
Loop _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:
  file ./src/lib.rs line 11 column 5 function initialize_prefix

Loop _RNvMs8_NtNtCswN0xKFrR8r_4core3ops5rangeINtB5_14RangeInclusivejE8is_emptyCs6JP7pnlEvdt_3lib.0:
  file $RUST/library/core/src/ops/range.rs line 540 column 9 function std::ops::RangeInclusive::&lt;Idx&gt;::is_empty

Loop gen-repeat&lt;[u8; 10]::16806744624734428132&gt;.0:
</code></pre>
<p>This command shows us the labels of the loops involved. Note that, as mentioned
in <a href="#cbmc-arguments">CBMC arguments</a>, we need to use <code>--output-format old</code> to
avoid post-processing the output from CBMC.</p>
<blockquote>
<p><strong>NOTE</strong>: At the moment, these labels are constructed using the mangled name
of the function and an index. Mangled names are likely to change across
different versions, so this method is highly unstable.</p>
</blockquote>
<p>Then, we can use the CBMC argument <code>--unwindset label_1:bound_1,label_2:bound_2,...</code> to specify an individual bound for each
loop as follows:</p>
<pre><code class="language-bash">kani src/lib.rs --cbmc-args --unwindset _RNvCs6JP7pnlEvdt_3lib17initialize_prefix.0:12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="working-with-rustc"><a class="header" href="#working-with-rustc">Working with <code>rustc</code></a></h1>
<p>Kani is developed on the top of the Rust compiler, which is not distributed on <a href="https://crates.io/">crates.io</a> and depends on
bootstrapping mechanisms to properly build its components.
Thus, our dependency on <code>rustc</code> crates are not declared in our <code>Cargo.toml</code>.</p>
<p>Below are a few hacks that will make it easier to develop on the top of <code>rustc</code>.</p>
<h2 id="code-analysis-for-rustc-definitions"><a class="header" href="#code-analysis-for-rustc-definitions">Code analysis for <code>rustc</code> definitions</a></h2>
<p>IDEs rely on <code>cargo</code> to find dependencies and sources to provide proper code analysis and code completion.
In order to get these features working for <code>rustc</code> crates, you can do the following:</p>
<h3 id="vscode"><a class="header" href="#vscode">VSCode</a></h3>
<p>Add the following to the <code>rust-analyzer</code> extension settings in <code>settings.json</code>:</p>
<pre><code class="language-json">    "rust-analyzer.rustc.source": "discover",
    "rust-analyzer.workspace.symbol.search.scope": "workspace_and_dependencies",
</code></pre>
<p>Ensure that any packages that use <code>rustc</code> data structures have the following line set in their <code>Cargo.toml</code></p>
<pre><code class="language-toml">[package.metadata.rust-analyzer]
# This package uses rustc crates.
rustc_private=true
</code></pre>
<p>You may also need to install the <code>rustc-dev</code> package using rustup</p>
<pre><code>rustup toolchain install nightly --component rustc-dev
</code></pre>
<h4 id="debugging-in-vs-code"><a class="header" href="#debugging-in-vs-code">Debugging in VS code</a></h4>
<p>To debug Kani in VS code, first install the <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB extension</a>.
Then add the following lines at the start of the <code>main</code> function (see <a href="https://github.com/vadimcn/vscode-lldb/blob/master/MANUAL.md#attaching-debugger-to-the-current-process-rust">the CodeLLDB manual</a> for details):</p>
<pre><code class="language-rust">{
    let url = format!(
        "vscode://vadimcn.vscode-lldb/launch/config?{{'request':'attach','sourceLanguages':['rust'],'waitFor':true,'pid':{}}}",
        std::process::id()
    );
    std::process::Command::new("code").arg("--open-url").arg(url).output().unwrap();
}</code></pre>
<p>Note that pretty printing for the Rust nightly toolchain (which Kani uses) is not very good as of June 2022.
For example, a vector may be displayed as <code>vec![{...}, {...}]</code> on nightly Rust, when it would be displayed as <code>vec![Some(0), None]</code> on stable Rust.
Hopefully, this will be fixed soon.</p>
<h3 id="rustrover--clion"><a class="header" href="#rustrover--clion">RustRover / CLion</a></h3>
<p>This is not a great solution, but it works for now (see <a href="https://github.com/intellij-rust/intellij-rust/issues/1618">https://github.com/intellij-rust/intellij-rust/issues/1618</a>
for more details).</p>
<p>Open the <code>Cargo.toml</code> of your crate (e.g.: <code>kani-compiler</code>), and do the following:</p>
<ol>
<li>Add optional dependencies on the <code>rustc</code> crates you are using.</li>
<li>Add a feature that enable those dependencies.</li>
<li>Toggle that feature using the IDE GUI.</li>
</ol>
<p>Here is an example:</p>
<pre><code class="language-toml"># ** At the bottom of the dependencies section: **
# Adjust the path here to point to a local copy of the rust compiler.
# E.g.: ~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/rustc-src/rust/compiler
rustc_public_bridge = { path = "&lt;path_to_rustc&gt;/rustc_public_bridge", optional = true }
rustc_public = { path = "&lt;path_to_rustc&gt;/rustc_public", optional = true }

[features]
clion = ['rustc_public_bridge', 'rustc_public']
</code></pre>
<p><strong>Don’t forget to rollback the changes before you create your PR.</strong></p>
<h3 id="emacs-with-use-package"><a class="header" href="#emacs-with-use-package">EMACS (with <code>use-package</code>)</a></h3>
<p>First, <code>Cargo.toml</code> and <code>rustup toolchain</code> steps are identical to VS
Code. Install Rust-analyzer binary under <code>~/.cargo/bin/</code>.</p>
<p>On EMACS, add the following to your EMACS lisp files. They will
install the necessary packages using the <code>use-package</code> manager.</p>
<pre><code class="language-elisp">;; Install LSP
(use-package lsp-mode
  :commands lsp)
(use-package lsp-ui)

;; Install Rust mode
(use-package toml-mode)
(use-package rust-mode)

(setq lsp-rust-server 'rust-analyzer)
(setenv "PATH" (concat (getenv "PATH") ":/home/USER/.cargo/bin/"))
</code></pre>
<p>If EMACS complains that it cannot find certain packages, try running
<code>M-x package-refresh-contents</code>.</p>
<p>For LSP to be able to find <code>rustc_private</code> files used by Kani, you
will need to modify variable <code>lsp-rust-analyzer-rustc-source</code>. Run
<code>M-x customize-variable</code>, type in <code>lsp-rust-analyzer-rustc-source</code>,
click <code>Value Menu</code> and change it to <code>Path</code>. Paste in the path to
<code>Cargo.toml</code> of <code>rustc</code>’s source code. You can find the source code
under <code>.rustup</code>, and the path should end with
<code>compiler/rustc/Cargo.toml</code>. <strong>Important</strong>: make sure that this
<code>rustc</code> is the same version and architecture as what Kani uses. If
not, LSP features like definition lookup may be break.</p>
<p>This ends the basic install for EMACS. You can test your configuration
with the following steps.</p>
<ol>
<li>Opening up a rust file with at least one <code>rustc_private</code> import.</li>
<li>Activate LSP mode with <code>M-x lsp</code>.</li>
<li>When asked about the root of the project, pick one of them. <strong>Make
sure</strong> that whichever root you pick has a <code>Cargo.toml</code> with
<code>rustc_private=true</code> added.</li>
<li>If LSP asks if you want to watch all files, select yes. For less
powerful machines, you may want to adjust that later.</li>
<li>On the file with <code>rustc_private</code> imports, do the following. If both
work, then you are set up.
<ul>
<li>Hover mouse over the <code>rustc_private</code> import. If LSP is working,
you should get information about the imported item.</li>
<li>With text cursor over the same <code>rustc_private</code> import, run <code>M-x lsp-find-definition</code>. This should jump to the definition within
<code>rustc</code>’s source code.</li>
</ul>
</li>
</ol>
<p>LSP mode can integrate with <code>flycheck</code> for instant error checking and
<code>company</code> for auto-complete. Consider adding the following to the
configuration.</p>
<pre><code class="language-elisp">(use-package flycheck
  :hook (prog-mode . flycheck-mode))

(use-package company
  :hook (prog-mode . company-mode)
  :config
   (global-company-mode))
</code></pre>
<p><code>clippy</code> linter can be added by changing the LSP install to:</p>
<pre><code class="language-elisp">(use-package lsp-mode
  :commands lsp
  :custom
  (lsp-rust-analyzer-cargo-watch-command "clippy"))
</code></pre>
<p>Finally lsp-mode can run rust-analyzer via TRAMP for remote
development. <strong>We found this way of using rust-analyzer to be unstable
as of 2022-06</strong>. If you want to give it a try you will need to add a
new LSP client for that remote with the following code.</p>
<pre><code class="language-elisp">(lsp-register-client
  (make-lsp-client
	:new-connection (lsp-tramp-connection "/full/path/to/remote/machines/rust-analyzer")
	:major-modes '(rust-mode)
	:remote? t
	:server-id 'rust-analyzer-remote))
</code></pre>
<p>For further details, please see https://emacs-lsp.github.io/lsp-mode/page/remote/.</p>
<h2 id="custom-rustc"><a class="header" href="#custom-rustc">Custom <code>rustc</code></a></h2>
<p>There are a few reasons why you may want to use your own copy of <code>rustc</code>. E.g.:</p>
<ul>
<li>Enable more verbose logs.</li>
<li>Use a debug build to allow you to step through <code>rustc</code> code.</li>
<li>Test changes to <code>rustc</code>.</li>
</ul>
<p>We will assume that you already have a Kani setup and that the variable <code>KANI_WORKSPACE</code> contains the path to your Kani workspace.</p>
<p><strong>It’s highly recommended that you start from the commit that corresponds to the current <code>rustc</code> version from your workspace.</strong>
To get that information, run the following command:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE} # Go to your Kani workspace.
rustc --version # This will print the commit id. Something like:
# rustc 1.60.0-nightly (0c292c966 2022-02-08)
#                       ^^^^^^^^^ this is used as the ${COMMIT_ID} below
# E.g.:
COMMIT_ID=0c292c966
</code></pre>
<p>First you need to clone and build stage 2 of the compiler.
You should tweak the configuration to satisfy your use case.
For more details, see <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html</a> and <a href="https://rustc-dev-guide.rust-lang.org/building/suggested.html">https://rustc-dev-guide.rust-lang.org/building/suggested.html</a>.</p>
<pre><code class="language-bash">git clone https://github.com/rust-lang/rust.git
cd rust
git checkout ${COMMIT_ID:?"Missing rustc commit id"}
./configure --enable-extended --tools=src,rustfmt,cargo --enable-debug --set=llvm.download-ci-llvm=true
./x.py build -i --stage 2
</code></pre>
<p>Now create a custom toolchain (here we name it <code>custom-toolchain</code>):</p>
<pre><code class="language-bash"># Use x86_64-apple-darwin for MacOs
rustup toolchain link custom-toolchain build/x86_64-unknown-linux-gnu/stage2
cp build/x86_64-unknown-linux-gnu/stage2-tools-bin/* build/x86_64-unknown-linux-gnu/stage2/bin/
</code></pre>
<p>Finally, override the current toolchain in your kani workspace and rebuild kani:</p>
<pre><code class="language-bash">cd ${KANI_WORKSPACE}
rustup override set custom-toolchain
cargo clean
cargo build-dev
</code></pre>
<h1 id="rust-compiler-utilities-to-debug-kani-compiler"><a class="header" href="#rust-compiler-utilities-to-debug-kani-compiler">Rust compiler utilities to debug <code>kani-compiler</code></a></h1>
<h2 id="enable-rustc-logs"><a class="header" href="#enable-rustc-logs">Enable <code>rustc</code> logs</a></h2>
<p>In order to enable logs, you can just define the <code>RUSTC_LOG</code> variable, as documented here: <a href="https://rustc-dev-guide.rust-lang.org/tracing.html">https://rustc-dev-guide.rust-lang.org/tracing.html</a>.</p>
<p>Note that, depending on the level of logs you would like to get (debug and trace are not enabled by default), you’ll need to build your own version of <code>rustc</code> as described above.
For logs that are related to <code>kani-compiler</code> code, use the <code>KANI_LOG</code> variable.</p>
<h2 id="debugging-type-layout"><a class="header" href="#debugging-type-layout">Debugging type layout</a></h2>
<p>In order to print the type layout computed by the Rust compiler, you can pass the following flag to <code>rustc</code>: <code>-Zprint-type-sizes</code>.
This flag can be passed to <code>kani</code> or <code>cargo kani</code> by setting the <code>RUSTFLAG</code> environment variable.</p>
<pre><code>RUSTFLAGS=-Zprint-type-sizes kani test.rs
</code></pre>
<p>When enabled, the compiler will print messages that look like:</p>
<pre><code>print-type-size type: `std::option::Option&lt;bool&gt;`: 1 bytes, alignment: 1 bytes
print-type-size     variant `Some`: 1 bytes
print-type-size         field `.0`: 1 bytes
print-type-size     variant `None`: 0 bytes
</code></pre>
<h2 id="inspecting-the-mir"><a class="header" href="#inspecting-the-mir">Inspecting the MIR</a></h2>
<p>You can easily visualize the MIR that is used as an input to code generation by setting the Rust flag <code>--emit mir</code>. I.e.:</p>
<pre><code>RUSTFLAGS=--emit=mir kani test.rs
</code></pre>
<p>The compiler will generate a few files, but we recommend looking at the files that have the following suffix: <code>kani.mir</code>.
Those files will include the entire MIR collected by our reachability analysis.
It will include functions from all dependencies, including the <code>std</code> library.
One limitation is that we dump one copy of each specialization of the MIR function, even though the MIR body itself doesn’t change.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transition-to-stablemir"><a class="header" href="#transition-to-stablemir">Transition to StableMIR</a></h1>
<p>We have partnered with the Rust compiler team in the initiative to introduce stable
APIs to the compiler that can be used by third-party tools, which is known as the
<a href="https://github.com/rust-lang/project-stable-mir">Stable MIR Project</a>, or just StableMIR.
This means that we are starting to use the new APIs introduced by this project as is,
despite them not being stable yet.</p>
<h3 id="stablemir-apis"><a class="header" href="#stablemir-apis">StableMIR APIs</a></h3>
<p>For now, the StableMIR APIs are exposed as a crate in the compiler named <code>rustc_public</code>.
This crate includes the definition of structures and methods to be stabilized,
which are expected to become the stable APIs in the compiler.
To reduce the migration burden, these APIs are somewhat close to the original compiler interfaces.
However, some changes have been made to make these APIs cleaner and easier to use.</p>
<p>For example:</p>
<ol>
<li>The usage of the compiler context (aka <code>TyCtxt</code>) is transparent to the user.
The StableMIR implementation caches this context in a thread local variable,
and retrieves it whenever necessary.
<ul>
<li>Because of that, code that uses the StableMIR has to be invoked inside a <code>run</code> call.</li>
</ul>
</li>
<li>The <code>DefId</code> has been specialized into multiple types,
making its usage less error prone. E.g.:
<code>FnDef</code> represents the definition of a function,
while <code>StaticDef</code> is the definition of a static variable.
<ul>
<li>Note that the same <code>DefId</code> may be mapped to different definitions according to its context.
For example, an <code>InstanceDef</code> and a <code>FnDef</code> may represent the same function definition.</li>
</ul>
</li>
<li>Methods that used to be exposed as part of <code>TyCtxt</code> are now part of a type.
Example, the function <code>TyCtxt.instance_mir</code> is now <code>Instance::body</code>.</li>
<li>There is no need for explicit instantiation (monomorphization) of items from an<code>Instance::body</code>.
This method already instantiates all types and resolves all constants before converting
it to stable APIs.</li>
</ol>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Since the new APIs require converting internal data to a stable representation,
the APIs were also designed to avoid needless conversions,
and to allow extra information to be retrieved on demand.</p>
<p>For example, <code>Ty</code> is just an identifier, while <code>TyKind</code> is a structure that can be retrieved via <code>Ty::kind</code> method.
The <code>TyKind</code> is a more structured object, thus,
it is only generated when the <code>kind</code> method is invoked.
Since this translation is not cached,
many of the functions that the rust compiler used to expose in <code>Ty</code>,
is now only part of <code>TyKind</code>.
The reason being that there is no cache for the <code>TyKind</code>,
and users should do the caching themselves to avoid needless translations.</p>
<p>From our initial experiments with the transition of the reachability algorithm to use StableMIR,
there is a small penalty of using StableMIR over internal rust compiler APIs.
However, they are still fairly efficient and it did not impact the overall compilation time.</p>
<h3 id="interface-with-internal-apis"><a class="header" href="#interface-with-internal-apis">Interface with internal APIs</a></h3>
<p>To reduce the burden of migrating to StableMIR,
and to allow StableMIR to be used together with internal APIs,
there are two helpful methods to convert StableMIR constructs to internal rustc and back:</p>
<ul>
<li><code>rustc_internal::internal()</code>: Convert a Stable item into an internal one.</li>
<li><code>rustc_internal::stable()</code>: Convert an internal item into a Stable one.</li>
</ul>
<p>Both of these methods are inside <code>rustc_public_bridge</code> crate in the <code>rustc_internal</code>
module inside the compiler.
Note that there is no plan to stabilize any of these methods,
and there’s also no guarantee on its support and coverage.</p>
<p>The conversion is not implemented for all items, and some conversions may be incomplete.
Please proceed with caution when using these methods.</p>
<p>Besides that, do not invoke any other <code>rustc_public_bridge</code> methods, except for <code>run</code>.
This crate’s methods are not meant to be invoked externally.
Note that, the method <code>run</code> will also eventually be replaced by a Stable driver.</p>
<h3 id="creating-and-modifying-stablemir-items"><a class="header" href="#creating-and-modifying-stablemir-items">Creating and modifying StableMIR items</a></h3>
<p>For now, StableMIR should only be used to get information from the compiler.
Do not try to create or modify items directly, as it may not work.
This may result in incorrect behavior or an internal compiler error (ICE).</p>
<h2 id="naming-conventions-in-kani"><a class="header" href="#naming-conventions-in-kani">Naming conventions in Kani</a></h2>
<p>As we adopt StableMIR, we would like to introduce a few conventions to make it easier to maintain the code.
Whenever there is a name conflict, for example, <code>Ty</code> or <code>codegen_ty</code>,
use a suffix to indicate which API you are using.
<code>Stable</code> for StableMIR and <code>Internal</code> for <code>rustc</code> internal APIs.</p>
<p>A module should either default its naming to Stable APIs or Internal APIs.
I.e.: Modules that have been migrated to StableMIR don’t need to add the <code>Stable</code> suffix to stable items.
While those that haven’t been migrated, should add <code>Stable</code>, but no <code>Internal</code> is needed.</p>
<p>For example, the <code>codegen::typ</code> module will likely include methods:</p>
<p><code>codegen_ty(&amp;mut self, Ty)</code> and <code>codegen_ty_stable(&amp;mut, TyStable)</code> to handle
internal and stable APIs.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="command-cheat-sheets"><a class="header" href="#command-cheat-sheets">Command cheat sheets</a></h1>
<p>Development work in the Kani project depends on multiple tools. Regardless of
your familiarity with the project, the commands below may be useful for
development purposes.</p>
<h2 id="kani"><a class="header" href="#kani">Kani</a></h2>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<pre><code class="language-bash"># Error "'rustc' panicked at 'failed to lookup `SourceFile` in new context'"
# or similar error? Cleaning artifacts might help.
# Otherwise, comment the line below.
cargo clean
cargo build-dev
</code></pre>
<h3 id="test"><a class="header" href="#test">Test</a></h3>
<pre><code class="language-bash"># Full regression suite
./scripts/kani-regression.sh
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (Linux)
rm -r build/x86_64-unknown-linux-gnu/tests/
</code></pre>
<pre><code class="language-bash"># Delete regression test caches (macOS)
rm -r build/x86_64-apple-darwin/tests/
</code></pre>
<pre><code class="language-bash"># Test suite run (we can only run one at a time)
# cargo run -p compiletest -- --suite ${suite} --mode ${mode}
cargo run -p compiletest -- --suite kani --mode kani
</code></pre>
<pre><code class="language-bash"># Build documentation
cd docs
./build-docs.sh
</code></pre>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>These can help understand what Kani is generating or encountering on an example or test file:</p>
<pre><code class="language-bash"># Enable `debug!` macro logging output when running Kani:
kani --debug file.rs
</code></pre>
<pre><code class="language-bash"># Use KANI_LOG for a finer grain control of the source and verbosity of logs.
# E.g.: The command below will print all logs from the kani_middle module.
KANI_LOG="kani_compiler::kani_middle=trace" kani file.rs
</code></pre>
<pre><code class="language-bash"># Keep CBMC Symbol Table and Goto-C output (.json and .goto)
kani --keep-temps file.rs
</code></pre>
<pre><code class="language-bash"># Generate "C code" from CBMC IR (.c)
kani --gen-c file.rs
</code></pre>
<pre><code class="language-bash"># Generate a ${INPUT}.kani.mir file with a human friendly MIR dump
# for all items that are compiled to the respective goto-program.
RUSTFLAGS="--emit mir" kani ${INPUT}.rs
</code></pre>
<p>The <code>KANI_REACH_DEBUG</code> environment variable can be used to debug Kani’s reachability analysis.
If defined, Kani will generate a DOT graph <code>${INPUT}.dot</code> with the graph traversed during reachability analysis.
If defined and not empty, the graph will be filtered to end at functions that contains the substring
from <code>KANI_REACH_DEBUG</code>.</p>
<p>Note that this will only work on debug builds.</p>
<pre><code class="language-bash"># Generate a DOT graph ${INPUT}.dot with the graph traversed during reachability analysis
KANI_REACH_DEBUG= kani ${INPUT}.rs

# Generate a DOT graph ${INPUT}.dot with the sub-graph traversed during the reachability analysis
# that connect to the given target.
KANI_REACH_DEBUG="${TARGET_ITEM}" kani ${INPUT}.rs
</code></pre>
<h2 id="cbmc"><a class="header" href="#cbmc">CBMC</a></h2>
<pre><code class="language-bash"># See CBMC IR from a C file:
goto-cc file.c -o file.out
goto-instrument --print-internal-representation file.out
# or (for json symbol table)
cbmc --show-symbol-table --json-ui file.out
# or (an alternative concise format)
cbmc --show-goto-functions file.out
</code></pre>
<pre><code class="language-bash"># Recover C from goto-c binary
goto-instrument --dump-c file.out &gt; file.gen.c
</code></pre>
<h2 id="git"><a class="header" href="#git">Git</a></h2>
<p>The Kani project follows the <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#squash-and-merge-your-pull-request-commits">squash and merge option</a> for pull request merges.
As a result:</p>
<ol>
<li>The title of your pull request will become the main commit message.</li>
<li>The messages from commits in your pull request will appear by default as a bulleted list in the main commit message body.</li>
</ol>
<p>But the main commit message body is editable at merge time, so you don’t have to worry about “typo fix” messages because these can be removed before merging.</p>
<pre><code class="language-bash"># Set up your git fork
git remote add fork git@github.com:${USER}/kani.git
</code></pre>
<pre><code class="language-bash"># Reset everything. Don't have any uncommitted changes!
git clean -xffd
git submodule foreach --recursive git clean -xffd
git submodule update --init
</code></pre>
<pre><code class="language-bash"># Need to update local branch (e.g. for an open pull request?)
git fetch origin
git merge origin/main
# Or rebase, but that requires a force push,
# and because we squash and merge, an extra merge commit in a PR doesn't hurt.
</code></pre>
<pre><code class="language-bash"># Checkout a pull request locally without the github cli
git fetch origin pull/$ID/head:pr/$ID
git switch pr/$ID
</code></pre>
<pre><code class="language-bash"># Push to someone else's pull request
git origin add $USER $GIR_URL_FOR_THAT_USER
git push $USER $LOCAL_BRANCH:$THEIR_PR_BRANCH_NAME
</code></pre>
<pre><code class="language-bash"># Search only git-tracked files
git grep codegen_panic
</code></pre>
<pre><code class="language-bash"># Accidentally commit to main?
# "Move" commit to a branch:
git checkout -b my_branch
# Fix main:
git branch --force main origin/main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Testing in Kani is carried out in multiple ways. There are at least
two very good reasons to do it:</p>
<ol>
<li>
<p><strong>Software regression</strong>: A regression is a type of bug
that appears after a change is introduced where a feature that
was previously working has unexpectedly stopped working.</p>
<p>Regression testing allows one to prevent a software regression
from happening by running a comprehensive set of working tests
before any change is committed to the project.</p>
</li>
<li>
<p><strong>Software metrics</strong>: A metric is a measure of software
characteristics which are quantitative and countable. Metrics are
particularly valuable for project management purposes.</p>
</li>
</ol>
<p>We recommend reading our section on <a href="#regression-testing">Regression
Testing</a> if you’re interested in Kani
development.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regression-testing"><a class="header" href="#regression-testing">Regression testing</a></h1>
<p>Kani relies on a quite extensive range of tests to perform regression testing.
Regression testing can be executed by running the command:</p>
<pre><code class="language-bash">./scripts/kani-regression.sh
</code></pre>
<p>The <code>kani-regression.sh</code> script executes different testing commands, which we classify into:</p>
<ul>
<li><a href="#kani-testing-suites">Kani testing suites</a></li>
<li><a href="#rust-unit-tests">Rust unit tests</a></li>
<li><a href="#python-unit-tests">Python unit tests</a></li>
<li><a href="#script-based-tests">Script-based tests</a></li>
</ul>
<p>See below for a description of each one.</p>
<p>Note that regression testing is run whenever a Pull Request is opened, updated or merged
into the main branch. Therefore, it’s a good idea to run regression testing locally before
submitting a Pull Request for Kani.</p>
<h2 id="kani-testing-suites"><a class="header" href="#kani-testing-suites">Kani testing suites</a></h2>
<p>The Kani testing suites are the main testing resource for Kani. In most cases, the
tests contained in the Kani testing suites are single Rust files that are run
using the following command:</p>
<pre><code class="language-bash">kani file.rs &lt;options&gt;
</code></pre>
<p>Command-line options can be passed to the test by adding a special
comment to the file. See <a href="#testing-options">testing options</a> for more details.</p>
<p>In particular, the Kani testing suites are composed of:</p>
<ul>
<li><code>kani</code>: The main testing suite for Kani. The test is a single Rust file that’s
run through Kani. In general, the test passes if verification with Kani
is successful, otherwise it fails.</li>
<li><code>firecracker</code>: Works like <code>kani</code> but contains tests inspired by
<a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a> code.</li>
<li><code>prusti</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/viperproject/prusti-dev">Prusti</a> tool.</li>
<li><code>smack</code>: Works like <code>kani</code> but contains tests from the
<a href="https://github.com/smackers/smack">SMACK</a> tool.</li>
<li><code>kani-fixme</code>: Similar to <code>kani</code>, but runs ignored tests from the <code>kani</code> testing
suite (i.e., tests with <code>fixme</code> or <code>ignore</code> in their name).
Allows us to detect when a previously not supported test becomes
supported. More details in <a href="#fixme-tests">“Fixme” tests</a>.</li>
<li><code>expected</code>: Similar to <code>kani</code> but with an additional check which ensures that
lines appearing in <code>*.expected</code> files appear in the output
generated by <code>kani</code>.</li>
<li><code>ui</code>: Works like <code>expected</code>, but focuses on the user interface (e.g.,
warnings) instead of the verification output.</li>
<li><code>cargo-kani</code>: This suite is designed to test the <code>cargo-kani</code> command. As such,
this suite works with packages instead of single Rust files.
Arguments can be specified in the <code>Cargo.toml</code> configuration file.
Similar to the <code>expected</code> suite, we look for <code>*.expected</code> files
for each harness in the package.</li>
<li><code>cargo-ui</code>: Similar to <code>cargo-kani</code>, but focuses on the user interface like the <code>ui</code> test suite.</li>
<li><code>script-based-pre</code>: This suite is useful to execute script-based tests, and
also allows checking expected output and exit codes after
running them. The suite uses the <code>exec</code> mode, described in
more detail <a href="#the-exec-mode">here</a>.</li>
</ul>
<p>We’ve extended
<a href="https://rustc-dev-guide.rust-lang.org/tests/intro.html"><code>compiletest</code></a> (the
Rust compiler testing framework) to work with these suites. That way, we take
advantage of all <code>compiletest</code> features (e.g., parallel execution).</p>
<p>A good rule of thumb is to put a test in the <code>kani</code> or <code>cargo-kani</code> folders if all we care about is codegen and verification succeeding. This is usually the case if we’re fixing a code pattern that previously crashed, so a successful verification result is a sufficient test. Otherwise, if the output refers to UI, e.g., a compiler error with a highlighted span, put it in the <code>ui</code> or <code>cargo-ui</code> suites. If the output is for a CBMC-based property that we expect Kani to check (e.g., ensuring that a particular assertion passes or fails), use the <code>expected</code> folder.</p>
<h3 id="testing-stages"><a class="header" href="#testing-stages">Testing stages</a></h3>
<p>The process of running single-file tests is split into three stages:</p>
<ul>
<li><code>check</code>: This stage uses the Rust front-end to detect if the example is valid
Rust code.</li>
<li><code>codegen</code>: This stage uses the Kani back-end to determine if we can generate
GotoC code.</li>
<li><code>verify</code>: This stage uses CBMC to obtain a verification result.</li>
</ul>
<p>If a test fails, the error message will include the stage where it failed:</p>
<pre><code>error: test failed: expected check success, got failure
</code></pre>
<p>Some tests have the following, historical syntax:</p>
<pre><code class="language-rust">// kani-&lt;stage&gt;-fail</code></pre>
<p>at the top of the test file, where <code>&lt;stage&gt;</code> is the stage where the test is
expected to fail.</p>
<p>We retain support for this test format, but prefer <code>expected</code> tests, since they more precisely indicate which failure we expect, rather than a general verification or codegen failure.</p>
<h3 id="testing-options"><a class="header" href="#testing-options">Testing options</a></h3>
<p>Many tests will require passing command-line options to Kani. These options can
be specified in single Rust files by adding a comment at the top of the file:</p>
<pre><code class="language-rust">// kani-flags: &lt;options&gt;</code></pre>
<p>For example, to use an unwinding value of 4 in a test, we can write:</p>
<pre><code class="language-rust">// kani-flags: --default-unwind 4</code></pre>
<p>For <code>cargo-kani</code> tests, the preferred way to pass command-line options is adding
them to <code>Cargo.toml</code>. See <a href="#usage-on-a-package"><code>Usage on a package</code></a> for more details.</p>
<h3 id="fixme-tests"><a class="header" href="#fixme-tests">“Fixme” tests</a></h3>
<p>Any test containing <code>fixme</code> or <code>ignore</code> in its name is considered a test not
supported for some reason (i.e., they return an unexpected verification result).</p>
<p>However, “fixme” tests included in the <code>kani</code> folder are run via the <code>kani-fixme</code>
testing suite. <code>kani-fixme</code> works on test files from <code>kani</code> but:</p>
<ol>
<li>Only runs tests whose name contains <code>fixme</code> or <code>ignore</code> (ignoring the rest).</li>
<li>The expected outcome is failure. In other words, a test is successful if it
fails.</li>
</ol>
<p>We welcome contributions with “fixme” tests which demonstrate a bug or
unsupported feature in Kani. Ideally, the test should include some comments
regarding:</p>
<ul>
<li>The expected result of the test.</li>
<li>The actual result of the test (e.g., interesting parts of the output).</li>
<li>Links to related issues.</li>
</ul>
<p>To include a new “fixme” test in <code>kani</code> you only need to ensure its name contains
<code>fixme</code> or <code>ignore</code>. If your changes to Kani cause a “fixme” test to become
supported, you only need to rename it so the name does not contain <code>fixme</code> nor
<code>ignore</code>.</p>
<h2 id="rust-unit-tests"><a class="header" href="#rust-unit-tests">Rust unit tests</a></h2>
<p>These tests follow the
<a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">Rust unit testing</a>
style.</p>
<p>At present, Kani runs unit tests from the following packages:</p>
<ul>
<li><code>cprover_bindings</code></li>
<li><code>kani-compiler</code></li>
<li><code>cargo-kani</code></li>
</ul>
<h2 id="python-unit-tests"><a class="header" href="#python-unit-tests">Python unit tests</a></h2>
<p>We use the Python <a href="https://docs.python.org/3/library/unittest.html">unit testing framework</a> to
test the CBMC JSON parser.</p>
<h2 id="script-based-tests"><a class="header" href="#script-based-tests">Script-based tests</a></h2>
<p>These are tests which are run using scripts. Scripting gives us the ability to
perform ad-hoc checks that cannot be done otherwise. They are currently used
for:</p>
<ul>
<li>Standard library codegen</li>
<li>Firecracker virtio codegen</li>
<li>Diamond dependency</li>
</ul>
<p>In fact, most of them are equivalent to running <code>cargo kani</code> and performing
checks on the output. The downside to scripting is that these tests will always
be run, even if there have not been any changes since the last time the
regression was run.</p>
<blockquote>
<p><strong>NOTE</strong>: With the addition of the <code>exec</code> mode for <code>compiletest</code> (described
below), we’ll be migrating these script-based tests to other suites using the
<code>exec</code> mode. The <code>exec</code> mode allows us to take advantage of <code>compiletest</code>
features while executing script-based tests (e.g., parallel execution).</p>
</blockquote>
<h3 id="the-exec-mode"><a class="header" href="#the-exec-mode">The <code>exec</code> mode</a></h3>
<p>The <code>exec</code> mode in <code>compiletest</code> allows us to execute script-based tests, in
addition to checking expected output and exit codes after running them.</p>
<p>In particular, tests are expected to be placed directly under the test directory
(e.g., <code>script-based-pre</code>) in a directory with a <code>config.yml</code> file, which
should contain:</p>
<ul>
<li><code>script</code>: The path to the script to be executed.</li>
<li><code>expected</code> (optional): The path to the <code>.expected</code> file to
use for output comparison.</li>
<li><code>exit_code</code> (optional): The exit code to be returned by executing
the script (a zero exit code is expected if not specified).</li>
</ul>
<p>For example, let’s say want to test the script <code>exit-one.sh</code>:</p>
<pre><code class="language-bash">echo "Exiting with code 1!"
exit 1
</code></pre>
<p>In this case, we’ll create a folder that contains the <code>config.yml</code> file:</p>
<pre><code class="language-yml">script: exit-one.sh
expected: exit-one.expected
exit_code: 1
</code></pre>
<p>where <code>exit-one.expected</code> is simply a text file such as:</p>
<pre><code class="language-text">Exiting with code 1!
</code></pre>
<p>If <code>expected</code> isn’t specified, the output won’t be checked. If <code>exit_code</code> isn’t
specified, the <code>exec</code> mode will check the exit code was zero.</p>
<p>Note that all paths specified in the <code>config.yml</code> file are local to the test
directory, which is the working directory assumed when executing the test. This
is meant to avoid problems when executing the test manually.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-comparisons-with-benchcomp"><a class="header" href="#performance-comparisons-with-benchcomp">Performance comparisons with <code>benchcomp</code></a></h1>
<p>While Kani includes a <a href="https://github.com/model-checking/kani/tree/main/tests/perf">performance regression suite</a>, you may wish to test Kani’s performance using your own benchmarks or with particular versions of Kani.
You can use the <code>benchcomp</code> tool in the Kani repository to run several ‘variants’ of a command on one or more benchmark suites; automatically parse the results of each of those suites; and take actions or emit visualizations based on those results.</p>
<h2 id="example-use-cases"><a class="header" href="#example-use-cases">Example use-cases</a></h2>
<ol>
<li>Run one or more benchmark suites with the current and previous versions of Kani.
Exit with a return code of 1 or print a custom summary to the terminal if any benchmark regressed by more than a user-configured amount.</li>
<li>Run benchmark suites using several historical versions of Kani and emit a graph of performance over time.</li>
<li>Run benchmark suites using different SAT solvers, command-line flags, or environment variables.</li>
</ol>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Benchcomp provides the following features to support your performance-comparison workflow:</p>
<ul>
<li><strong>Automatically copies benchmark suites into a fresh directories</strong> before running with each variant, to ensure that built artifacts do not affect subsequent runtimes</li>
<li><strong>Parses the results of different ‘kinds’ of benchmark suite</strong> and combines those results into a single unified format.
This allows you to run benchmarks from external repositories, suites of pre-compiled GOTO-binaries, and other kinds of benchmark all together and view their results in a single dashboard.</li>
<li><strong>Driven by a single configuration file</strong> that can be sent to colleagues or checked into a repository to be used in continuous integration.</li>
<li><strong>Extensible,</strong> allowing you to write your own parsers and visualizations.</li>
<li><strong>Caches all previous runs</strong> and allows you to re-create visualizations for the latest run without actually re-running the suites.</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<p>Here’s how to run Kani’s performance suite twice, comparing the last released version of Kani with the current HEAD.</p>
<pre><code>cd $KANI_SRC_DIR
git worktree add new HEAD
git worktree add old $(git describe --tags --abbrev=0)

tools/benchcomp/bin/benchcomp --config tools/benchcomp/configs/perf-regression.yaml
</code></pre>
<p>This uses the <a href="https://github.com/model-checking/kani/blob/main/tools/benchcomp/configs/perf-regression.yaml"><code>perf-regression.yaml</code> configuration file</a> that we use in continuous integration.
After running the suite twice, the configuration file terminates <code>benchcomp</code> with a return code of 1 if any of the benchmarks regressed on metrics such as <code>success</code> (a boolean), <code>solver_runtime</code>, and <code>number_vccs</code> (numerical).
Additionally, the config file directs benchcomp to print out a Markdown table that GitHub’s CI summary page renders in to a table.</p>
<p>The rest of this documentation describes how to modify <code>benchcomp</code> for your own use cases, including writing a configuration file; writing a custom parser for your benchmark suite; and writing a custom visualization to examine the results of a performance comparison.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchcomp-command-line"><a class="header" href="#benchcomp-command-line"><code>benchcomp</code> command line</a></h1>
<p><code>benchcomp</code> is a single command that runs benchmarks, parses their results, combines these results, and emits visualizations.
<code>benchcomp</code> also provides <em>subcommands</em> to run these steps individually.
Most users will want to invoke <code>benchcomp</code> in one of two ways:</p>
<ul>
<li><code>benchcomp</code> without any subcommands, which runs the entire performance comparison process as depicted below</li>
<li><code>benchcomp visualize</code>, which runs the visualization step on the results of a previous benchmark run without actually re-running the benchmarks.
This is useful when tweaking the parameters of a visualization, for example changing the threshold of what is considered to be a regression.</li>
</ul>
<p>The subcommands <code>run</code> and <code>collate</code> are also available.
The diagram below depicts <code>benchcomp</code>’s order of operation.
<div class="mdbook-graphviz-output"><!-- Generated by graphviz version 2.43.0 (0) --><!-- Title: G Pages: 1 --><svg width="627pt" height="478pt" viewbox="0.00 0.00 627.00 478.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 474)"><title>G</title><polygon fill="white" stroke="transparent" points="-4,4 -4,-474 623,-474 623,4 -4,4" /><g id="clust1" class="cluster"><title>cluster_run</title><polygon fill="none" stroke="black" points="8,-196 8,-462 611,-462 611,-196 8,-196" /><text text-anchor="middle" x="309.5" y="-446.8" font-family="Times,serif" font-size="14.00">benchcomp run</text></g><g id="clust2" class="cluster"><title>cluster_collate</title><polygon fill="none" stroke="black" points="200,-102 200,-177 349,-177 349,-102 200,-102" /><text text-anchor="middle" x="274.5" y="-161.8" font-family="Times,serif" font-size="14.00">benchcomp collate</text></g><g id="clust3" class="cluster"><title>cluster_vizualize</title><polygon fill="none" stroke="black" points="106,-8 106,-83 430,-83 430,-8 106,-8" /><text text-anchor="middle" x="268" y="-67.8" font-family="Times,serif" font-size="14.00">benchcomp visualize</text></g><!-- suite_1a --><g id="node1" class="node"><title>suite_1a</title><ellipse fill="none" stroke="black" cx="60" cy="-413" rx="44.39" ry="18" /><text text-anchor="middle" x="60" y="-409.3" font-family="Times,serif" font-size="14.00">suite_1</text></g><!-- out_1a --><g id="node2" class="node"><title>out_1a</title><polygon fill="none" stroke="black" points="86,-329 22,-329 22,-291 86,-291 86,-329" /><text text-anchor="middle" x="54" y="-313.8" font-family="Times,serif" font-size="14.00">output</text><text text-anchor="middle" x="54" y="-298.8" font-family="Times,serif" font-size="14.00">files</text></g><!-- suite_1a&#45;&gt;out_1a --><g id="edge1" class="edge"><title>suite_1a-&gt;out_1a</title><path fill="none" stroke="black" d="M58.98,-394.87C58.08,-379.69 56.75,-357.25 55.69,-339.4" /><polygon fill="black" stroke="black" points="59.17,-339.02 55.08,-329.24 52.18,-339.43 59.17,-339.02" /><text text-anchor="middle" x="90" y="-365.8" font-family="Times,serif" font-size="14.00">run with</text><text text-anchor="middle" x="90" y="-350.8" font-family="Times,serif" font-size="14.00">variant a</text></g><!-- suite_1a_yaml --><g id="node3" class="node"><title>suite_1a_yaml</title><polygon fill="none" stroke="black" points="131.5,-240 16.5,-240 16.5,-204 131.5,-204 131.5,-240" /><text text-anchor="middle" x="74" y="-218.3" font-family="Times,serif" font-size="14.00">suite_1a.yaml</text></g><!-- out_1a&#45;&gt;suite_1a_yaml --><g id="edge2" class="edge"><title>out_1a-&gt;suite_1a_yaml</title><path fill="none" stroke="black" d="M40.25,-290.84C34.53,-281 30.23,-268.7 35,-258 36.66,-254.27 38.94,-250.78 41.56,-247.55" /><polygon fill="black" stroke="black" points="44.3,-249.75 48.65,-240.09 39.23,-244.93 44.3,-249.75" /><text text-anchor="middle" x="97.5" y="-261.8" font-family="Times,serif" font-size="14.00">suite_1_parser.py</text></g><!-- result_yaml --><g id="node13" class="node"><title>result_yaml</title><polygon fill="none" stroke="black" points="323,-146 225,-146 225,-110 323,-110 323,-146" /><text text-anchor="middle" x="274" y="-124.3" font-family="Times,serif" font-size="14.00">result.yaml</text></g><!-- suite_1a_yaml&#45;&gt;result_yaml --><g id="edge12" class="edge"><title>suite_1a_yaml-&gt;result_yaml</title><path fill="none" stroke="black" d="M111.15,-203.91C144.02,-188.79 192.13,-166.66 227.54,-150.37" /><polygon fill="black" stroke="black" points="229.09,-153.51 236.71,-146.15 226.16,-147.15 229.09,-153.51" /></g><!-- suite_1b --><g id="node4" class="node"><title>suite_1b</title><ellipse fill="none" stroke="black" cx="182" cy="-413" rx="44.39" ry="18" /><text text-anchor="middle" x="182" y="-409.3" font-family="Times,serif" font-size="14.00">suite_1</text></g><!-- out_1b --><g id="node5" class="node"><title>out_1b</title><polygon fill="none" stroke="black" points="214,-329 150,-329 150,-291 214,-291 214,-329" /><text text-anchor="middle" x="182" y="-313.8" font-family="Times,serif" font-size="14.00">output</text><text text-anchor="middle" x="182" y="-298.8" font-family="Times,serif" font-size="14.00">files</text></g><!-- suite_1b&#45;&gt;out_1b --><g id="edge3" class="edge"><title>suite_1b-&gt;out_1b</title><path fill="none" stroke="black" d="M182,-394.87C182,-379.69 182,-357.25 182,-339.4" /><polygon fill="black" stroke="black" points="185.5,-339.24 182,-329.24 178.5,-339.24 185.5,-339.24" /><text text-anchor="middle" x="214.5" y="-365.8" font-family="Times,serif" font-size="14.00">run with</text><text text-anchor="middle" x="214.5" y="-350.8" font-family="Times,serif" font-size="14.00">variant b</text></g><!-- suite_1b_yaml --><g id="node6" class="node"><title>suite_1b_yaml</title><polygon fill="none" stroke="black" points="266,-240 150,-240 150,-204 266,-204 266,-240" /><text text-anchor="middle" x="208" y="-218.3" font-family="Times,serif" font-size="14.00">suite_1b.yaml</text></g><!-- out_1b&#45;&gt;suite_1b_yaml --><g id="edge4" class="edge"><title>out_1b-&gt;suite_1b_yaml</title><path fill="none" stroke="black" d="M187.51,-290.76C191.13,-278.82 195.91,-263.01 199.94,-249.66" /><polygon fill="black" stroke="black" points="203.3,-250.63 202.85,-240.04 196.6,-248.6 203.3,-250.63" /><text text-anchor="middle" x="259.5" y="-261.8" font-family="Times,serif" font-size="14.00">suite_1_parser.py</text></g><!-- suite_1b_yaml&#45;&gt;result_yaml --><g id="edge11" class="edge"><title>suite_1b_yaml-&gt;result_yaml</title><path fill="none" stroke="black" d="M220.41,-203.7C230.37,-189.82 244.49,-170.14 255.73,-154.46" /><polygon fill="black" stroke="black" points="258.66,-156.39 261.64,-146.23 252.97,-152.31 258.66,-156.39" /></g><!-- suite_2c --><g id="node7" class="node"><title>suite_2c</title><ellipse fill="none" stroke="black" cx="330" cy="-413" rx="44.39" ry="18" /><text text-anchor="middle" x="330" y="-409.3" font-family="Times,serif" font-size="14.00">suite_2</text></g><!-- out_2c --><g id="node8" class="node"><title>out_2c</title><polygon fill="none" stroke="black" points="362,-329 298,-329 298,-291 362,-291 362,-329" /><text text-anchor="middle" x="330" y="-313.8" font-family="Times,serif" font-size="14.00">output</text><text text-anchor="middle" x="330" y="-298.8" font-family="Times,serif" font-size="14.00">files</text></g><!-- suite_2c&#45;&gt;out_2c --><g id="edge5" class="edge"><title>suite_2c-&gt;out_2c</title><path fill="none" stroke="black" d="M330,-394.87C330,-379.69 330,-357.25 330,-339.4" /><polygon fill="black" stroke="black" points="333.5,-339.24 330,-329.24 326.5,-339.24 333.5,-339.24" /><text text-anchor="middle" x="362" y="-365.8" font-family="Times,serif" font-size="14.00">run with</text><text text-anchor="middle" x="362" y="-350.8" font-family="Times,serif" font-size="14.00">variant a</text></g><!-- suite_2c_yaml --><g id="node9" class="node"><title>suite_2c_yaml</title><polygon fill="none" stroke="black" points="398,-240 284,-240 284,-204 398,-204 398,-240" /><text text-anchor="middle" x="341" y="-218.3" font-family="Times,serif" font-size="14.00">suite_2c.yaml</text></g><!-- out_2c&#45;&gt;suite_2c_yaml --><g id="edge6" class="edge"><title>out_2c-&gt;suite_2c_yaml</title><path fill="none" stroke="black" d="M332.33,-290.76C333.85,-278.93 335.84,-263.32 337.54,-250.05" /><polygon fill="black" stroke="black" points="341.02,-250.41 338.82,-240.04 334.08,-249.52 341.02,-250.41" /><text text-anchor="middle" x="398.5" y="-261.8" font-family="Times,serif" font-size="14.00">suite_2_parser.py</text></g><!-- suite_2c_yaml&#45;&gt;result_yaml --><g id="edge10" class="edge"><title>suite_2c_yaml-&gt;result_yaml</title><path fill="none" stroke="black" d="M328.4,-203.7C318.29,-189.82 303.96,-170.14 292.54,-154.46" /><polygon fill="black" stroke="black" points="295.26,-152.25 286.55,-146.23 289.6,-156.37 295.26,-152.25" /></g><!-- suite_2d --><g id="node10" class="node"><title>suite_2d</title><ellipse fill="none" stroke="black" cx="478" cy="-413" rx="44.39" ry="18" /><text text-anchor="middle" x="478" y="-409.3" font-family="Times,serif" font-size="14.00">suite_2</text></g><!-- out_2d --><g id="node11" class="node"><title>out_2d</title><polygon fill="none" stroke="black" points="510,-329 446,-329 446,-291 510,-291 510,-329" /><text text-anchor="middle" x="478" y="-313.8" font-family="Times,serif" font-size="14.00">output</text><text text-anchor="middle" x="478" y="-298.8" font-family="Times,serif" font-size="14.00">files</text></g><!-- suite_2d&#45;&gt;out_2d --><g id="edge7" class="edge"><title>suite_2d-&gt;out_2d</title><path fill="none" stroke="black" d="M478,-394.87C478,-379.69 478,-357.25 478,-339.4" /><polygon fill="black" stroke="black" points="481.5,-339.24 478,-329.24 474.5,-339.24 481.5,-339.24" /><text text-anchor="middle" x="510.5" y="-365.8" font-family="Times,serif" font-size="14.00">run with</text><text text-anchor="middle" x="510.5" y="-350.8" font-family="Times,serif" font-size="14.00">variant b</text></g><!-- suite_2d_yaml --><g id="node12" class="node"><title>suite_2d_yaml</title><polygon fill="none" stroke="black" points="534,-240 418,-240 418,-204 534,-204 534,-240" /><text text-anchor="middle" x="476" y="-218.3" font-family="Times,serif" font-size="14.00">suite_2d.yaml</text></g><!-- out_2d&#45;&gt;suite_2d_yaml --><g id="edge8" class="edge"><title>out_2d-&gt;suite_2d_yaml</title><path fill="none" stroke="black" d="M477.58,-290.76C477.3,-278.93 476.94,-263.32 476.63,-250.05" /><polygon fill="black" stroke="black" points="480.13,-249.96 476.4,-240.04 473.13,-250.12 480.13,-249.96" /><text text-anchor="middle" x="539.5" y="-261.8" font-family="Times,serif" font-size="14.00">suite_2_parser.py</text></g><!-- suite_2d_yaml&#45;&gt;result_yaml --><g id="edge9" class="edge"><title>suite_2d_yaml-&gt;result_yaml</title><path fill="none" stroke="black" d="M438.48,-203.91C405.28,-188.79 356.69,-166.66 320.92,-150.37" /><polygon fill="black" stroke="black" points="322.21,-147.11 311.66,-146.15 319.31,-153.48 322.21,-147.11" /></g><!-- viz_1 --><g id="node14" class="node"><title>viz_1</title><polygon fill="none" stroke="black" points="202,-52 114,-52 114,-16 202,-16 202,-52" /><text text-anchor="middle" x="158" y="-30.3" font-family="Times,serif" font-size="14.00">graph.svg</text></g><!-- result_yaml&#45;&gt;viz_1 --><g id="edge13" class="edge"><title>result_yaml-&gt;viz_1</title><path fill="none" stroke="black" d="M248.02,-109.94C236.45,-102.07 222.79,-92.39 211,-83 201.63,-75.54 191.8,-66.88 183.18,-58.99" /><polygon fill="black" stroke="black" points="185.37,-56.25 175.66,-52.02 180.61,-61.39 185.37,-56.25" /></g><!-- viz_2 --><g id="node15" class="node"><title>viz_2</title><polygon fill="none" stroke="black" points="328,-52 220,-52 220,-16 328,-16 328,-52" /><text text-anchor="middle" x="274" y="-30.3" font-family="Times,serif" font-size="14.00">summary.md</text></g><!-- result_yaml&#45;&gt;viz_2 --><g id="edge14" class="edge"><title>result_yaml-&gt;viz_2</title><path fill="none" stroke="black" d="M274,-109.7C274,-96.46 274,-77.95 274,-62.66" /><polygon fill="black" stroke="black" points="277.5,-62.23 274,-52.23 270.5,-62.23 277.5,-62.23" /></g><!-- viz_3 --><g id="node16" class="node"><title>viz_3</title><text text-anchor="middle" x="384" y="-37.8" font-family="Times,serif" font-size="14.00">exit 1 on</text><text text-anchor="middle" x="384" y="-22.8" font-family="Times,serif" font-size="14.00">regression</text></g><!-- result_yaml&#45;&gt;viz_3 --><g id="edge15" class="edge"><title>result_yaml-&gt;viz_3</title><path fill="none" stroke="black" d="M300.86,-109.85C312.36,-102.11 325.7,-92.57 337,-83 346.54,-74.92 356.33,-65.19 364.49,-56.61" /><polygon fill="black" stroke="black" points="367.2,-58.83 371.47,-49.13 362.09,-54.06 367.2,-58.83" /></g></g></svg></div>
</p>
<p>Running <code>benchcomp</code> invokes <code>run</code>, <code>collate</code>, and <code>visualize</code> behind the scenes.
If you have previously run <code>benchcomp</code>, then running <code>benchcomp visualize</code> will emit the visualizations in the config file using the previous <code>result.yaml</code>.</p>
<p>In the diagram above, two different suites (1 and 2) are both run using two <em>variants</em>—combinations of command, working directory, and environment variables.
Benchmark suite 2 requires a totally different command line to suite 1—for example, <code>suite_1</code> might contain Kani harnesses invoked through <code>cargo kani</code>, while <code>suite_2</code> might contain CBMC harnesses invoked through <code>run_cbmc_proofs.py</code>.
Users would therefore define different variants (<code>c</code> and <code>d</code>) for invoking <code>suite_2</code>, and also specify a different parser to parse the results.
No matter how different the benchmark suites are, the <code>collate</code> stage combines their results so that they can later be compared.</p>
<h2 id="example-config-file"><a class="header" href="#example-config-file">Example config file</a></h2>
<p>Users must specify the actual suites to run, the parsers used to collect their results, and the visualizations to emit in a file called <code>benchcomp.yaml</code> or a file passed to the <code>-c/--config</code> flag.
The <a href="#benchcomp-configuration-file">next section</a> describes the schema for this configuration file.
A run similar to the diagram above might be achieved using the following configuration file:</p>
<pre><code class="language-yaml"># Compare a range of Kani and CBMC benchmarks when
# using Cadical versus the default SAT solver

variants:
  variant_a:
    config:
      directory: kani_benchmarks
      command_line: scripts/kani-perf.sh
      env: {}

  variant_b:
    config:
      directory: kani_benchmarks
      command_line: scripts/kani-perf.sh
      # This variant uses a hypothetical environment variable that
      # forces Kani to use the cadical SAT solver
      env:
        KANI_SOLVER: cadical

  variant_c:
    config:
      directory: cbmc_benchmarks
      command_line: run_cbmc_proofs.py
      env: {}

  variant_d:
    config:
      directory: cbmc_benchmarks
      command_line: run_cbmc_proofs.py
      env:
        EXTERNAL_SAT_SOLVER: cadical

run:
  suites:
    suite_1:
      parser:
        module: kani_perf
      variants: [variant_a, variant_b]

    suite_2:
      parser:
        module: cbmc_litani_parser
      variants: [variant_c, variant_d]

visualize:
  - type: dump_graph
    out_file: graph.svg

  - type: dump_markdown_results_table
    out_file: summary.md
    extra_columns: []

  - type: error_on_regression
    variant_pairs:
    - [variant_a, variant_b]
    - [variant_c, variant_d]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchcomp-configuration-file"><a class="header" href="#benchcomp-configuration-file"><code>benchcomp</code> configuration file</a></h1>
<p><code>benchcomp</code>’s operation is controlled through a YAML file—<code>benchcomp.yaml</code> by default or a file passed to the <code>-c/--config</code> option.
This page lists the different visualizations that are available.</p>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<p>A <em>variant</em> is a single invocation of a benchmark suite. Benchcomp runs several
variants, so that their performance can be compared later. A variant consists of
a command-line argument, working directory, and environment. Benchcomp invokes
the command using the operating system environment, updated with the keys and
values in <code>env</code>. If any values in <code>env</code> contain strings of the form <code>${var}</code>,
Benchcomp expands them to the value of the environment variable <code>$var</code>.</p>
<pre><code class="language-yaml">variants:
    variant_1:
        config:
            command_line: echo "Hello, world"
            directory: /tmp
            env:
              PATH: /my/local/directory:${PATH}
</code></pre>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>After benchcomp has finished parsing the results, it writes the results to <code>results.yaml</code> by default.
Before visualizing the results (see below), benchcomp can <em>filter</em> the results by piping them into an external program.</p>
<p>To filter results before visualizing them, add <code>filters</code> to the configuration file.</p>
<pre><code class="language-yaml">filters:
    - command_line: ./scripts/remove-redundant-results.py
    - command_line: cat
</code></pre>
<p>The value of <code>filters</code> is a list of dicts.
Currently the only legal key for each of the dicts is <code>command_line</code>.
Benchcomp invokes each <code>command_line</code> in order, passing the results as a JSON file on stdin, and interprets the stdout as a YAML-formatted modified set of results.
Filter scripts can emit either YAML (which might be more readable while developing the script), or JSON (which benchcomp will parse as a subset of YAML).</p>
<h2 id="built-in-visualizations"><a class="header" href="#built-in-visualizations">Built-in visualizations</a></h2>
<p>The following visualizations are available; these can be added to the <code>visualize</code> list of <code>benchcomp.yaml</code>.</p>
<ul>
<li><a href="#Environment">Environment</a></li>
<li><a href="#Plot">Plot</a></li>
<li><a href="#dump_markdown_results_table">dump_markdown_results_table</a></li>
<li><a href="#dump_yaml">dump_yaml</a></li>
<li><a href="#error_on_regression">error_on_regression</a></li>
<li><a href="#run_command">run_command</a></li>
</ul>
<p>Detailed documentation for these visualizations follows.</p>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>The core component of Jinja is the <code>Environment</code>.  It contains
important shared variables like configuration, filters, tests,
globals and others.  Instances of this class may be modified if
they are not shared and if no template was loaded so far.
Modifications on environments after the first template was loaded
will lead to surprising effects and undefined behavior.</p>
<p>Here are the possible initialization parameters:</p>
<pre><code>`block_start_string`
    The string marking the beginning of a block.  Defaults to ``'{%'``.

`block_end_string`
    The string marking the end of a block.  Defaults to ``'%}'``.

`variable_start_string`
    The string marking the beginning of a print statement.
    Defaults to ``'{{'``.

`variable_end_string`
    The string marking the end of a print statement.  Defaults to
    ``'}}'``.

`comment_start_string`
    The string marking the beginning of a comment.  Defaults to ``'{#'``.

`comment_end_string`
    The string marking the end of a comment.  Defaults to ``'#}'``.

`line_statement_prefix`
    If given and a string, this will be used as prefix for line based
    statements.  See also :ref:`line-statements`.

`line_comment_prefix`
    If given and a string, this will be used as prefix for line based
    comments.  See also :ref:`line-statements`.

    .. versionadded:: 2.2

`trim_blocks`
    If this is set to ``True`` the first newline after a block is
    removed (block, not variable tag!).  Defaults to `False`.

`lstrip_blocks`
    If this is set to ``True`` leading spaces and tabs are stripped
    from the start of a line to a block.  Defaults to `False`.

`newline_sequence`
    The sequence that starts a newline.  Must be one of ``'\r'``,
    ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a
    useful default for Linux and OS X systems as well as web
    applications.

`keep_trailing_newline`
    Preserve the trailing newline when rendering templates.
    The default is ``False``, which causes a single newline,
    if present, to be stripped from the end of the template.

    .. versionadded:: 2.7

`extensions`
    List of Jinja extensions to use.  This can either be import paths
    as strings or extension classes.  For more information have a
    look at :ref:`the extensions documentation &lt;jinja-extensions&gt;`.

`optimized`
    should the optimizer be enabled?  Default is ``True``.

`undefined`
    :class:`Undefined` or a subclass of it that is used to represent
    undefined values in the template.

`finalize`
    A callable that can be used to process the result of a variable
    expression before it is output.  For example one can convert
    ``None`` implicitly into an empty string here.

`autoescape`
    If set to ``True`` the XML/HTML autoescaping feature is enabled by
    default.  For more details about autoescaping see
    :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also
    be a callable that is passed the template name and has to
    return ``True`` or ``False`` depending on autoescape should be
    enabled by default.

    .. versionchanged:: 2.4
       `autoescape` can now be a function

`loader`
    The template loader for this environment.

`cache_size`
    The size of the cache.  Per default this is ``400`` which means
    that if more than 400 templates are loaded the loader will clean
    out the least recently used template.  If the cache size is set to
    ``0`` templates are recompiled all the time, if the cache size is
    ``-1`` the cache will not be cleaned.

    .. versionchanged:: 2.8
       The cache size was increased to 400 from a low 50.

`auto_reload`
    Some loaders load templates from locations where the template
    sources may change (ie: file system or database).  If
    ``auto_reload`` is set to ``True`` (default) every time a template is
    requested the loader checks if the source changed and if yes, it
    will reload the template.  For higher performance it's possible to
    disable that.

`bytecode_cache`
    If set to a bytecode cache object, this object will provide a
    cache for the internal Jinja bytecode so that templates don't
    have to be parsed if they were not changed.

    See :ref:`bytecode-cache` for more information.

`enable_async`
    If set to true this enables async template execution which
    allows using async functions and generators.
</code></pre>
<h3 id="plot"><a class="header" href="#plot">Plot</a></h3>
<p>Scatterplot configuration options</p>
<h3 id="dump_markdown_results_table"><a class="header" href="#dump_markdown_results_table">dump_markdown_results_table</a></h3>
<p>Print Markdown-formatted tables displaying benchmark results</p>
<p>For each metric, this visualization prints out a table of benchmarks,
showing the value of the metric for each variant, combined with an optional
scatterplot.</p>
<p>The ‘out_file’ key is mandatory; specify ‘-’ to print to stdout.</p>
<p>‘extra_colums’ can be an empty dict. The sample configuration below assumes
that each benchmark result has a ‘success’ and ‘runtime’ metric for both
variants, ‘variant_1’ and ‘variant_2’. It adds a ‘ratio’ column to the table
for the ‘runtime’ metric, and a ‘change’ column to the table for the
‘success’ metric. The ‘text’ lambda is called once for each benchmark. The
‘text’ lambda accepts a single argument—a dict—that maps variant
names to the value of that variant for a particular metric. The lambda
returns a string that is rendered in the benchmark’s row in the new column.
This allows you to emit arbitrary text or markdown formatting in response to
particular combinations of values for different variants, such as
regressions or performance improvements.</p>
<p>‘scatterplot’ takes the values ‘off’ (default), ‘linear’ (linearly scaled
axes), or ‘log’ (logarithmically scaled axes).</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: dump_markdown_results_table
  out_file: "-"
  scatterplot: linear
  extra_columns:
    runtime:
    - column_name: ratio
      text: &gt;
        lambda b: str(b["variant_2"]/b["variant_1"])
        if b["variant_2"] &lt; (1.5 * b["variant_1"])
        else "**" + str(b["variant_2"]/b["variant_1"]) + "**"
    success:
    - column_name: change
      text: &gt;
        lambda b: "" if b["variant_2"] == b["variant_1"]
        else "newly passing" if b["variant_2"]
        else "regressed"
</code></pre>
<p>Example output:</p>
<pre><code>## runtime

| Benchmark |  variant_1 | variant_2 | ratio |
| --- | --- | --- | --- |
| bench_1 | 5 | 10 | **2.0** |
| bench_2 | 10 | 5 | 0.5 |

## success

| Benchmark |  variant_1 | variant_2 | change |
| --- | --- | --- | --- |
| bench_1 | True | True |  |
| bench_2 | True | False | regressed |
| bench_3 | False | True | newly passing |
</code></pre>
<h3 id="dump_yaml"><a class="header" href="#dump_yaml">dump_yaml</a></h3>
<p>Print the YAML-formatted results to a file.</p>
<p>The ‘out_file’ key is mandatory; specify ‘-’ to print to stdout.</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: dump_yaml
  out_file: '-'
</code></pre>
<h3 id="error_on_regression"><a class="header" href="#error_on_regression">error_on_regression</a></h3>
<p>Terminate benchcomp with a return code of 1 if any benchmark regressed.</p>
<p>This visualization checks whether any benchmark regressed from one variant
to another. Sample configuration:</p>
<pre><code>visualize:
- type: error_on_regression
  variant_pairs:
  - [variant_1, variant_2]
  - [variant_1, variant_3]
  checks:
  - metric: runtime
    test: "lambda old, new: new / old &gt; 1.1"
  - metric: passed
    test: "lambda old, new: False if not old else not new"
</code></pre>
<p>This says to check whether any benchmark regressed when run under variant_2
compared to variant_1. A benchmark is considered to have regressed if the
value of the ‘runtime’ metric under variant_2 is 10% higher than the value
under variant_1. Furthermore, the benchmark is also considered to have
regressed if it was previously passing, but is now failing. These same
checks are performed on all benchmarks run under variant_3 compared to
variant_1. If any of those lambda functions returns True, then benchcomp
will terminate with a return code of 1.</p>
<h3 id="run_command"><a class="header" href="#run_command">run_command</a></h3>
<p>Run an executable command, passing the performance metrics as JSON on stdin.</p>
<p>This allows you to write your own visualization, which reads a result file
on stdin and does something with it, e.g. writing out a graph or other
output file.</p>
<p>Sample configuration:</p>
<pre><code>visualize:
- type: run_command
  command: ./my_visualization.py
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-parsers"><a class="header" href="#custom-parsers">Custom parsers</a></h1>
<p>Benchcomp ships with built-in <em>parsers</em> that retrieve the results of a benchmark suite after the run has completed.
You can also create your own parser, either to run locally or to check into the Kani codebase.</p>
<h2 id="built-in-parsers"><a class="header" href="#built-in-parsers">Built-in parsers</a></h2>
<p>You specify which parser should run for each benchmark suite in <code>benchcomp.yaml</code>.
For example, if you’re running the kani performance suite, you would use the built-in <code>kani_perf</code> parser to parse the results:</p>
<pre><code class="language-yaml">suites:
    my_benchmark_suite:
      variants: [variant_1, variant_2]
      parser:
        module: kani_perf
</code></pre>
<h2 id="custom-parsers-1"><a class="header" href="#custom-parsers-1">Custom parsers</a></h2>
<p>A parser is a program that benchcomp runs inside the root directory of a benchmark suite, after the suite run has completed.
The parser should retrieve the results of the run (by parsing output files etc.) and print the results out as a YAML document.
You can use your executable parser by specifying the <code>command</code> key rather than the <code>module</code> key in your <code>benchconf.yaml</code> file:</p>
<pre><code class="language-yaml">suites:
    my_benchmark_suite:
      variants: [variant_1, variant_2]
      parser:
        command: ./my-cool-parser.sh
</code></pre>
<p>The <code>kani_perf</code> parser mentioned above, in <code>tools/benchcomp/benchcomp/parsers/kani_perf.py</code>, is a good starting point for writing a custom parser, as it also works as a standalone executable.
Here is an example output from an executable parser:</p>
<pre><code class="language-yaml">metrics:
    runtime: {}
    success: {}
    errors: {}
benchmarks:
    bench_1:
        metrics:
            runtime: 32
            success: true
            errors: []
    bench_2:
        metrics:
            runtime: 0
            success: false
            errors: ["compilation failed"]
</code></pre>
<p>The above format is different from the final <code>result.yaml</code> file that benchcomp writes, because the above file represents the output of running a single benchmark suite using a single variant.
Your parser will run once for each variant, and benchcomp combines the dictionaries into the final <code>result.yaml</code> file.</p>
<h2 id="contributing-custom-parsers-to-kani"><a class="header" href="#contributing-custom-parsers-to-kani">Contributing custom parsers to Kani</a></h2>
<p>To turn your executable parser into one that benchcomp can invoke as a module, ensure that it has a <code>main(working_directory)</code> method that returns a dict (the same dict that it would print out as a YAML file to stdout).
Save the file in <code>tools/benchcomp/benchcomp/parsers</code> using python module naming conventions (filename should be an identifier and end in <code>.py</code>).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="profiling-kanis-performance"><a class="header" href="#profiling-kanis-performance">Profiling Kani’s Performance</a></h1>
<p>To profile Kani’s performance at a fine-grained level, we use a tool called <a href="https://github.com/mstange/samply"><code>samply</code></a> that allows the compiler &amp; driver to periodically record the current stack trace, allowing us to construct flamegraphs of where they are spending most of their time.</p>
<h2 id="install-samply"><a class="header" href="#install-samply">Install samply</a></h2>
<p>First, install <code>samply</code> using <a href="https://github.com/mstange/samply?tab=readme-ov-file#installation">the instructions</a> from their repo. The easier methods include installing a prebuilt binary or installing from crates.io.</p>
<h2 id="running-kani-for-profiling-output"><a class="header" href="#running-kani-for-profiling-output">Running Kani for profiling output</a></h2>
<ol>
<li>First, build Kani from source with <code>cargo build-dev --profile profiling</code> to ensure you are getting all release mode optimizations without stripping useful debug info.</li>
<li>Then, you can profile the Kani compiler on a crate of your choice by <a href="#adding-kani-to-your-path">exporting Kani to your local PATH</a> and  running <code>FLAMEGRAPH=[OPTION] cargo kani</code> within the crate.</li>
</ol>
<p>The <code>FLAMEGRAPH</code> environment variable can be set to <code>driver</code> (to profile the complete <code>kani-driver</code> execution) or <code>compiler</code> (to profile each time the <code>kani-compiler</code> is called).</p>
<p>We have to instrument the driver and compiler separately because samply’s instrumentation usually cannot handle detecting the subprocess the driver uses to call the compiler.</p>
<p>Our default sampling rate is <em>8000 Hz</em>, but you can change it yourself in <a href="../../kani-driver/src/session.rs"><code>session.rs</code></a> for the compiler or the <a href="../../scripts/cargo-kani">cargo-kani</a> script for the driver.</p>
<blockquote>
<p>Note: Specifically when profiling the compiler, ensure you are running <code>cargo clean</code> immediately before <code>cargo kani</code>, or parts of the workspace may not be recompiled by the Kani compiler.</p>
</blockquote>
<h2 id="displaying-profiling-output"><a class="header" href="#displaying-profiling-output">Displaying profiling output</a></h2>
<p>This will create a new <code>flamegraphs</code> directory in the crate which will contain a single <code>driver.json.gz</code> output file and one <code>compiler-{crate_name}.json.gz</code> file for each crate in the workspace. Run <code>samply load flamegraphs/XXX.json.gz</code> on any of these to open a local server that will display the file’s flamegraph.</p>
<p>Once the server has opened, you’ll see a display with the list of threads in rows at the top, and a flamegraph for the currently selected thread at the bottom. There is typically only one process when profiling the driver. When profiling the compiler, the process that runs the <code>kani-compiler</code> and handles all codegen is usually at the very bottom of the thread window.</p>
<p>In the flamegraph view, I’ve found it very useful to right click on a function of interest and select “focus on subtree only” so that it zooms in and you can more clearly see the callees it uses. This can then be undone with the breadcrumb trail at the top of the flamegraph.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="limitations-8"><a class="header" href="#limitations-8">Limitations</a></h1>
<p>Like other tools, Kani comes with some limitations. In some cases, these
limitations are inherent because of the techniques it’s based on, or the
undecidability of the properties that Kani seeks to prove. In other
cases, it’s just a matter of time and effort to remove these limitations (e.g.,
specific unsupported Rust language features).</p>
<p>In this chapter, we do the following to document these limitations:</p>
<ul>
<li>Discuss the effect of <a href="#undefined-behaviour">Rust undefined behaviour</a>.</li>
<li>Summarize the <a href="#rust-feature-support">current support for Rust features</a>.</li>
<li>Explain the need for <a href="#overrides">overrides</a> and list all overriden
symbols.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="undefined-behaviour"><a class="header" href="#undefined-behaviour">Undefined Behaviour</a></h1>
<h2 id="the-effect-of-undefined-behaviour-on-program-verification"><a class="header" href="#the-effect-of-undefined-behaviour-on-program-verification">The Effect of Undefined Behaviour on Program Verification</a></h2>
<p>Rust has a broad definition of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behaviour</a> (UB).
The <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation warns</a> that UB can have unexpected, non-local effects:</p>
<blockquote>
<p><strong>Note</strong>: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
<p>If a program has UB, the semantics of the rest of the program are <strong>undefined</strong>.
As a result, if the program under verification contains UB then, in principle, the program (including its representation in MIR analyzed by Kani) <strong>has no semantics</strong> and hence could do anything, including violating the guarantees checked by Kani.
This means that verification results are subject to the proviso that the program under verification does not contain UB.</p>
<h2 id="what-forms-of-undefined-behaviour-can-rust-exhibit"><a class="header" href="#what-forms-of-undefined-behaviour-can-rust-exhibit">What forms of Undefined Behaviour can Rust Exhibit</a></h2>
<p>Rust’s <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">definition of UB</a> is so broad that Rust has the following warning:</p>
<blockquote>
<p><strong>Warning</strong>
The following list is not exhaustive. There is no formal model of Rust’s semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the Rustonomicon (https://doc.rust-lang.org/nomicon/index.html) before writing unsafe code.</p>
</blockquote>
<p>Given the lack of a formal semantics for UB, and given Kani’s focus on memory safety, there are classes of UB which Kani does not detect, or only makes a best-effort attempt to detect them.
A non-exhaustive list of these, based on the non-exhaustive list from the <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Rust documentation</a>, is:</p>
<ul>
<li>Data races.
<ul>
<li>Kani focuses on sequential code.</li>
</ul>
</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a>.
<ul>
<li>Kani can detect if misuse of pointers causes memory safety or assertion violations, but does not track reference lifetimes.</li>
</ul>
</li>
<li>Mutating immutable data.
<ul>
<li>Kani can detect if modification of immutable data causes memory safety or assertion violations, but does not track reference lifetimes.</li>
</ul>
</li>
<li>Invoking undefined behavior via compiler intrinsics.
<ul>
<li>Kani makes a best effort attempt to check the preconditions of compiler intrinsics, but does not guarantee to do so in all cases. See also <a href="#intrinsics-1">current support for compiler intrinsics</a>.</li>
</ul>
</li>
<li>Executing code compiled with platform features that the current platform does not support (see <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-target_feature-attribute">target_feature</a>).
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.
<ul>
<li>Kani relies on <code>rustc</code> to check for this case.</li>
</ul>
</li>
<li>Producing an invalid value, even in private fields and locals.
<ul>
<li>Kani <a href="#nondeterministic-variables">won’t create invalid values</a> with <code>kani::any()</code> but it also won’t complain if you <code>transmute</code> an invalid value to a Rust type (for example, a <code>0</code> to <code>NonZeroU32</code>).</li>
</ul>
</li>
<li>Incorrect use of inline assembly.
<ul>
<li>Kani does not support inline assembly.</li>
</ul>
</li>
<li>Using uninitialized memory.
<ul>
<li>See the corresponding section in our <a href="#uninitialized-memory">Rust feature support</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-feature-support"><a class="header" href="#rust-feature-support">Rust feature support</a></h1>
<p>The table below tries to summarize the current support in Kani for
the Rust language features according to the <a href="https://doc.rust-lang.org/stable/reference/">Rust Reference</a>.
We use the following values to indicate the level of support:</p>
<ul>
<li><strong>Yes</strong>: The feature is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The feature is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The feature is not supported. Some support may be available but analyses should not be trusted.</li>
</ul>
<p>As with all software, bugs may be found anywhere regardless of the level of support. In such cases, we
would greatly appreciate that you <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">filed a bug report</a>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Reference</th><th>Feature</th><th>Support</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>3.1</td><td>Macros By Example</td><td>Yes</td><td></td></tr>
<tr><td>3.2</td><td>Procedural Macros</td><td>Yes</td><td></td></tr>
<tr><td>4</td><td>Crates and source files</td><td>Yes</td><td></td></tr>
<tr><td>5</td><td>Conditional compilation</td><td>Yes</td><td></td></tr>
<tr><td>6.1</td><td>Modules</td><td>Yes</td><td></td></tr>
<tr><td>6.2</td><td>Extern crates</td><td>Yes</td><td></td></tr>
<tr><td>6.3</td><td>Use declarations</td><td>Yes</td><td></td></tr>
<tr><td>6.4</td><td>Functions</td><td>Yes</td><td></td></tr>
<tr><td>6.5</td><td>Type aliases</td><td>Yes</td><td></td></tr>
<tr><td>6.6</td><td>Structs</td><td>Yes</td><td></td></tr>
<tr><td>6.7</td><td>Enumerations</td><td>Yes</td><td></td></tr>
<tr><td>6.8</td><td>Unions</td><td>Yes</td><td></td></tr>
<tr><td>6.9</td><td>Constant items</td><td>Yes</td><td></td></tr>
<tr><td>6.10</td><td>Static items</td><td>Yes</td><td></td></tr>
<tr><td>6.11</td><td>Traits</td><td>Yes</td><td></td></tr>
<tr><td>6.12</td><td>Implementations</td><td>Yes</td><td></td></tr>
<tr><td>6.13</td><td>External blocks</td><td>Yes</td><td></td></tr>
<tr><td>6.14</td><td>Generic parameters</td><td>Yes</td><td></td></tr>
<tr><td>6.15</td><td>Associated Items</td><td>Yes</td><td></td></tr>
<tr><td>7</td><td>Attributes</td><td>Yes</td><td></td></tr>
<tr><td>8.1</td><td>Statements</td><td>Yes</td><td></td></tr>
<tr><td>8.2.1</td><td>Literal expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.2</td><td>Path expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.3</td><td>Block expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.4</td><td>Operator expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.5</td><td>Grouped expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.6</td><td>Array and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.7</td><td>Tuple and index expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.8</td><td>Struct expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.9</td><td>Call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.10</td><td>Method call expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.11</td><td>Field access expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.12</td><td>Closure expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.13</td><td>Loop expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.14</td><td>Range expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.15</td><td>If and if let expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.16</td><td>Match expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.17</td><td>Return expressions</td><td>Yes</td><td></td></tr>
<tr><td>8.2.18</td><td>Await expressions</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>9</td><td>Patterns</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/707">#707</a></td></tr>
<tr><td>10.1.1</td><td>Boolean type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.2</td><td>Numeric types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.3</td><td>Textual types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.4</td><td>Never type</td><td>Yes</td><td></td></tr>
<tr><td>10.1.5</td><td>Tuple types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.6</td><td>Array types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.7</td><td>Slice types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.8</td><td>Struct types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.9</td><td>Enumerated types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.10</td><td>Union types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.11</td><td>Function item types</td><td>Yes</td><td></td></tr>
<tr><td>10.1.12</td><td>Closure types</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.13</td><td>Pointer types</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.14</td><td>Function pointer types</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.15</td><td>Trait object types</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.16</td><td>Impl trait type</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.17</td><td>Type parameters</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.1.18</td><td>Inferred type</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.2</td><td>Dynamically Sized Types</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.3</td><td>Type layout</td><td>Yes</td><td></td></tr>
<tr><td>10.4</td><td>Interior mutability</td><td>Yes</td><td></td></tr>
<tr><td>10.5</td><td>Subtyping and Variance</td><td>Yes</td><td></td></tr>
<tr><td>10.6</td><td>Trait and lifetime bounds</td><td>Yes</td><td></td></tr>
<tr><td>10.7</td><td>Type coercions</td><td>Partial</td><td>See <a href="#advanced-features">Notes - Advanced features</a></td></tr>
<tr><td>10.8</td><td>Destructors</td><td>Partial</td><td></td></tr>
<tr><td>10.9</td><td>Lifetime elision</td><td>Yes</td><td></td></tr>
<tr><td>11</td><td>Special types and traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Box&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Rc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Arc&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Pin&lt;T&gt;</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>UnsafeCell&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>PhantomData&lt;T&gt;</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td>Operator Traits</td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Deref</code> and <code>DerefMut</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Drop</code></td><td>Partial</td><td></td></tr>
<tr><td></td><td><code>Copy</code></td><td>Yes</td><td></td></tr>
<tr><td></td><td><code>Clone</code></td><td>Yes</td><td></td></tr>
<tr><td>14</td><td>Linkage</td><td>Yes</td><td></td></tr>
<tr><td>15.1</td><td>Unsafe functions</td><td>Yes</td><td></td></tr>
<tr><td>15.2</td><td>Unsafe blocks</td><td>Yes</td><td></td></tr>
<tr><td>15.3</td><td>Behavior considered undefined</td><td>Partial</td><td></td></tr>
<tr><td></td><td>Data races</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td></td><td>Dereferencing dangling raw pointers</td><td>Yes</td><td></td></tr>
<tr><td></td><td>Dereferencing unaligned raw pointers</td><td>No</td><td></td></tr>
<tr><td></td><td>Breaking pointer aliasing rules</td><td>No</td><td></td></tr>
<tr><td></td><td>Mutating immutable data</td><td>No</td><td></td></tr>
<tr><td></td><td>Invoking undefined behavior via compiler intrinsics</td><td>Partial</td><td>See <a href="#intrinsics">Notes - Intrinsics</a></td></tr>
<tr><td></td><td>Executing code compiled with platform features that the current platform does not support</td><td>No</td><td></td></tr>
<tr><td></td><td>Producing an invalid value, even in private fields and locals</td><td>No</td><td></td></tr>
</tbody>
</table>
</div>
<h2 id="notes-on-partially-or-unsupported-features"><a class="header" href="#notes-on-partially-or-unsupported-features">Notes on partially or unsupported features</a></h2>
<h3 id="code-generation-for-unsupported-features"><a class="header" href="#code-generation-for-unsupported-features">Code generation for unsupported features</a></h3>
<p>Kani aims to be an industrial verification tool. Most industrial crates may
include unsupported features in parts of their code that do not need to be
verified. In general, this should not prevent users using Kani to verify their code.</p>
<p>Because of that, the general rule is that Kani generates an <code>assert(false)</code>
statement followed by an <code>assume(false)</code> statement when compiling any
unsupported feature. <code>assert(false)</code> will cause verification to fail if the
statement is reachable during the verification stage, while <code>assume(false)</code> will
block any further exploration of the path. However, the analysis will not be
affected if the statement is not reachable from the code under verification, so
users can still verify components of their code that do not use unsupported
features.</p>
<p>In a few cases, Kani aborts execution if the analysis could be affected in
some way because of an unsupported feature (e.g., global ASM).</p>
<h3 id="assembly"><a class="header" href="#assembly">Assembly</a></h3>
<p>Kani does not support assembly code for now. We may add it in the future but at
present there are no plans to do so.</p>
<p>Check out the tracking issues for <a href="https://github.com/model-checking/kani/issues/2">inline assembly (<code>asm!</code>
macro)</a> and <a href="https://github.com/model-checking/kani/issues/316">global assembly
(<code>asm_global!</code> macro)</a> to know
more about the current status.</p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Concurrent features are currently out of scope for Kani. In general, the
verification of concurrent programs continues to be an open research problem
where most tools that analyze concurrent code lack support for other features.
Because of this, Kani emits a warning whenever it encounters concurrent code and
compiles as if it was sequential code.</p>
<h3 id="standard-library-functions"><a class="header" href="#standard-library-functions">Standard library functions</a></h3>
<p>Kani <a href="#overrides">overrides</a> a few common functions
(e.g., print macros) to provide a more verification friendly implementation.</p>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced features</a></h3>
<p>The semantics around some advanced features (traits, types, etc.) from Rust are
not formally defined which makes it harder to ensure that we can properly model
all their use cases.</p>
<p>We are aware of a lack of sanity checking the <code>Variant</code> type in projections
<a href="https://github.com/model-checking/kani/issues/448">#448</a>.
If you become aware of other issues concerning
these features, please <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md">file a bug
report</a>.</p>
<h3 id="panic-strategies"><a class="header" href="#panic-strategies">Panic strategies</a></h3>
<p>Rust has two different strategies when a panic occurs:</p>
<ol>
<li>Stack unwinding (default): Walks back the stack cleaning up the data from
each function it encounters.</li>
<li>Abortion: Immediately ends the program without cleaning up.</li>
</ol>
<p>Currently, Kani does not support stack unwinding. This has some implications
regarding memory safety since programs sometimes rely on the unwinding logic to
ensure there is no resource leak or persistent data inconsistency. Check out
<a href="https://github.com/model-checking/kani/issues/692">this issue</a> for updates on
stack unwinding support.</p>
<h3 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h3>
<p>Reading uninitialized memory is
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#behavior-considered-undefined">considered undefined behavior</a> in Rust.
Kani has partial, experimental support for detecting access to uninitialized memory with the <code>-Z uninit-checks</code> option.
See <a href="https://github.com/model-checking/kani/issues/3300">this issue</a> for more details.</p>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>At present, we are aware of some issues with destructors, in particular those
related to <a href="#advanced-features">advanced features</a>.</p>
<h3 id="intrinsics"><a class="header" href="#intrinsics">Intrinsics</a></h3>
<p>Please refer to <a href="#intrinsics-1">Intrinsics</a> for information
on the current support in Kani for Rust compiler intrinsics.</p>
<h3 id="floating-point-operations"><a class="header" href="#floating-point-operations">Floating point operations</a></h3>
<p>Kani supports floating point numbers, but some supported operations on floats are “over-approximated.”
These are the trigonometric functions like <code>sin</code> and <code>cos</code> and the <code>sqrt</code> function as well.
This means the verifier can raise errors that cannot actually happen when the code is run normally.
For instance, (<a href="https://github.com/model-checking/kani/issues/1342">#1342</a>) the <code>sin</code>/<code>cos</code> functions basically return a nondeterministic value between -1 and 1.
In other words, they largely ignore their input and give very conservative answers.
This range certainly includes the “real” value, so proof soundness is still preserved, but it means Kani could raise spurious errors that cannot actually happen.
This makes Kani unsuitable for verifying some kinds of properties (e.g. precision) about numerical algorithms.
Proofs that fail because of this problem can sometimes be repaired by introducing “stubs” for these functions that return a more acceptable approximation.
However, note that the actual behavior of these functions can vary by platform/os/architecture/compiler, so introducing an “overly precise” approximation may introduce unsoundness: actual system behavior may produce different values from the stub’s approximation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="intrinsics-1"><a class="header" href="#intrinsics-1">Intrinsics</a></h1>
<p>The tables below try to summarize the current support in Kani for Rust intrinsics.
We define the level of support similar to how we indicate <a href="#rust-feature-support">Rust feature support</a>:</p>
<ul>
<li><strong>Yes</strong>: The intrinsic is fully supported. We are not aware of any issue with it.</li>
<li><strong>Partial</strong>: The intrinsic is at least partially supported. We are aware of some issue with
with it.</li>
<li><strong>No</strong>: The intrinsic is not supported.</li>
</ul>
<p>In general, code generation for unsupported intrinsics follows the rule
described in <a href="#code-generation-for-unsupported-features">Rust feature support - Code generation for unsupported
features</a>.</p>
<p>Any intrinsic not appearing in the tables below is considered not supported.
Please <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=%5BC%5D+Feature+%2F+Enhancement&amp;template=feature_request.md&amp;title=">open a feature request</a>
if your code depends on an unsupported intrinsic.</p>
<h3 id="compiler-intrinsics"><a class="header" href="#compiler-intrinsics">Compiler intrinsics</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Support</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>abort</td><td>Yes</td><td></td></tr>
<tr><td>add_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>arith_offset</td><td>Yes</td><td></td></tr>
<tr><td>assert_inhabited</td><td>Yes</td><td></td></tr>
<tr><td>assert_uninit_valid</td><td>Yes</td><td></td></tr>
<tr><td>assert_zero_valid</td><td>Yes</td><td></td></tr>
<tr><td>assume</td><td>Yes</td><td></td></tr>
<tr><td>atomic_and_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_and_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acqrel_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_acquire_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_relaxed_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_release_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchg_seqcst_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acqrel_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_acquire_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_relaxed_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_release_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_cxchgweak_seqcst_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_fence_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_load_unordered</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_max_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_min_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_nand_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_or_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_singlethreadfence_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_store_unordered</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umax_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_umin_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xadd_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xchg_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xor_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_seqcst</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acquire</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_acqrel</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_release</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>atomic_xsub_relaxed</td><td>Partial</td><td>See <a href="#atomics">Atomics</a></td></tr>
<tr><td>blackbox</td><td>Yes</td><td></td></tr>
<tr><td>bitreverse</td><td>Yes</td><td></td></tr>
<tr><td>breakpoint</td><td>Yes</td><td></td></tr>
<tr><td>bswap</td><td>Yes</td><td></td></tr>
<tr><td>caller_location</td><td>No</td><td></td></tr>
<tr><td>ceilf32</td><td>Yes</td><td></td></tr>
<tr><td>ceilf64</td><td>Yes</td><td></td></tr>
<tr><td>copy</td><td>Yes</td><td></td></tr>
<tr><td>copy_nonoverlapping</td><td>Yes</td><td></td></tr>
<tr><td>copysignf32</td><td>Yes</td><td></td></tr>
<tr><td>copysignf64</td><td>Yes</td><td></td></tr>
<tr><td>cosf32</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/cosf32.rs">this test</a> explains how</td></tr>
<tr><td>cosf64</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/cosf64.rs">this test</a> explains how</td></tr>
<tr><td>ctlz</td><td>Yes</td><td></td></tr>
<tr><td>ctlz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>ctpop</td><td>Yes</td><td></td></tr>
<tr><td>cttz</td><td>Yes</td><td></td></tr>
<tr><td>cttz_nonzero</td><td>Yes</td><td></td></tr>
<tr><td>discriminant_value</td><td>Yes</td><td></td></tr>
<tr><td>drop_in_place</td><td>No</td><td></td></tr>
<tr><td>exact_div</td><td>Yes</td><td></td></tr>
<tr><td>exp2f32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>exp2f64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>expf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>expf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>fabsf32</td><td>Yes</td><td></td></tr>
<tr><td>fabsf64</td><td>Yes</td><td></td></tr>
<tr><td>fadd_fast</td><td>Yes</td><td></td></tr>
<tr><td>fdiv_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>float_to_int_unchecked</td><td>Yes</td><td></td></tr>
<tr><td>floorf32</td><td>Yes</td><td></td></tr>
<tr><td>floorf64</td><td>Yes</td><td></td></tr>
<tr><td>fmaf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>fmaf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>fmul_fast</td><td>Partial</td><td><a href="https://github.com/model-checking/kani/issues/809">#809</a></td></tr>
<tr><td>forget</td><td>Yes</td><td></td></tr>
<tr><td>frem_fast</td><td>No</td><td></td></tr>
<tr><td>fsub_fast</td><td>Yes</td><td></td></tr>
<tr><td>likely</td><td>Yes</td><td></td></tr>
<tr><td>log10f32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>log10f64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>log2f32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>log2f64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>logf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>logf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>maxnumf32</td><td>Yes</td><td></td></tr>
<tr><td>maxnumf64</td><td>Yes</td><td></td></tr>
<tr><td>align_of</td><td>Yes</td><td></td></tr>
<tr><td>align_of_val</td><td>Yes</td><td></td></tr>
<tr><td>minnumf32</td><td>Yes</td><td></td></tr>
<tr><td>minnumf64</td><td>Yes</td><td></td></tr>
<tr><td>move_val_init</td><td>No</td><td></td></tr>
<tr><td>mul_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>needs_drop</td><td>Yes</td><td></td></tr>
<tr><td>nontemporal_store</td><td>No</td><td></td></tr>
<tr><td>offset</td><td>Partial</td><td>Doesn’t check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-2">all UB conditions</a></td></tr>
<tr><td>powf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>powf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>powif32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>powif64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>prefetch_read_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_read_instruction</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_data</td><td>No</td><td></td></tr>
<tr><td>prefetch_write_instruction</td><td>No</td><td></td></tr>
<tr><td>ptr_guaranteed_eq</td><td>Yes</td><td></td></tr>
<tr><td>ptr_guaranteed_ne</td><td>Yes</td><td></td></tr>
<tr><td>ptr_offset_from</td><td>Partial</td><td>Doesn’t check <a href="https://doc.rust-lang.org/std/primitive.pointer.html#safety-4">all UB conditions</a></td></tr>
<tr><td>raw_eq</td><td>Partial</td><td>Cannot detect <a href="#uninitialized-memory">uninitialized memory</a></td></tr>
<tr><td>round_ties_even_f16</td><td>No</td><td></td></tr>
<tr><td>round_ties_even_f32</td><td>Yes</td><td></td></tr>
<tr><td>round_ties_even_f64</td><td>Yes</td><td></td></tr>
<tr><td>round_ties_even_f128</td><td>No</td><td></td></tr>
<tr><td>rotate_left</td><td>Yes</td><td></td></tr>
<tr><td>rotate_right</td><td>Yes</td><td></td></tr>
<tr><td>roundf32</td><td>Yes</td><td></td></tr>
<tr><td>roundf64</td><td>Yes</td><td></td></tr>
<tr><td>rustc_peek</td><td>No</td><td></td></tr>
<tr><td>saturating_add</td><td>Yes</td><td></td></tr>
<tr><td>saturating_sub</td><td>Yes</td><td></td></tr>
<tr><td>sinf32</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/sinf32.rs">this test</a> explains how</td></tr>
<tr><td>sinf64</td><td>Partial</td><td>Results are overapproximated; <a href="https://github.com/model-checking/kani/blob/main/tests/kani/Intrinsics/Math/Trigonometry/sinf64.rs">this test</a> explains how</td></tr>
<tr><td>size_of</td><td>Yes</td><td></td></tr>
<tr><td>size_of_val</td><td>Yes</td><td></td></tr>
<tr><td>sqrtf32</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>sqrtf64</td><td>Partial</td><td>Results are overapproximated</td></tr>
<tr><td>sub_with_overflow</td><td>Yes</td><td></td></tr>
<tr><td>transmute</td><td>Partial</td><td>Doesn’t check <a href="https://doc.rust-lang.org/nomicon/transmutes.html">all UB conditions</a></td></tr>
<tr><td>truncf32</td><td>Yes</td><td></td></tr>
<tr><td>truncf64</td><td>Yes</td><td></td></tr>
<tr><td>try</td><td>No</td><td><a href="https://github.com/model-checking/kani/issues/267">#267</a></td></tr>
<tr><td>type_id</td><td>Yes</td><td></td></tr>
<tr><td>type_name</td><td>Yes</td><td></td></tr>
<tr><td>typed_swap_nonoverlapping</td><td>Yes</td><td></td></tr>
<tr><td>unaligned_volatile_load</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unaligned_volatile_store</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>unchecked_add</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_div</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_mul</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_rem</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shl</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_shr</td><td>Yes</td><td></td></tr>
<tr><td>unchecked_sub</td><td>Yes</td><td></td></tr>
<tr><td>unlikely</td><td>Yes</td><td></td></tr>
<tr><td>unreachable</td><td>Yes</td><td></td></tr>
<tr><td>variant_count</td><td>Yes</td><td></td></tr>
<tr><td>volatile_copy_memory</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_copy_nonoverlapping_memory</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_load</td><td>Partial</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_set_memory</td><td>No</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>volatile_store</td><td>Partial</td><td>See <a href="#concurrency">Notes - Concurrency</a></td></tr>
<tr><td>wrapping_add</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_mul</td><td>Yes</td><td></td></tr>
<tr><td>wrapping_sub</td><td>Yes</td><td></td></tr>
<tr><td>write_bytes</td><td>Yes</td><td></td></tr>
</tbody>
</table>
</div>
<h4 id="atomics"><a class="header" href="#atomics">Atomics</a></h4>
<p>All atomic intrinsics are compiled as an atomic block where the operation is
performed. But as noted in <a href="#concurrency">Notes - Concurrency</a>, Kani support for
concurrent verification is limited and not used by default. Verification on code
containing atomic intrinsics should not be trusted given that Kani assumes the
code to be sequential.</p>
<h3 id="platform-intrinsics"><a class="header" href="#platform-intrinsics">Platform intrinsics</a></h3>
<p>Intrinsics from <a href="https://rust-lang.github.io/rfcs/1199-simd-infrastructure.html#operations">the <code>platform_intrinsics</code> feature</a>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Support</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>simd_add</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_and</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_div</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_eq</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_extract</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_ge</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_gt</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_insert</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_le</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_lt</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_mul</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_ne</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_or</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_rem</code></td><td>Yes</td><td>Doesn’t check for floating point overflow <a href="https://github.com/model-checking/kani/issues/2669">#2669</a></td></tr>
<tr><td><code>simd_shl</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_shr</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_shuffle*</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_sub</code></td><td>Yes</td><td></td></tr>
<tr><td><code>simd_xor</code></td><td>Yes</td><td></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>In general, unstable Rust features are out of scope and any support
for them available in Kani should be considered unstable as well.</p>
<p>The following are examples of unstable features that are not supported
in Kani:</p>
<ul>
<li>Generators</li>
<li>C-variadics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overrides"><a class="header" href="#overrides">Overrides</a></h1>
<p>As explained in <a href="#comparison-with-other-tools">Comparison with other
tools</a>, Kani is based on a
technique called model checking, which verifies a program without actually
executing it. It does so through encoding the program and analyzing the encoded
version. The encoding process often requires “modeling” some of the library
functions to make them suitable for analysis. Typical examples of functionality
that requires modeling are system calls and I/O operations. In some cases, Kani
performs such encoding through overriding some of the definitions in the Rust
standard library.</p>
<p>The following table lists some of the symbols that Kani
overrides and a description of their behavior compared to the <code>std</code> versions:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>assert</code>, <code>assert_eq</code>, and <code>assert_ne</code> macros</td><td>Skips string formatting code, generates a more informative message and performs some instrumentation</td></tr>
<tr><td><code>debug_assert</code>, <code>debug_assert_eq</code>, and <code>debug_assert_ne</code> macros</td><td>Rewrites as equivalent <code>assert*</code> macro</td></tr>
<tr><td><code>print</code>, <code>eprint</code>, <code>println</code>, and <code>eprintln</code> macros</td><td>Skips string formatting and I/O operations</td></tr>
<tr><td><code>unreachable</code> macro</td><td>Skips string formatting and invokes <code>panic!()</code></td></tr>
<tr><td><code>std::process::{abort, exit}</code> functions</td><td>Invokes <code>panic!()</code> to abort the execution</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="faqs"><a class="header" href="#faqs">FAQs</a></h1>
<p>This section collects frequently asked questions about Kani.
Please consider <a href="https://github.com/model-checking/kani/issues/new/choose">opening an issue</a> if you have a question that would like to see here.</p>
<h2 id="questions"><a class="header" href="#questions">Questions</a></h2>
<details>
<summary>Kani doesn't fail after <code>kani::assume(false)</code>. Why?</summary>

<p><code>kani::assume(false)</code> (or <code>kani::assume(cond)</code> where <code>cond</code> is a condition that results in <code>false</code> in the context of the program), won’t cause errors in Kani.
Instead, such an assumption has the effect of blocking all the symbolic execution paths from the assumption.
Therefore, all checks after the assumption should appear as <a href="#../../verification-results.md"><code>UNREACHABLE</code></a>.
That’s the expected behavior for <code>kani::assume(false)</code> in Kani.</p>
<p>If you didn’t expect certain checks in a harness to be <code>UNREACHABLE</code>, we recommend using the <a href="#../../verification-results.md#cover-property-results"><code>kani::cover</code> macro</a> to determine what conditions are possible in case you’ve over-constrained the harness.</p>
</details>
<details>
<summary>I implemented the <code>kani::Arbitrary</code> trait for a type that's not from my crate, and got the error
<code>only traits defined in the current crate can be implemented for types defined outside of the crate</code>.
What does this mean? What can I do?</summary>

<p>This error is due to a violation of Rust’s orphan rules for trait implementations, which are explained <a href="https://doc.rust-lang.org/error_codes/E0117.html">here</a>.
In that case, you’ll need to write a function that builds an object from non-deterministic variables.
Inside this function you would simply return an arbitrary value by generating arbitrary values for its components.</p>
<p>For example, let’s assume the type you’re working with is this enum:</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
pub enum Rating {
    One,
    Two,
    Three,
}</code></pre>
<p>Then, you can match on a non-deterministic integer (supplied by <code>kani::any</code>) to return non-deterministic <code>Rating</code> variants:</p>
<pre><code class="language-rust">    pub fn any_rating() -&gt; Rating {
        match kani::any() {
            0 =&gt; Rating::One,
            1 =&gt; Rating::Two,
            _ =&gt; Rating::Three,
        }
    }</code></pre>
<p>More details about this option, which also useful in other cases, can be found <a href="https://model-checking.github.io/kani/tutorial-nondeterministic-variables.html#custom-nondeterministic-types">here</a>.</p>
<p>If the type comes from <code>std</code> (Rust’s standard library), you can <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=%5BC%5D+Feature+%2F+Enhancement&amp;template=feature_request.md&amp;title=">open a request</a> for adding <code>Arbitrary</code> implementations to the Kani library.
Otherwise, there are more involved options to consider:</p>
<ol>
<li>Importing a copy of the external crate that defines the type, then implement <code>Arbitrary</code> there.</li>
<li>Contributing the <code>Arbitrary</code> implementation to the external crate that defines the type.</li>
</ol>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
