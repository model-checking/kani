<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kani RFC Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design documents for Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="template.html">RFC Template</a></li><li class="chapter-item expanded affix "><li class="part-title">Kani RFCs</li><li class="chapter-item expanded "><a href="rfcs/0001-mir-linker.html">0001-mir-linker</a></li><li class="chapter-item expanded "><a href="rfcs/0002-function-stubbing.html">0002-function-stubbing</a></li><li class="chapter-item expanded "><a href="rfcs/0003-cover-statement.html">0003-cover-statement</a></li><li class="chapter-item expanded "><a href="rfcs/0004-loop-contract-synthesis.html">0004-loop-contract-synthesis</a></li><li class="chapter-item expanded "><a href="rfcs/0005-should-panic-attr.html">0005-should-panic-attr</a></li><li class="chapter-item expanded "><a href="rfcs/0006-unstable-api.html">0006-unstable-api</a></li><li class="chapter-item expanded "><a href="rfcs/0007-global-conditions.html">0007-global-conditions</a></li><li class="chapter-item expanded "><a href="rfcs/0008-line-coverage.html">0008-line-coverage</a></li><li class="chapter-item expanded "><a href="rfcs/0009-function-contracts.html">0009-function-contracts</a></li><li class="chapter-item expanded "><a href="rfcs/0010-quantifiers.html">0010-quantifiers</a></li><li class="chapter-item expanded "><a href="rfcs/0011-source-coverage.html">0011-source-coverage</a></li><li class="chapter-item expanded "><a href="rfcs/0012-loop-contracts.html">0012-loop-contracts</a></li><li class="chapter-item expanded "><a href="rfcs/0013-list.html">0013-list</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kani RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Kani is an open-source verification tool that uses automated reasoning to analyze Rust programs. In order to
integrate feedback from developers and users on future changes to Kani, we decided to follow a light-weight
&quot;RFC&quot; (request for comments) process.</p>
<h2 id="when-to-create-an-rfc"><a class="header" href="#when-to-create-an-rfc">When to create an RFC</a></h2>
<p>You should create an RFC in one of two cases:</p>
<ol>
<li>The change you are proposing would be a &quot;one way door&quot;: e.g. a major change to the public API, a new feature that would be difficult to modify once released, etc.</li>
<li>The change you are making has a significant design component, and would benefit from a design review.</li>
</ol>
<p>Bugs and improvements to existing features do not require an RFC.
If you are in doubt, feel free to create  a <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=&amp;template=feature_request.md">feature request</a> and discuss the next steps in the new issue.
Your PR reviewer may also request an RFC if your change appears to fall into category 1 or 2.</p>
<p>You do not necessarily need to create an RFC immediately. It is our experience that it is often best to write some &quot;proof of concept&quot; code to test out possible ideas before writing the formal RFC.</p>
<h2 id="the-rfc-process"><a class="header" href="#the-rfc-process">The RFC process</a></h2>
<p>This is the overall workflow for the RFC process:</p>
<pre><code class="language-toml">    Create RFC ──&gt; Receive Feedback  ──&gt; Accepted?
                        │  ∧                  │ Y
                        ∨  │                  ├───&gt; Implement ───&gt; Test + Feedback ───&gt; Stabilize?
                       Revise                 │ N                                          │ Y
                                              └───&gt; Close PR                               ├───&gt; RFC Stable
                                                                                           │ N
                                                                                           └───&gt; Remove feature
</code></pre>
<ol>
<li>Create an RFC
<ol>
<li>Create a tracking issue for your RFC (e.g.: <a href="https://github.com/model-checking/kani/issues/1588">Issue-1588</a>).</li>
<li>Start from a fork of the Kani repository.</li>
<li>Copy the template file (<a href="./template.html"><code>rfc/src/template.md</code></a>) to <code>rfc/src/rfcs/&lt;ID_NUMBER&gt;&lt;my-feature&gt;.md</code>.</li>
<li>Fill in the details according to the template instructions.</li>
</ol>
<ul>
<li>For the first RFC version, we recommend that you leave the &quot;Software Design&quot; section empty.</li>
<li>Focus on the user impact and user experience.
Include a few usage examples if possible.</li>
</ul>
<ol start="5">
<li>Add a link to the new RFC inside <a href="https://github.com/model-checking/kani/blob/main/rfc/src/SUMMARY.md"><code>rfc/src/SUMMARY.md</code></a></li>
<li>Submit a pull request.</li>
</ol>
</li>
<li>Build consensus and integrate feedback.
<ol>
<li>RFCs should get approved by at least 2 Kani developers.</li>
<li>Once the RFC has been approved, update the RFC status and merge the PR.</li>
<li>If the RFC is not approved, close the PR without merging.</li>
</ol>
</li>
<li>Feature implementation.
<ol>
<li>Start implementing the new feature in your fork.</li>
<li>Create a new revision of the RFC to add details about the &quot;Software Design&quot;.</li>
<li>It is OK to implement the feature incrementally over multiple PRs.
Just ensure that every pull request has a testable end-to-end flow and that it is properly tested.</li>
<li>In the implementation stage, the feature should only be accessible if the user explicitly passes
<code>-Z &lt;FEATURE_ID&gt;</code> as an argument to Kani.</li>
<li>Document how to use the feature.</li>
<li>Keep the RFC up-to-date with the decisions you make during implementation.</li>
</ol>
</li>
<li>Test and Gather Feedback.
<ol>
<li>Fix major issues related to the new feature.</li>
<li>Gather user feedback and make necessary adjustments.</li>
<li>Resolve RFC open questions.</li>
<li>Add regression tests to cover all expected behaviors and unit tests whenever possible.</li>
</ol>
</li>
<li>Stabilization.
<ol>
<li>Propose to stabilize the feature when feature is well tested and UX has received positive feedback.</li>
<li>Create a new PR that makes the option a no-op with a deprecation warning.</li>
<li><em>Only after the PR from #2 is included in a release</em>, create another PR that actually removes the option and marks the RFC status as &quot;STABLE&quot;.
<ol>
<li>Make sure the RFC reflects the final implementation and user experience.</li>
<li>See <a href="https://github.com/model-checking/kani/issues/3561">#3561</a> for an example of such a two-phase deletion, where we first deprecate the option in one release, then remove it in the next. See also <a href="rfcs/0006-unstable-api.html">0006-unstable-api</a>.</li>
</ol>
</li>
<li>In some cases, we might decide not to incorporate a feature
(E.g.: performance degradation, bad user experience, better alternative).
In those cases, please update the RFC status to &quot;CANCELLED as per &lt;PR_LINK | ISSUE_LINK&gt;&quot; and remove the code
that is no longer relevant.</li>
<li>Close the tracking issue.</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> <em>Fill me with pretty name and a unique ident <sup class="footnote-reference"><a href="#unstable_feature">1</a></sup>. Example: New Feature (<code>new_feature</code>)</em></li>
<li><strong>Feature Request Issue:</strong> <em>Link to issue</em></li>
<li><strong>RFC PR:</strong> <em>Link to original PR</em></li>
<li><strong>Status:</strong> <em>One of the following: [Under Review | Unstable | Stable | Cancelled]</em></li>
<li><strong>Version:</strong> [0-9]* <em>Increment this version whenever you open a new PR to update the RFC (not at every revision).
Start with 0.</em></li>
<li><strong>Proof-of-concept:</strong> <em>Optional field. If you have implemented a proof of concept, add a link here</em></li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Short (1-2 sentences) description of the feature. What is this feature about?</p>
<h2 id="user-impact"><a class="header" href="#user-impact">User Impact</a></h2>
<p>Imagine this as your elevator pitch directed to users as well as Kani developers.</p>
<ul>
<li>Why are we doing this?</li>
<li>Why should users care about this feature?</li>
<li>How will this benefit them?</li>
<li>What is the downside?</li>
</ul>
<p>If this RFC is related to change in the architecture without major user impact,
think about the long term impact for user.
I.e.: what future work will this enable.</p>
<ul>
<li>If you are unsure you need an RFC, please create a feature request issue and discuss the need with other Kani developers.</li>
</ul>
<h2 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h2>
<p>This should be a description on how users will interact with the feature.
Users should be able to read this section and understand how to use the feature.
<strong>Do not include implementation details in this section, neither discuss the rationale behind the chosen UX.</strong></p>
<p>Please include:</p>
<ul>
<li>High level user flow description.</li>
<li>Any new major functions or attributes that will be added to Kani library.</li>
<li>New command line options or subcommands (no need to mention the unstable flag).</li>
<li>List failure scenarios and how are they presented (e.g., compilation errors, verification failures, and possible failed user iterations).</li>
<li>Substantial changes to existing functionality or Kani output.</li>
</ul>
<p>If the RFC is related to architectural changes and there are no visible changes to UX, please state so.
No further explanation is needed.</p>
<h2 id="software-design"><a class="header" href="#software-design">Software Design</a></h2>
<p><strong>We recommend that you leave the Software Design section empty for the first version of your RFC</strong>.</p>
<p>This is the beginning of the technical portion of the RFC.
From now on, your main audience is Kani developers, so it's OK to assume readers know Kani architecture.</p>
<p>Please provide a high level description your design.</p>
<ul>
<li>What are the main components that will be modified? (E.g.: changes to <code>kani-compiler</code>, <code>kani-driver</code>, metadata, proc-macros, installation...)</li>
<li>Will there be changes to the components interface?</li>
<li>Any changes to how these components communicate?</li>
<li>What corner cases do you anticipate?</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>This is the section where you discuss the decisions you made.</p>
<ul>
<li>What are the pros and cons of the UX? What would be the alternatives?</li>
<li>What is the impact of not doing this?</li>
<li>Any pros / cons on how you designed this?</li>
</ul>
<h2 id="open-questions"><a class="header" href="#open-questions">Open questions</a></h2>
<p>List of open questions + an optional link to an issue that captures the work required to address the open question.
Capture the details of each open question in their respective issue, not here.</p>
<p>Example:</p>
<ul>
<li>Is there any use case that isn't handled yet?</li>
<li>Is there any part of the UX that still needs some improvement?</li>
</ul>
<p>Make sure all open questions are addressed before stabilization.</p>
<h2 id="out-of-scope--future-improvements"><a class="header" href="#out-of-scope--future-improvements">Out of scope / Future Improvements</a></h2>
<p><em>Optional Section</em>: List of extensions and possible improvements that you predict for this feature that is out of
the scope of this RFC.</p>
<p>Feel free to add as many items as you want, but please refrain from adding too much detail.
If you want to capture your thoughts or start a discussion, please create a feature request.
You are welcome to add a link to the new issue here.</p>
<div class="footnote-definition" id="unstable_feature"><sup class="footnote-definition-label">1</sup>
<p>This unique ident should be used to enable features proposed in the RFC using <code>-Z &lt;ident&gt;</code> until the feature has been stabilized.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> MIR Linker (<code>mir_linker</code>)</li>
<li><strong>RFC Tracking Issue</strong>: <a href="https://github.com/model-checking/kani/issues/1588">https://github.com/model-checking/kani/issues/1588</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1600">https://github.com/model-checking/kani/pull/1600</a></li>
<li><strong>Status:</strong> Stable</li>
<li><strong>Version:</strong> 3</li>
</ul>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Fix linking issues with the rust standard library in a scalable manner by only generating goto-program for
code that is reachable from the user harnesses.</p>
<h2 id="user-impact-1"><a class="header" href="#user-impact-1">User Impact</a></h2>
<p>The main goal of this RFC is to enable Kani users to link against all supported constructs from the <code>std</code> library.
Currently, Kani will only link to items that are either generic or have an inline annotation.</p>
<p>The approach introduced in this RFC will have the following secondary benefits.</p>
<ul>
<li>Reduce spurious warnings about unsupported features for cases where the feature is not reachable from any harness.</li>
<li>In the verification mode, we will likely see a reduction on the compilation time and memory consumption
by pruning the inputs of symtab2gb and goto-instrument.
<ul>
<li>Compared to linking against the standard library goto-models that take more than 5 GB.</li>
</ul>
</li>
<li>In a potential assessment mode, only analyze code that is reachable from all public items in the target crate.</li>
</ul>
<p>One downside is that we will include a pre-compiled version of the std, our release bundle will double in size
(See <a href="rfcs/0001-mir-linker.html#rational-and-alternatives">Rational and Alternatives</a>
for more information on the size overhead).
This will negatively impact the time taken to set up Kani
(triggered by either the first time a user invokes <code>kani | cargo-kani</code> , or explicit invoke the subcommand <code>setup</code>).</p>
<h2 id="user-experience-1"><a class="header" href="#user-experience-1">User Experience</a></h2>
<p>Once this RFC has been stabilized users shall use Kani in the same manner as they have been today.
Until then, we wil add an unstable option <code>--mir-linker</code> to enable the cross-crate reachability analysis
and the generation of the goto-program only when compiling the target crate.</p>
<p>Kani setup will likely take longer and more disk space as mentioned in the section above.
This change will not be guarded by <code>--mir-linker</code> option above.</p>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>In a nutshell, we will no longer generate a goto-program for every crate we compile.
Instead, we will generate the MIR for every crate, and we will generate only one goto-program.
This model will only include items reachable from the target crate's harnesses.</p>
<p>The current system flow for a crate verification is the following (Kani here represents either <code>kani | cargo-kani</code>
executable):</p>
<ol>
<li>Kani compiles the user crate as well as all its dependencies.
For every crate compiled, <code>kani-compiler</code> will generate a goto-program.
This model includes everything reachable from the crate's public functions.</li>
<li>After that, Kani links all models together by invoking <code>goto-cc</code>.
This step will also link against Kani's <code>C</code> library.</li>
<li>For every harness, Kani invokes <code>goto-instrument</code> to prune the linked model to only include items reachable from the given harness.</li>
<li>Finally, Kani instruments and verify each harness model via <code>goto-instrument</code> and <code>cbmc</code> calls.</li>
</ol>
<p>After this RFC, the system flow would be slightly different:</p>
<ol>
<li>Kani compiles the user crate dependencies up to the MIR translation.
I.e., for every crate compiled, <code>kani-compiler</code> will generate an artifact that includes the MIR representation
of all items in the crate.</li>
<li>Kani will generate the goto-program only while compiling the target user crate.
It will generate one goto-program that includes all items reachable from any harness in the target crate.</li>
<li><code>goto-cc</code> will still be invoked to link the generated model against Kani's <code>C</code> library.</li>
<li>Steps #3 and #4 above will be performed without any change.</li>
</ol>
<p>This feature will require three main changes to Kani which are detailed in the sub-sections below.</p>
<h3 id="kanis-sysroot"><a class="header" href="#kanis-sysroot">Kani's Sysroot</a></h3>
<p>Kani currently uses <code>rustup</code> sysroot to gather information from the standard library constructs.
The artifacts from this <code>sysroot</code> include the MIR for generic items as well as for items that may be included in
a crate compilation (e.g.: functions marked with <code>#[inline]</code> annotation).
The artifacts do not include the MIR for items that have already been compiled to the <code>std</code> shared library.
This leaves a gap that cannot be filled by the <code>kani-compiler</code>;
thus, we are unable to translate these items into goto-program.</p>
<p>In order to fulfill this gap, we must compile the standard library from scratch.
This RFC proposes a similar method to what <a href="https://github.com/rust-lang/miri"><code>MIRI</code></a> implements.
We will generate our own sysroot using the <code>-Z always-encode-mir</code> compilation flag.
This sysroot will be pre-compiled and included in our release bundle.</p>
<p>We will compile <code>kani</code>'s libraries (<code>kani</code> and <code>std</code>) also with <code>-Z always-encode-mir</code>
and with the new sysroot.</p>
<h3 id="cross-crate-reachability-analysis"><a class="header" href="#cross-crate-reachability-analysis">Cross-Crate Reachability Analysis</a></h3>
<p><code>kani-compiler</code> will include a new <code>reachability</code> module to traverse over the local and external MIR items.
This module will <code>monomorphize</code> all generic code as it's performing the traversal.</p>
<p>The traversal logic will be customizable allowing different starting points to be used.
The two options to be included in this RFC is starting from all local harnesses
(tagged with <code>#[kani::proof]</code>) and all public functions in the local crate.</p>
<p>The <code>kani-compiler</code> behavior will be customizable via a new flag:</p>
<pre><code>--reachability=[ harnesses | pub_fns |  none | legacy | tests ]
</code></pre>
<p>where:</p>
<ul>
<li><code>harnesses</code>: Use the local harnesses as the starting points for the reachability analysis.</li>
<li><code>pub_fns</code>: Use the public local functions as the starting points for the reachability analysis.</li>
<li><code>none</code>: This will be the default value if <code>--reachability</code> flag is not provided. It will skip
reachability analysis. No goto-program will be generated.
This will be used to compile dependencies up to the MIR level.
<code>kani-compiler</code> will still generate artifacts with the crate's MIR.</li>
<li><code>tests</code>: Use the functions marked as tests with <code>#[tests]</code> as the starting points for the analysis.</li>
<li><code>legacy</code>: Mimics <code>rustc</code> behavior by invoking
<code>rustc_monomorphizer::collect_and_partition_mono_items()</code> to collect the items to be generated.
This will not include many items that go beyond the crate boundary.
<em>This option was only kept for now for internal usage in some of our compiler tests.</em>
<em>It cannot be used as part of the end to end verification flow, and it will be removed in the future.</em></li>
</ul>
<p>These flags will not be exposed to the final user.
They will only be used for the communication between <code>kani-driver</code> and <code>kani-compiler</code>.</p>
<h3 id="dependencies-vs-target-crate-compilation"><a class="header" href="#dependencies-vs-target-crate-compilation">Dependencies vs Target Crate Compilation</a></h3>
<p>The flags described in the section above will be used by <code>kani-driver</code> to implement the new system flow.
For that, we propose the following mechanism:</p>
<ul>
<li>
<p>For standalone <code>kani</code>, we will pass the option <code>--reachability=harnesses</code> to <code>kani-compiler</code>.</p>
</li>
<li>
<p>For <code>cargo-kani</code>, we will replace</p>
<pre><code>cargo build &lt;FLAGS&gt;
</code></pre>
<p>with:</p>
<pre><code>cargo rustc &lt;FLAGS&gt; -- --reachability=harnesses
</code></pre>
<p>to build everything.
This command will compile all dependencies without the <code>--reachability</code> argument, and it will only pass <code>harnesses</code>
value to the compiler when compiling the target crate.</p>
</li>
</ul>
<h2 id="rational-and-alternatives"><a class="header" href="#rational-and-alternatives">Rational and Alternatives</a></h2>
<p>Not doing anything is not an alternative, since this fixes a major gap in Kani's usability.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ul>
<li>The MIR linker will allow us to fix the linking issues with Rust's standard library.</li>
<li>Once stabilized, the MIR linker will be transparent to the user.</li>
<li>It will enable more powerful and precise static analysis to <code>kani-compiler</code>.</li>
<li>It won't require any changes to our dependencies.</li>
<li>This will fix the harnesses' dependency on the<code>#[no_mangle]</code> annotation
(<a href="https://github.com/model-checking/kani/issues/661">Issue-661</a>).</li>
</ul>
<h3 id="risks"><a class="header" href="#risks">Risks</a></h3>
<p>Failures in the linking stage would not impact the tool soundness. I anticipate the following failure scenarios:</p>
<ul>
<li>ICE (Internal compiler error): Some logic is incorrectly implemented and the linking stage crashes.
Although this is a bad experience for the user, this will not impact the verification result.</li>
<li>Missing items: This would either result in ICE during code generation or a verification failure if the missing
item is reachable.</li>
<li>Extra items: This shouldn't impact the verification results, and they should be pruned by CBMC's reachability
analysis.
This is already the case today. In extreme cases, this could include a symbol that we cannot compile and cause an ICE.</li>
</ul>
<p>The new reachability code would be highly dependent on the <code>rustc</code> unstable APIs, which could increase
the cost of the upstream synchronization.
That said, the APIs that would be required are already used today.</p>
<p>Finally, this implementation relies on a few unstable options from <code>cargo</code> and <code>rustc</code>.
These APIs are used by other tools such as MIRI, so we don't see a high risk that they would be removed.</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>The other options explored were:</p>
<ol>
<li>Pre-compile the standard library, and the kani library, and ship the generated <code>*symtab.json</code> files.</li>
<li>Pre-compile the standard library, and the kani library, convert the standard library and dependencies to goto-program
(via<code>symtab2gb</code>) and link them into one single goto-program.
Ship the generated model.</li>
</ol>
<p>Both would still require shipping the compiler metadata (via <code>rlib</code> or <code>rmeta</code>) for the kani library, its
dependencies, and <code>kani_macro.so</code>.</p>
<p>Both alternatives are very similar. They only differ on the artifact that would be shipped.
They require generating and shipping a custom <code>sysroot</code>;
however, there is no need to implement the reachability algorithm.</p>
<p>We implemented a prototype for the MIR linker and one for the alternatives.
Both prototypes generate the sysroot as part of the <code>cargo kani</code> flow.</p>
<p>We performed a small experiment (on a <code>c5.4xlarge</code> ec2 instance running Ubuntu 20.04) to assess the options.</p>
<p>For this experiment, we used the following harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(4)]
pub fn check_format() {
    assert!(&quot;2&quot;.parse::&lt;u32&gt;().unwrap() == 2);
}
</code></pre>
<p>The experiment showed that the MIR linker approach is much more efficient.</p>
<p>See the table bellow for the breakdown of time (in seconds) taken for each major step of
the harness verification:</p>
<table><thead><tr><th>Stage</th><th>MIR Linker</th><th>Alternative 1</th></tr></thead><tbody>
<tr><td>compilation</td><td>22.2s</td><td>64.7s</td></tr>
<tr><td>goto-program generation</td><td>2.4s</td><td>90.7s</td></tr>
<tr><td>goto-program linking</td><td>0.8s</td><td>33.2s</td></tr>
<tr><td>code instrumentation</td><td>0.8s</td><td>33.1</td></tr>
<tr><td>verification</td><td>0.5s</td><td>8.5s</td></tr>
</tbody></table>
<p>It is possible that <code>goto-cc</code> time can be improved, but this would also require further experimentation and
expertise that we don't have today.</p>
<p>Every option would require a custom sysroot to either be built or shipped with Kani.
The table below shows the size of the sysroot files for the alternative #2
(goto-program files) vs compiler artifacts (<code>*.rmeta</code> files)
files with <code>-Z always-encode-mir</code> for <code>x86_64-unknown-linux-gnu</code> (on Ubuntu 18.04).</p>
<table><thead><tr><th>File Type</th><th>Raw size</th><th>Compressed size</th></tr></thead><tbody>
<tr><td><code>symtab.json</code></td><td>950M</td><td>26M</td></tr>
<tr><td><code>symtab.out</code></td><td>84M</td><td>24M</td></tr>
<tr><td><code>*.rmeta</code></td><td>92M</td><td>25M</td></tr>
</tbody></table>
<p>These results were obtained by looking at the artifacts generated during the same experiment.</p>
<h2 id="open-questions-1"><a class="header" href="#open-questions-1">Open questions</a></h2>
<ul>
<li><del>Should we build or download the sysroot during <code>kani setup</code>?</del>
We include pre-built MIR artifacts for the <code>std</code> library.</li>
<li><del>What's the best way to enable support to run Kani in the entire <code>workspace</code>?</del>
We decided to run <code>cargo rustc</code> per package.</li>
<li><del>Should we codegen all static items no matter what?</del>
We only generate code for static items that are collected by the reachability analysis.
Static objects can only be initialized via constant function.
Thus, it shouldn't have any side effect.</li>
<li><del>What's the best way to handle <code>cargo kani --tests</code>?</del>
We are going to use the test profile and iterate over all the targets available in the crate:
<ul>
<li><code>cargo rustc --profile test -- --reachability=harnesses</code></li>
</ul>
</li>
</ul>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<ul>
<li>Split the goto-program into two or more items to optimize compilation result caching.
<ul>
<li>Dependencies: One model will include items from all the crate dependencies.
This model will likely be more stable and require fewer updates.</li>
<li>Target crate: The model for all items in the target crate.</li>
</ul>
</li>
<li>Do the analysis per-harness. This might be adequate once we have a mechanism to cache translations.</li>
<li>Add an option to include external functions to the analysis starting point in order to enable verification when
calls are made from <code>C</code> to <code>rust</code>.</li>
<li>Contribute the reachability analysis code back to upstream.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Function and method stubbing (<code>function-stubbing</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/1695">https://github.com/model-checking/kani/issues/1695</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1723">https://github.com/model-checking/kani/pull/1723</a> </li>
<li><strong>Status:</strong> Unstable</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/aaronbembenek-aws/kani/tree/mir_transform">https://github.com/aaronbembenek-aws/kani/tree/mir_transform</a></li>
</ul>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Allow users to specify that certain functions and methods should be replaced with mock functions (stubs) during verification.</p>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>In scope:</p>
<ul>
<li>Replacing function bodies</li>
<li>Replacing method bodies (which means that the new method body will be executed, whether the method is invoked directly or through a vtable)</li>
</ul>
<p>Out of scope:</p>
<ul>
<li>Replacing type definitions</li>
<li>Replacing macro definitions</li>
<li>Mocking traits</li>
<li>Mocking intrinsics</li>
</ul>
<h2 id="user-impact-2"><a class="header" href="#user-impact-2">User impact</a></h2>
<p>We anticipate that function/method stubbing will have a substantial positive impact on the usability of Kani:</p>
<ol>
<li>Users might need to stub functions/methods containing features that Kani does not support, such as inline assembly.</li>
<li>Users might need to stub functions/methods containing code that Kani supports in principle, but which in practice leads to bad verification performance (for example, if it contains deserialization code).</li>
<li>Users could use stubbing to perform compositional reasoning: prove the behavior of a function/method <code>f</code>, and then in other proofs---that call <code>f</code> indirectly---use a stub of <code>f</code> that mocks that behavior but is less complex.</li>
</ol>
<p>In all cases, stubbing would enable users to verify code that cannot currently be verified by Kani (or at least not within a reasonable resource bound).
Even without stubbing types, the ability to stub functions/methods can help provide verification-friendly abstractions for standard data structures.
For example, <a href="https://github.com/model-checking/kani/issues/1673">Issue 1673</a> suggests that some Kani proofs run more quickly if <code>Vec::new</code> is replaced with <code>Vec::with_capacity</code>; function stubbing would allow us to make this substitution everywhere in a codebase (and not just in the proof harness).</p>
<p>In what follows, we give an example of stubbing external code, using the annotations we propose in this RFC.
We are able to run this example on a modified version of Kani using a proof-of-concept MIR-to-MIR transformation implementing stubbing (the prototype does not support stub-related annotations; instead, it reads the stub mapping from a file).
This example stubs out a function that returns a random number.
This is the type of function that is commonly stubbed in other verification and program analysis projects, along with system calls, timer functions, logging calls, and deserialization methods---all of which we should be able to handle.
See the appendix at the end of this RFC for an extended example involving stubbing out a deserialization method.</p>
<h3 id="mocking-randomization"><a class="header" href="#mocking-randomization">Mocking randomization</a></h3>
<p>The crate <a href="https://crates.io/crates/rand"><code>rand</code></a> is widely used (150M downloads).
However, Kani cannot currently handle code that uses it (Kani users have run into this; see <a href="https://github.com/model-checking/kani/issues/1727">Issue 1727</a>.
Consider this example:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn random_cannot_be_zero() {
    assert_ne!(rand::random::&lt;u32&gt;(), 0);
}
</code></pre>
<p>For unwind values less than 2, Kani encounters an unwinding assertion error (there is a loop used to seed the random number generator); if we set an unwind value of 2, Kani fails to terminate within 5 minutes.</p>
<p>Using stubbing, we can specify that the function <code>rand::random</code> should be replaced with a mocked version:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(rand::random, mock_random)]
fn random_cannot_be_zero() {
    assert_ne!(rand::random::&lt;u32&gt;(), 0);
}
</code></pre>
<p>Under this substitution, Kani has a single check, which proves that the assertion can fail. Verification time is 0.02 seconds.</p>
<h2 id="user-experience-2"><a class="header" href="#user-experience-2">User experience</a></h2>
<p>This feature is currently limited to stubbing functions and methods.
We anticipate that the annotations we propose here could also be used for stubbing types, although the underlying technical approach might have to change.</p>
<p>Stubs will be specified per harness; that is, different harnesses can use different stubs.
This is one of the main design points.
Users might want to mock the behavior of a function within one proof harness, and then mock it a different way for another harness, or even use the original function definition.
It would be overly restrictive to impose the same stub definitions across all proof harnesses.
A good example of this is compositional reasoning: in some harnesses, we want to prove properties of a particular function (and so want to use its actual implementation), and in other harnesses we want to assume that that function has those properties.</p>
<p>Users will specify stubs by attaching the <code>#[kani::stub(&lt;original&gt;, &lt;replacement&gt;)]</code> attribute to each harness function.
The arguments <code>original</code> and <code>replacement</code> give the names of functions/methods.
They will be resolved using Rust's standard name resolution rules; this includes supporting imports like <code>use foo::bar as baz</code>, as well as imports of multiple versions of the same crate (in which case a name would resolve to a function/method in a particular version).
The attribute may be specified multiple times per harness, so that multiple (non-conflicting) stub pairings are supported.</p>
<p>For example, this code specifies that the function <code>mock_random</code> should be used in place of the function <code>rand::random</code> and the function <code>my_mod::bar</code> should be used in place of the function <code>my_mod::foo</code> for the harness <code>my_mod::my_harness</code>:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T {
    kani::any()
}

mod my_mod {

    fn foo(x: u32) -&gt; u32 { ... }

    fn bar(x: u32) -&gt; u32 { ... }

    #[cfg(kani)]
    #[kani::proof]
    #[kani::stub(rand::random, super::mock_random)]
    #[kani::stub(foo, bar)]
    fn my_harness() { ... }

}
</code></pre>
<p>We will support the stubbing of private functions and methods.
While this provides flexibility that we believe will be necessary in practice, it can also lead to brittle proofs: private functions/methods can change or disappear in even minor version upgrades (thanks to refactoring), and so proofs that depend on them might have a high maintenance burden.
In the documentation, we will discourage stubbing private functions/methods except if absolutely necessary.</p>
<h3 id="stub-sets"><a class="header" href="#stub-sets">Stub sets</a></h3>
<p>As a convenience, we will provide a macro <code>kani::stub_set</code> that allows users to specify sets of stubs that can be applied to multiple harnesses:</p>
<pre><code class="language-rust">kani::stub_set!(my_io_stubs(
    stub(std::fs::read, my_read),
    stub(std::fs::write, my_write),
));
</code></pre>
<p>When declaring a harness, users can use the <code>#[kani::use_stub_set(&lt;stub_set_name&gt;)]</code> attribute to apply the stub set:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
#[kani::use_stub_set(my_io_stubs)]
fn my_harness() { ... }
</code></pre>
<p>The name of the stub set will be resolved through the module path (i.e., they are not global symbols), using Rust's standard name resolution rules.</p>
<p>A similar mechanism can be used to aggregate stub sets:</p>
<pre><code class="language-rust">kani::stub_set!(all_my_stubs(
    use_stub_set(my_io_stubs),
    use_stub_set(my_other_stubs),
));
</code></pre>
<h3 id="error-conditions"><a class="header" href="#error-conditions">Error conditions</a></h3>
<p>Given a set of <code>original</code>-<code>replacement</code> pairs, Kani will exit with an error if</p>
<ol>
<li>a specified <code>original</code> function/method does not exist;</li>
<li>a specified <code>replacement</code> stub does not exist;</li>
<li>the user specifies conflicting stubs for the same harness (e.g., if the same <code>original</code> function is mapped to multiple <code>replacement</code> functions); or</li>
<li>the signature of the <code>replacement</code> stub is not compatible with the signature of the <code>original</code> function/method (see next section).</li>
</ol>
<h3 id="stub-compatibility-and-validation"><a class="header" href="#stub-compatibility-and-validation">Stub compatibility and validation</a></h3>
<p>When considering whether a function/method can be replaced with some given stub, we want to allow some measure of flexibility, while also ensuring that we can provide the user with useful feedback if stubbing results in misformed code.
We consider a stub and a function/method to be compatible if all the following conditions are met:</p>
<ul>
<li>They have the same number of parameters.</li>
<li>They have the same return type.</li>
<li>Each parameter in the stub has the same type as the corresponding parameter in the original function/method.</li>
<li>The stub must have the same number of generic parameters as the original function/method.
However, a generic parameter in the stub is allowed to have a different name than the corresponding parameter in the original function/method.
For example, the stub <code>bar&lt;A, B&gt;(x: A, y: B) -&gt; B</code> is considered to have a type compatible with the function <code>foo&lt;S, T&gt;(x: S, y: T) -&gt; T</code>.</li>
<li>The bounds for each type parameter don't need to match; however, all calls to the original function must also satisfy the bounds of the stub.</li>
</ul>
<p>The final point is the most subtle.
We do not require that a type parameter in the signature of the stub implements the same traits as the corresponding type parameter in the signature of the original function/method.
However, Kani will reject a stub if a trait mismatch leads to a situation where a statically dispatched call to a trait method cannot be resolved during monomorphization.
For example, this restriction rules out the following harness:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(_x: T) -&gt; bool {
    false
}

trait DoIt {
    fn do_it(&amp;self) -&gt; bool;
}

fn bar&lt;T: DoIt&gt;(x: T) -&gt; bool {
    x.do_it()
}

#[kani::proof]
#[kani::stub(foo, bar)]
fn harness() {
    assert!(foo(&quot;hello&quot;));
}
</code></pre>
<p>The call to the trait method <code>DoIt::do_it</code> is unresolvable in the stub <code>bar</code> when the type parameter <code>T</code> is instantiated with the type <code>&amp;str</code>.
On the other hand, our approach provides some flexibility, such as allowing our earlier example of mocking randomization: both <code>rand::random</code> and <code>my_random</code> have the type <code>() -&gt; T</code>, but in the first case <code>T</code> is restricted such that the type <code>Standard</code> implements <code>Distribution&lt;T&gt;</code>, whereas in the latter case <code>T</code> has to implement <code>kani::Arbitrary</code>.
This trait mismatch is allowed because at this call site <code>T</code> is instantiated with <code>u32</code>, which implements <code>kani::Arbitrary</code>.</p>
<h3 id="pedagogy"><a class="header" href="#pedagogy">Pedagogy</a></h3>
<p>To teach this feature, we will update the documentation with a section on function and method stubbing, including simple examples showing how stubbing can help Kani handle code that currently cannot be verified, as well as a guide to best practices for stubbing.</p>
<h2 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h2>
<p>We expect that this feature will require changes primarily to <code>kani-compiler</code>, with some less invasive changes to <code>kani-driver</code>.
We will modify <code>kani-compiler</code> to collects stub mapping information (from the harness attributes) before code generation.
Since stubs are specified on a per-harness basis, we need to generate multiple versions of code if all harnesses do not agree on their stub mappings; accordingly, we will update <code>kani-compiler</code> to generate multiple versions of code as appropriate. 
To do the stubbing, we will plug in a new MIR-to-MIR transformation that replaces the bodies of specified functions with their replacements.
This can be achieved via <code>rustc</code>'s query mechanism: if the user wants to replace <code>foo</code> with <code>bar</code>, then when the compiler requests the MIR for <code>foo</code>, we instead return the MIR for <code>bar</code>.
<code>kani-compiler</code> will also be responsible for checking for the error conditions previously enumerated.</p>
<p>We will also need to update the metadata that <code>kani-compiler</code> generates, so that it maps each harness to the generated code that has the right stub mapping for that harness (since there will be multiple versions of generated code).
The metadata will also list the stubs applied in each harness.
<code>kani-driver</code> will need to be updated to process this new type of metadata and invoke the correct generated code for each harness.
We can also update the results report to include the stubs that were used.</p>
<p>We anticipate that this design will evolve and be iterated upon.</p>
<h2 id="rationale-and-alternatives-user-experience"><a class="header" href="#rationale-and-alternatives-user-experience">Rationale and alternatives: user experience</a></h2>
<p>Stubbing is a <em>de facto</em> necessity for verification tools, and the lack of stubbing has a negative impact on the usability of Kani.</p>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<ul>
<li>Because stubs are specified by annotating the harness, the user is able to specify stubs for functions they do not have source access to (like library functions).
This contrasts with annotating the function to be replaced (such as with function contracts).</li>
<li>The current design provides the user with flexibility, as they can specify different sets of stubs to use for different harnesses.
This is important if users are trying to perform compositional reasoning using stubbing, since in some harnesses a function/method should be fully verified, in in other harnesses its behavior should be mocked.</li>
<li>The stub selections are located adjacent to the harness, which makes it easy to understand which replacements are going to happen for each harness.</li>
</ul>
<h3 id="risks-1"><a class="header" href="#risks-1">Risks</a></h3>
<ul>
<li>Users can always write stubs that do not correctly correspond to program behavior, and so a successful verification does not actually mean the program is bug-free.
This is similar to other specification bugs.
All the stubbing code will be available, so it is possible to inspect the assumptions it makes.</li>
</ul>
<h3 id="comparison-to-function-contracts"><a class="header" href="#comparison-to-function-contracts">Comparison to function contracts</a></h3>
<ul>
<li>In many cases, stubs are more user-friendly than contracts.
With contracts, it is sometimes necessary to explicitly provide information that is automatically captured in Rust (such as which memory is written).
Furthermore, contract predicates constitute a DSL of their own that needs to be learned; using stubbing, we can stick to using just Rust.</li>
<li>Function contracts sometimes come with a mechanism for verifying that a function satisfies its contract (for example, <a href="http://www.cprover.org/cprover-manual/contracts/functions/">CBMC provides this</a>).
While we do not plan to provide such a feature, it is possible to emulate this by writing proof harnesses comparing the behavior of the original function and the stub.
Furthermore, our approach provides additional flexibility, as it is not always actually desirable for a stub to be an overapproximation of the function (e.g., we might want the stub to exhibit a certain behavior within a particular harness) or to have a consistent behavior across all harnesses.</li>
<li>The <a href="https://github.com/model-checking/kani/tree/features/function-contracts">currently proposed function contract mechanism</a> does not provide a way to specify contracts on external functions.
In principle, it would be possible to extend it to do so.
Doing so would require some additional UX design decisions (e.g., &quot;How do users specify this?&quot;); with stubbing there does not need to be a distinction between local and external functions.</li>
</ul>
<h3 id="alternative-1-annotate-stubbed-functions"><a class="header" href="#alternative-1-annotate-stubbed-functions">Alternative #1: Annotate stubbed functions</a></h3>
<p>In this alternative, users add an attribute <code>#[kani::stub_by(&lt;replacement&gt;)]</code> to the function that should be replaced.
This approach is similar to annotating a function with a contract specifying its behavior (the stub acts like a programmatic contract).
The major downside with this approach is that it would not be possible to stub external code. We see this as a likely use case that needs to be supported: users will want to replace <code>std</code> library functions or functions from arbitrary external crates.</p>
<h3 id="alternative-2-annotate-stubs"><a class="header" href="#alternative-2-annotate-stubs">Alternative #2: Annotate stubs</a></h3>
<p>In this alternative, users add an attribute <code>#[kani::stub_of(&lt;original&gt;)]</code> to the stub function itself, saying which function it replaces:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::stub_of(rand::random)]
fn mock_random&lt;T: kani::Arbitrary&gt;() -&gt; T { ... }
</code></pre>
<p>The downside is that this stub must be uniformly applied across all harnesses and the stub specifications might be spread out across multiple files.
It would also require an extra layer of indirection to use a function as a stub if the user does not have source code access to it.</p>
<h3 id="alternative-3-annotate-harnesses-and-stubs"><a class="header" href="#alternative-3-annotate-harnesses-and-stubs">Alternative #3: Annotate harnesses and stubs</a></h3>
<p>This alternative combines the proposed solution and Alternative #2.
Users annotate the stub (as in Alternative #2) and specify for each harness which stubs to use using an annotation <code>#[kani::use_stubs(&lt;stub&gt;+)]</code> placed above the harness.</p>
<p>This could be combined with modules, so that a module can be used to group stubs together, and then harnesses could pull in all the stubs in the module:</p>
<pre><code class="language-rust">#[cfg(kani)]
mod my_stubs {

  #[kani::stub_of(foo)]
  fn stub1() { ... }

  #[kani::stub_of(bar)]
  fn stub2() { ... }

}

#[cfg(kani)]
#[kani::proof]
#[kani::use_stubs(my_stubs)]
fn my_harness() { ... }
</code></pre>
<p>The benefit is that stubs are specified per harness, and (using modules) it might be possible to group stubs together.
The downside is that multiple annotations are required and the stub mappings themselves are remote from the harness (at the harness you would know what stub is being used, but not what it is replacing).
There are also several issues that would need to be resolved:</p>
<ul>
<li>How do you mock multiple functions with the same stub?
(Say harness A wants to use <code>stub1</code> to mock <code>foo</code>, and harness B wants to use <code>stub1</code> to mock <code>bar</code>.)</li>
<li>How do you combine stub sets defined via modules? Would you use the module hierarchy?</li>
<li>If you use modules to define stub sets, are these modules regular modules or not?
In particular, given that modules can contain other constructs than functions, how should we interpret the extra stuff?</li>
</ul>
<h3 id="alternative-4-specify-stubs-in-a-file"><a class="header" href="#alternative-4-specify-stubs-in-a-file">Alternative #4: Specify stubs in a file</a></h3>
<p>One alternative would be to specify stubs in a file that is passed to <code>kani-driver</code> via a command line option.
Users would specify per-harness stub pairings in the file; JSON would be a possible format.
Using a file would eliminate the need for <code>kani-compiler</code> to do an extra pass to extract harness information from the Rust source code before doing code generation; the rest of the implementation would stay the same.
It would also allow the same harness to be run with different stub selections (by supplying a different file).
The disadvantage is that the stub selection is remote from the harness itself.</p>
<h2 id="rationale-and-alternatives-stubbing-mechanism"><a class="header" href="#rationale-and-alternatives-stubbing-mechanism">Rationale and alternatives: stubbing mechanism</a></h2>
<p>Our approach is based on a MIR-to-MIR transformation.
Some advantages are that it operates over a relatively simple intermediate representation and <code>rustc</code> has good support for plugging in MIR-to-MIR transformations, so it would not require any changes to <code>rustc</code> itself.
At this stage of the compiler, names have been fully resolved, and there is no problem with swapping in the body of a function defined in one crate for a function defined in another.
Another benefit is that it should be possible to extend the compiler to integrate <code>--concrete-playback</code> with the abstractions (although doing so is out of scope for the current proposal).</p>
<p>The major downside with the MIR-to-MIR transformation is that it does not appear to be possible to stub types at that stage (there is no way to change the definition of a type through the MIR).
Thus, our proposed approach will not be a fully general stubbing solution.
However, it is technically feasible and relatively clean, and provides benefits over having no stubbing at all (as can be seen in the examples in the first part of this document).</p>
<p>Furthermore, it could be used as part of a portfolio of stubbing approaches, where users stub local types using conditional compilation (see Alternative #1), and Kani provides a modified version of the standard library with verification-friendly versions of types like <code>std::vec::Vec</code>.</p>
<h3 id="alternative-1-conditional-compilation"><a class="header" href="#alternative-1-conditional-compilation">Alternative #1: Conditional compilation</a></h3>
<p>In this baseline alternative, we do not provide any stubbing mechanism at all.
Instead, users can effectively stub local code (functions, methods, and types) using conditional compilation.
For example, they could specify using <code>#[cfg(kani)]</code> to turn off the original definition and turn on the replacement definition when Kani is running, similarly to the ghost state approach taken in the <a href="https://model-checking.github.io/kani-verifier-blog/2022/08/17/using-the-kani-rust-verifier-on-tokio-bytes.html">Tokio Bytes proof</a>.</p>
<p>The disadvantage with this approach is that it does not provide any way to stub external code, which is one of the main motivations of our proposed approach.</p>
<h3 id="alternative-2-source-to-source-transformation"><a class="header" href="#alternative-2-source-to-source-transformation">Alternative #2: Source-to-source transformation</a></h3>
<p>In this alternative, we rewrite the source code before it even gets to the compiler.
The advantage with this approach is that it is very flexible, allowing us to stub functions, methods, and types, either by directly replacing them, or appending their replacements and injecting appropriate conditional compilation guards.</p>
<p>This approach entails less user effort than Alternative #1, but it has the same downside that it requires all source code to be available.
It also might be difficult to inject code in a way that names are correctly resolved (e.g., if the replacement code comes from a different crate).
Also, source code is difficult to work with (e.g., unexpanded macros).</p>
<p>On the last two points, we might be able to take advantage of an existing source analysis platform like <code>rust-analyzer</code> (which has facilities like structural search replace), but this would add more (potentially fragile) dependencies to Kani.</p>
<h3 id="alternative-3-ast-to-ast-or-hir-to-hir-transformation"><a class="header" href="#alternative-3-ast-to-ast-or-hir-to-hir-transformation">Alternative #3: AST-to-AST or HIR-to-HIR transformation</a></h3>
<p>In this alternative, we implement stubbing by rewriting the <a href="https://rustc-dev-guide.rust-lang.org/syntax-intro.html">AST</a> or <a href="https://rustc-dev-guide.rust-lang.org/hir.html">High-Level IR (HIR)</a> of the program.
The HIR is a more compiler-friendly version of the AST; it is what is used for type checking.
To swap out a function, method, or type at this level, it looks like it would be necessary to add another pass to <code>rustc</code> that takes the initial AST/HIR and produces a new AST/HIR with the appropriate replacements.</p>
<p>The advantage with this approach is, like source transformations, it would be very flexible.
The downside is that it would require modifying <code>rustc</code> (as far as we know, there is not an API for plugging in a new AST/HIR pass), and would also require performing the transformations at a very syntactic level: although the AST/HIR would likely be easier to work with than source code directly, it is still very close to the source code and not very abstract.
Furthermore, provided we supported stubbing across crate boundaries, it seems like we would run into a sequencing issue: if we were trying to stub a function in a dependency, we might not know until after we have compiled that dependency that we need to modify its AST/HIR; furthermore, even if we were aware of this, the replacement AST/HIR code would not be available at that time (the AST/HIR is usually just constructed for the crate currently being compiled).</p>
<h2 id="open-questions-2"><a class="header" href="#open-questions-2">Open questions</a></h2>
<ul>
<li>Would there ever be the need to stub a particular monomorphization of a function, as opposed to the polymorphic function?</li>
<li>How can the user verify that the stub is an abstraction of the original function/method?
Sometimes it might be important that a stub is an overapproximation or underapproximation of the replaced code. 
One possibility would be writing proofs about stubs (possibly relating their behavior to that of the code they are replacing).</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Our proposed approach will not work with <code>--concrete-playback</code> (for now).</li>
<li>We are only able to apply abstractions to some dependencies if the user enables the MIR linker.</li>
</ul>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<ul>
<li>
<p>It would increase the utility of stubbing if we supported stubs for types.
The source code annotations could likely stay the same, although the underlying technical approach performing these substitutions might be significantly more complex.</p>
</li>
<li>
<p>It would probably make sense to provide a library of common stubs for users, since many applications might want to stub the same functions and mock the same behaviors (e.g., <code>rand::random</code> can be replaced with a function returning <code>kani::any</code>).</p>
</li>
<li>
<p>We could provide special classes of stubs that are likely to come up in practice:</p>
<ul>
<li><code>unreachable</code>: assert the function is unreachable.</li>
<li><code>havoc_locals</code>: return nondeterministic values and assign nondeterministic values to all mutable arguments.</li>
<li><code>havoc</code>: similar to <code>havoc_locals</code> but also assign nondeterministic values to all mutable global variables.</li>
<li><code>uninterpret</code>: treat function as an uninterpreted function.</li>
</ul>
</li>
<li>
<p>How can we provide a good user experience for accessing private fields of <code>self</code> in methods?
It is possible to do so using <code>std::mem::transmute</code> (see below); this is clunky and error-prone, and it would be good to provide better support for users.</p>
<pre><code class="language-rust">struct Foo {
    x: u32,
}

impl Foo {
    pub fn m(&amp;self) -&gt; u32 {
        0
    }
}

struct MockFoo {
    pub x: u32,
}

fn mock_m(foo: &amp;Foo) {
    let mock: &amp;MockFoo = unsafe { std::mem::transmute(foo) };
    return mock.x;
}

#[cfg(kani)]
#[kani::proof]
#[kani::stub(Foo::m, mock_m)]
fn my_harness() { ... }
</code></pre>
</li>
</ul>
<h2 id="appendix-an-extended-example"><a class="header" href="#appendix-an-extended-example">Appendix: an extended example</a></h2>
<p>In this example, we mock a <a href="https://crates.io/crates/serde_json">serde_json</a> (96M downloads) deserialization method so that we can prove a property about the following <a href="https://github.com/firecracker-microvm/firecracker/blob/01eba51ded2f5439da91a2d73280f579651b067c/src/api_server/src/request/vsock.rs#L11">Firecracker function</a> that parses a configuration from some raw data:</p>
<pre><code class="language-rust">fn parse_put_vsock(body: &amp;Body) -&gt; Result&lt;ParsedRequest, Error&gt; {
    METRICS.put_api_requests.vsock_count.inc();
    let vsock_cfg = serde_json::from_slice::&lt;VsockDeviceConfig&gt;(body.raw()).map_err(|err| {
        METRICS.put_api_requests.vsock_fails.inc();
        err
    })?;

    // Check for the presence of deprecated `vsock_id` field.
    let mut deprecation_message = None;
    if vsock_cfg.vsock_id.is_some() {
        // vsock_id field in request is deprecated.
        METRICS.deprecated_api.deprecated_http_api_calls.inc();
        deprecation_message = Some(&quot;PUT /vsock: vsock_id field is deprecated.&quot;);
    }

    // Construct the `ParsedRequest` object.
    let mut parsed_req = ParsedRequest::new_sync(VmmAction::SetVsockDevice(vsock_cfg));
    // If `vsock_id` was present, set the deprecation message in `parsing_info`.
    if let Some(msg) = deprecation_message {
        parsed_req.parsing_info().append_deprecation_message(msg);
    }

    Ok(parsed_req)
}
</code></pre>
<p>We manually mocked some of the Firecracker types with simpler versions to reduce the number of dependencies we had to pull in (e.g., we removed some enum variants, unused struct fields).
With these changes, we were able to prove that the configuration data has a vsock ID if and only if the parsing metadata includes a deprecation message: </p>
<pre><code class="language-rust">#[cfg(kani)]
fn get_vsock_device_config(action: RequestAction) -&gt; Option&lt;VsockDeviceConfig&gt; {
    match action {
        RequestAction::Sync(vmm_action) =&gt; match *vmm_action {
            VmmAction::SetVsockDevice(dev) =&gt; Some(dev),
            _ =&gt; None,
        },
        _ =&gt; None,
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(2)]
#[kani::stub(serde_json::deserialize_slice, mock_deserialize)]
fn test_deprecation_vsock_id_consistent() {
    // We are going to mock the parsing of this body, so might as well use an empty one.
    let body: Vec&lt;u8&gt; = Vec::new();
    if let Ok(res) = parse_put_vsock(&amp;Body::new(body)) {
        let (action, mut parsing_info) = res.into_parts();
        let config = get_vsock_device_config(action).unwrap();
        assert_eq!(
            config.vsock_id.is_some(),
            parsing_info.take_deprecation_message().is_some()
        );
    }
}
</code></pre>
<p>Crucially, we did this by stubbing out <code>serde_json::from_slice</code> and replacing it with our mock version below, which ignores its input and creates a &quot;symbolic&quot; configuration struct:</p>
<pre><code class="language-rust">#[cfg(kani)]
fn symbolic_string(len: usize) -&gt; String {
    let mut v: Vec&lt;u8&gt; = Vec::with_capacity(len);
    for _ in 0..len {
        v.push(kani::any());
    }
    unsafe { String::from_utf8_unchecked(v) }
}

#[cfg(kani)]
fn mock_deserialize(_data: &amp;[u8]) -&gt; serde_json::Result&lt;VsockDeviceConfig&gt; {
    const STR_LEN: usize = 1;
    let vsock_id = if kani::any() {
        None
    } else {
        Some(symbolic_string(STR_LEN))
    };
    let guest_cid = kani::any();
    let uds_path = symbolic_string(STR_LEN);
    let config = VsockDeviceConfig {
        vsock_id,
        guest_cid,
        uds_path,
    };
    Ok(config)
}
</code></pre>
<p>The proof takes 170 seconds to complete (using Kissat as the backend SAT solver for CBMC).</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Cover statement (<code>cover-statement</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/696">https://github.com/model-checking/kani/issues/696</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1906">https://github.com/model-checking/kani/pull/1906</a></li>
<li><strong>Status:</strong> Stable</li>
<li><strong>Version:</strong> 2</li>
</ul>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>A new Kani API that allows users to check that a certain condition can occur at a specific location in the code.</p>
<h2 id="user-impact-3"><a class="header" href="#user-impact-3">User Impact</a></h2>
<p>Users typically want to gain confidence that a proof checks what it is supposed to check, i.e. that properties are not passing vacuously due to an over-constrained environment.</p>
<p>A new Kani macro, <code>cover</code> will be created that can be used for checking that a certain condition <em>can</em> occur at a specific location in the code.
The purpose of the macro is to verify, for example, that assumptions are not ruling out those conditions, e.g.:</p>
<pre><code class="language-rust">let mut v: Vec&lt;i32&gt; = Vec::new();
let len: usize = kani::any();
kani::assume(len &lt; 5);
for _i in 0..len {
    v.push(kani::any());
}
// make sure we can get a vector of length 5
kani::cover!(v.len() == 5);
</code></pre>
<p>This is typically used to ensure that verified checks are not passing <em>vacuously</em>, e.g. due to overconstrained pre-conditions.</p>
<p>The special case of verifying that a certain line of code is reachable can be achieved using <code>kani::cover!()</code> (which is equivalent to <code>cover!(true)</code>), e.g.</p>
<pre><code class="language-rust">match x {
    val_1 =&gt; ...,
    val_2 =&gt; ...,
    ...
    val_i =&gt; kani::cover!(), // verify that `x` can take the value `val_i`
}
</code></pre>
<p>Similar to Rust's <code>assert</code> macro, a custom message can be specified, e.g.</p>
<pre><code class="language-rust">kani::cover!(x &gt; y, &quot;x can be greater than y&quot;);
</code></pre>
<h2 id="user-experience-3"><a class="header" href="#user-experience-3">User Experience</a></h2>
<p>The <code>cover</code> macro instructs Kani to find <em>at least one</em> possible execution that satisfies the specified condition at that line of code.  If no such execution is possible, the check is reported as <em>unsatisfiable</em>.</p>
<p>Each cover statement will be reported as a check whose description is <code>cover condition: cond</code> and whose status is:</p>
<ul>
<li><code>SATISFIED</code> (green): if Kani found an execution that satisfies the condition.</li>
<li><code>UNSATISFIABLE</code> (yellow): if Kani proved that the condition cannot be satisfied.</li>
<li><code>UNREACHABLE</code> (yellow): if Kani proved that the cover statement itself cannot be reached.</li>
</ul>
<p>For example, for the following <code>cover</code> statement:</p>
<pre><code class="language-rust">kani::cover!(a == 0);
</code></pre>
<p>An example result is:</p>
<pre><code>Check 2: main.cover.2
         - Status: SATISFIED
         - Description: &quot;cover condition: a == 0&quot;
         - Location: foo.rs:9:5 in function main
</code></pre>
<h3 id="impact-on-overall-verification-status"><a class="header" href="#impact-on-overall-verification-status">Impact on Overall Verification Status</a></h3>
<p>By default, unsatisfiable and unreachable <code>cover</code> checks will not impact verification success or failure.
This is to avoid getting verification failure for harnesses for which a <code>cover</code> check is not relevant.
For example, on the following program, verification should not fail for <code>another_harness_that_doesnt_call_foo</code> because the <code>cover</code> statement in <code>foo</code> is unreachable from it.</p>
<pre><code class="language-rust">[kani::proof]
fn a_harness_that_calls_foo() {
    foo();
}

#[kani::proof]
fn another_harness_that_doesnt_call_foo() {
    // ...
}

fn foo() {
    kani::cover!( /* some condition */);
}
</code></pre>
<p>The <code>--fail-uncoverable</code> option will allow users to fail the verification if a cover property is unsatisfiable or unreachable.
This option will be integrated within the framework of <a href="https://model-checking.github.io/kani/rfc/rfcs/0007-global-conditions.html">Global Conditions</a>, which is used to define properties that depend on other properties.</p>
<p>Using the <code>--fail-uncoverable</code> option will enable the global condition with name <code>fail_uncoverable</code>.
Following the format for global conditions, the outcome will be one of the following:</p>
<ol>
<li><code> - fail_uncoverable: FAILURE (expected all cover statements to be satisfied, but at least one was not)</code></li>
<li><code> - fail_uncoverable: SUCCESS (all cover statements were satisfied as expected)</code></li>
</ol>
<p>Note that the criteria to achieve a <code>SUCCESS</code> status depends on all properties of the <code>&quot;cover&quot;</code> class having a <code>SATISFIED</code> status.
Otherwise, we return a <code>FAILURE</code> status.</p>
<h3 id="inclusion-in-the-verification-summary"><a class="header" href="#inclusion-in-the-verification-summary">Inclusion in the Verification Summary</a></h3>
<p>Cover checks will be reported separately in the verification summary, e.g.</p>
<pre><code>SUMMARY:
 ** 1 of 206 failed (2 unreachable)
 Failed Checks: assertion failed: x[0] == x[1]

 ** 30 of 35 cover statements satisfied (1 unreachable) &lt;--- NEW
</code></pre>
<p>In this example, 5 of the 35 cover statements were found to be unsatisfiable, and one of those 5 is additionally unreachable.</p>
<h3 id="interaction-with-other-checks"><a class="header" href="#interaction-with-other-checks">Interaction with Other Checks</a></h3>
<p>If one or more unwinding assertions fail or an unsupported construct is found to be reachable (which indicate an incomplete path exploration), and Kani found the condition to be unsatisfiable or unreachable, the result will be reported as <code>UNDETERMINED</code>.</p>
<h2 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed Design</a></h2>
<p>The implementation will touch the following components:</p>
<ul>
<li>Kani library: The <code>cover</code> macro will be added there along with a <code>cover</code> function with a <code>rustc_diagnostic_item</code></li>
<li><code>kani-compiler</code>: The <code>cover</code> function will be handled via a hook and codegen as two assertions (<code>cover(cond)</code> will be codegen as <code>__CPROVER_assert(false); __CPROVER_assert(!cond)</code>).
The purpose of the <code>__CPROVER_assert(false)</code> is to determine whether the <code>cover</code> statement is reachable.
If it is, the second <code>__CPROVER_assert(!cond)</code> indicates whether the condition is satisfiable or not.</li>
<li><code>kani-driver</code>: The CBMC output parser will extract cover properties through their property class, and their result will be set based on the result of the two assertions:
<ul>
<li>The first (reachability) assertion is proven: report as <code>FAILURE (UNREACHABLE)</code></li>
<li>The first assertion fails, and the second one is proven: report as <code>FAILURE</code> to indicate that the condition is unsatisfiable</li>
<li>The first assertion fails, and the second one fails: report as <code>SUCCESS</code> to indicate that the condition is satisfiable</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h2>
<ul>
<li>
<p>What are the pros and cons of this design?
CBMC has its own <a href="https://diffblue.github.io/cbmc//cprover__builtin__headers_8h.html#a44f072b21e93cb0f72adcccc9005f307">cover API (<code>__CPROVER_cover</code>)</a>, for which <code>SUCCESS</code> is reported if an execution is found, and <code>FAILURE</code> is reported otherwise.
However, using this API currently requires running CBMC in a separate <a href="https://github.com/diffblue/cbmc/issues/6613">&quot;cover&quot; mode</a>.
Having to run CBMC in that mode would complicate the Kani driver as it will have to perform two CBMC runs, and then combine their results into a single report.
Thus, the advantage of the proposed design is that it keeps the Kani driver simple.
In addition, the proposed solution does not depend on a feature in the backend, and thus will continue to work if we were to integrate a different backend.</p>
</li>
<li>
<p>What is the impact of not doing this?
The current workaround to accomplish the same effect of verifying that a condition can be covered is to use <code>assert!(!cond)</code>.
However, if the condition can indeed be covered, verification would fail due to the failure of the assertion.</p>
</li>
</ul>
<h2 id="open-questions-3"><a class="header" href="#open-questions-3">Open questions</a></h2>
<ul>
<li>~Should we allow format arguments in the macro, e.g. <code>kani::cover!(x &gt; y, &quot;{} can be greater than {}&quot;, x, y)</code>?
Users may expect this to be supported since the macro looks similar to the <code>assert</code> macro, but Kani doesn't include the formatted string in the message description, since it's not available at compile time.~
<ul>
<li>For now, this macro will not accept format arguments, since this
is not well handled by Kani.
This is an extesion to this API that can be easily added later on if Kani
ever supports runtime formatting.</li>
</ul>
</li>
</ul>
<h2 id="other-considerations"><a class="header" href="#other-considerations">Other Considerations</a></h2>
<p>We need to make sure the concrete playback feature can be used with <code>cover</code> statements that were found to be coverable.</p>
<h2 id="future-possibilities-2"><a class="header" href="#future-possibilities-2">Future possibilities</a></h2>
<p>The new cover API subsumes the current <code>kani::expect_fail</code> function.
Once it's implemented, we should be able to get rid of <code>expect_fail</code>, and all the related code in <code>compiletest</code> that handles the <code>EXPECTED FAILURE</code> message in a special manner.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Loop-contract synthesis (<code>loop-contract-synthesis</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2214">https://github.com/model-checking/kani/issues/2214</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2215">https://github.com/model-checking/kani/pull/2215</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 0</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/qinheping/kani/tree/kani-synthesizer">https://github.com/qinheping/kani/tree/kani-synthesizer</a></li>
</ul>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>A new option that allows users to verify programs without unwinding loops by synthesizing loop contracts for those loops.</p>
<h2 id="user-impact-4"><a class="header" href="#user-impact-4">User Impact</a></h2>
<p>Currently Kani does not support verification on programs with unbounded control flow (e.g. loops with dynamic bounds).
Kani unrolls all unbounded loops until a global threshold (unwinding number) specified by the user and then verifies this unrolled program, which limits the set of programs it can verify.</p>
<p>A new Kani flag <code>--synthesize-loop-contracts</code> will be created that can be used to enable the goto-level loop-contract synthesizer <code>goto-synthesizer</code>.
The idea of <a href="https://arxiv.org/pdf/2010.05812.pdf">loop contracts</a> is, instead of unwinding loops, we abstract those loops as non-loop structures that can cover arbitrary iterations of the loops.
The loop contract synthesizer, when enabled, will attempt to synthesize loop contracts for all loops.
CBMC can then apply the synthesized loop contracts and verify the program without unwinding any loop.
So, the synthesizer will help to verify the programs that require Kani to unwind loops for a very large number of times to cover all iterations.</p>
<p>For example, the number of executed iterations of the loop in the following harness is dynamically bounded by an unbounded variable <code>y</code> <sup class="footnote-reference"><a href="#1">1</a></sup>.
Only an unwinding value of <code>i32::MAX</code> can guarantee to cover all iterations of the loop, and hence satisfy the unwinding assertions.
Unwinding the loop an <code>i32::MAX</code> number of times will result in a too large goto program to be verified by CBMC.</p>
<pre><code class="language-rust">#[kani::proof]
fn main() {
    let mut y: i32 = kani::any_where(|i| *i &gt; 0);

    while y &gt; 0 {
        y = y - 1;
    }
    assert!(y == 0);
}
</code></pre>
<p>With the loop-contract synthesizer, Kani can synthesize the loop invariant <code>y &gt;= 0</code>, with which it can prove the post-condition <code>y == 0</code> without unwinding the loop.</p>
<p>Also, loop contracts could improve Kani’s verification time since all loops will be abstracted to a single iteration, as opposed to being unwound a large number of iterations.
For example, we can easily find out that the following loop is bounded by an unwinding value of <code>5000</code>.
Kani can verify the program in a few minutes by unwinding the loop 5000 times.
With loop contracts, we only need to verify the single abstract iteration of the loop, which leads to a smaller query.
As a result, Kani with the synthesizer can verify the program in a few seconds.</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(5000)]
fn main() {
    let mut y: i32 = 5000;

    while y &gt; 0 {
        y = y - 1;
    }
    assert!(y == 0);
}
</code></pre>
<p>The <code>goto-synthesizer</code> is an <a href="https://www.cis.upenn.edu/%7Ealur/SyGuS13.pdf">enumeration-based synthesizer</a>.
It enumerates candidate invariants from a pre-designed search space described by a given regular tree grammar and verifies if the candidate is an inductive invariant.
Therefore it has the following limitations:</p>
<ol>
<li>the search space is not complete, so it may fail to find a working candidate. The current search space consists of only conjunctions of linear inequalities built from the variables in the loop, which is not expressive enough to capture all loop invariants.
For example, the loop invariant <code>a[i] == 0</code> contains an array access and cannot be captured by the current search space.
However, we can easily extend the search space to include more complex expressions with the cost of an exponential increase of the running time of the synthesizer.</li>
<li>the synthesizer suffers from the same limitation as the loop contract verification in CBMC. For example, it does not support unbounded quantifiers, or dynamic allocations in the loop body.</li>
</ol>
<h2 id="user-experience-4"><a class="header" href="#user-experience-4">User Experience</a></h2>
<p>Users will be able to use the new command-line flag <code>--synthesize-loop-contracts</code> to run the synthesizer, which will attempt to synthesize loop contracts, and verify programs with the synthesized loop contracts.</p>
<h4 id="limit-resource-used-by-synthesizer-for-termination"><a class="header" href="#limit-resource-used-by-synthesizer-for-termination">Limit Resource Used by Synthesizer for Termination</a></h4>
<p>Without a resource limit, an enumerative synthesizer may run forever to exhaust a search space consisting of an infinite number of candidates, especially when there is no solution in the search space.
So, for the guarantee of termination, we provide users options: <code>--limit-synthesis-time T</code> to limit the running time of the synthesizer to be less than <code>T</code> seconds.</p>
<h4 id="output-of-kani-when-the-synthesizer-is-enabled"><a class="header" href="#output-of-kani-when-the-synthesizer-is-enabled">Output of Kani when the Synthesizer is Enabled</a></h4>
<p>When the flag <code>--synthesize-loop-contracts</code> is provided, Kani will report different result for different cases</p>
<ol>
<li>When there exists some loop invariant in the candidate space with which all assertions can be proved, Kani will synthesize the loop contracts, verify the program with the synthesized loop contracts, and report verification SUCCESS;</li>
<li>When no working candidate has been found in the search space within the specified limits, Kani will report the verification result with the best-effort-synthesized loop contracts.
Note that as loop contracts are over-approximations of the loop, the violated assertions in this case may be spurious.
So we will report the violated assertions as <code>UNDETERMINED</code> instead of <code>FAILED</code>.</li>
</ol>
<p>A question about how do we print the synthesized loop contracts when users request is discussed in <strong>Open question</strong>.</p>
<h2 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed Design</a></h2>
<p>The synthesizer <code>goto-synthesizer</code> is implemented in the repository of <code>CBMC</code>, takes as input a goto binary, and outputs a new goto binary with the synthesized loop contracts applied.
Currently, Kani invokes <code>goto-instrument</code> to instrument the goto binary <code>main.goto</code> into a new goto binary <code>main_instrumented.goto</code>, and then invokes <code>cbmc</code> on <code>main_instrumented.goto</code> to get the verification result.
The synthesis will happen between calling <code>goto-instrument</code> and calling <code>cbmc</code>.
That is, we invoke <code>goto-synthesizer</code> on <code>main_instrumented.goto</code> to produce a new goto binary <code>main_synthesized.goto</code>, and then call <code>cbmc</code> on <code>main_synthesized.goto</code> instead. </p>
<p>When invoking <code>goto-synthesizer</code>, we pass the following parameters to it with the flags built in <code>goto-synthesizer</code>:</p>
<ul>
<li>the resource limit of the synthesis;</li>
<li>the solver options to specify what SAT solver we use to verify invariant candidates.</li>
</ul>
<p>The enumerator used in the synthesizer enumerates candidates from the language of the following grammar template.</p>
<pre><code>NT_Bool -&gt; NT_Bool &amp;&amp; NT_Bool | NT_int == NT_int 
            | NT_int &lt;= NT_int | NT_int &lt; NT_int 
            | SAME_OBJECT(terminals_ptr, terminals_ptr)
            
NT_int  -&gt; NT_int + NT_int | terminals_int | LOOP_ENTRY(terminals_int)
            | POINTER_OFFSET(terminals_ptr) | OBJECT_SIZE(terminals_ptr)
            | POINTER_OFFSET(LOOP_ENTRY(terminals_ptr)) | 1
</code></pre>
<p>where <code>terminals_ptr</code> are all pointer variables in the scope, and <code>terminal_int</code> are all integer variables in the scope.
For every candidate invariant, <code>goto-synthesizer</code> applies it to the GOTO program and runs CBMC to verify the program.</p>
<ul>
<li>If all checks in the program pass, <code>goto-synthesizer</code> returns it as a solution.</li>
<li>If the inductive checks pass but some of the other checks fail, the candidate invariant is inductive. 
We keep it as an inductive invariant clause.</li>
<li>If the inductive checks fail, we discard the candidate.
When the resource limit is reached, <code>goto-synthesizer</code> returns the conjunction of all inductive clauses as the best-effort-synthesized loop contracts.</li>
</ul>
<p>We use the following example to illustrate how the synthesizer works.</p>
<pre><code class="language-rust">#[kani::proof]
fn main() {
    let mut y: i32 = kani::any_where(|i| *i &gt; 0);

    while y &gt; 0 {
        y = y - 1;
    }
    assert!(y == 0);
}
</code></pre>
<p>As there is only one variable <code>y</code> in the scope, the grammar template above will be instantiated to the following grammar</p>
<pre><code>NT_Bool -&gt; NT_Bool &amp;&amp; NT_Bool | NT_int == NT_int 
            | NT_int &lt;= NT_int | NT_int &lt; NT_int 
NT_int  -&gt; NT_int + NT_int | y | LOOP_ENTRY(y) | 1
</code></pre>
<p>The synthesizer will enumerate candidates derived from <code>NT_Bool</code> in the following order.</p>
<pre><code>y == y
y == LOOP_ENTRY(y)
y == 1
...
1 &lt;= y + 1
...
</code></pre>
<p>The synthesizer then verifies with CBMC if the candidate is an inductive invariant that can be used to prove the post-condition <code>y == 0</code>.
For example, the candidate <code>y == y</code> is verified to be an inductive invariant, but cannot be used to prove the post-condition <code>y == 0</code>.
The candidate <code>y == 1</code> is not inductive.
The synthesizer rejects all candidates until it finds the candidate <code>1 &lt;= y + 1</code>, which can be simplified to <code>y &gt;= 0</code>.
<code>y &gt;= 0</code> is an inductive invariant that can be used to prove the post-condition.
So the synthesizer will return <code>y &gt;= 0</code> and apply it to the goto model to get <code>main_synthesized.goto</code>.</p>
<p>For assign clauses, the synthesizer will first use alias analysis to determine an initial set of assign targets.
During the following iteration, if any assignable-check is violated, the synthesizer will extract the assign target from the violated check.</p>
<p>Then Kani will call <code>cbmc</code> on <code>main_synthesized.goto</code> to verify the program with the synthesized loop contracts. </p>
<h2 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h2>
<ul>
<li>Different candidate space.
The candidate grammar introduced above now only contains a restricted set of operators, which works well for array-manipulating programs with only pointer-checks instrumented by <code>goto-instrument</code>, but probably not enough for other user-written checks.
We may want to include array-indexing, pointer-dereference, or other arithmetic operators in the candidate grammar for synthesizing a larger set of loop invariants.
However, there is a trade-off between the size of candidate we enumerate and the running time of the enumeration.
We will collect more data to decide what operators we should include in the candidate grammar.
Once we decide more kinds of candidate grammars, we will provide users options to choose which candidate grammar they want to use.</li>
</ul>
<h2 id="open-questions-4"><a class="header" href="#open-questions-4">Open questions</a></h2>
<p><strong>How does the synthesizer work with unwinding numbers?</strong>
There may exist some loops for which the synthesizer cannot find loop contracts, but some small unwinding numbers are enough to cover all executions of the loops.
In this case, we may want to unwind some loops in the program while synthesizing loop contracts for other loops.
It requires us to have a way to identify and specify which loops we want to unwind. </p>
<p>In C programs, we identify loops by the <strong>loop ID</strong>, which is a pair <code>(function name, loop number)</code>.
However, in Rust programs, loops are usually in library functions such as <code>Iterator::for_each</code>.
And a library function may be called from different places in the program.
We may want to unwind the loop in some calls but not in other calls.</p>
<p><strong>How do we output the synthesized loop contracts?</strong>
To better earn users' trust, we want to be able to report what loop contracts we synthesized and used to verify the given programs.
Now <code>goto-synthesizer</code> can dump the synthesized loop contracts into a JSON file.
Here is an example of the dumped loop contracts.
It contains the location of source files of the loops, the synthesized invariant clauses and assign clauses for loops identified by loop numbers.</p>
<pre><code class="language-json">{
    &quot;sources&quot;: [ &quot;/Users/qinhh/Repos/playground/kani/synthesis/base_2/test.rs&quot; ],
    &quot;functions&quot;: [
      {
        &quot;main&quot;: [ &quot;loop 1 invariant y &gt;= 0&quot;, 
                  &quot;loop 1 assigns var_9,var_10,var_11,x,y,var_12&quot; ]
      }
    ],
    &quot;output&quot;: &quot;stdout&quot;
}
</code></pre>
<p>There are two challenges here if we want to also dump synthesized loop contracts in Kani.</p>
<ol>
<li>We need to have a consistent way to identify loops.</li>
<li>We need to dump loop invariants in <code>rust</code> instead of <code>c</code>.</li>
<li>There are many auxiliary variables we added in Kani-compiled GOTO, such as <code>var_9</code>, <code>var_10</code>, <code>var_11</code>, and <code>var_12</code> in the above JSON file.
We need to translate them back to the original variables they represent.</li>
</ol>
<h2 id="future-possibilities-3"><a class="header" href="#future-possibilities-3">Future possibilities</a></h2>
<p><strong>User-provided loop contracts.</strong>
If we have a good answer for how to identify loops and dump synthesized loop contracts, we could probably also allow users to provide the loop contracts they wrote to Kani, and verify programs with user-provided loop contracts.</p>
<p>When users want to unwind some loops, we can also introduce macros to enable/disable unwinding for certain block of code.</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(10)]
fn check() {
    // unwinding starts as enabled, so all loops in this code block will be unwound to 10
    #[kani::disable_unwinding]
    // unwinding is disabled for all loops in this block of code
    #[kani::enable_unwinding]
    // it is enabled in this block of code until the end of the program
}
</code></pre>
<p><strong>Invariant caching.</strong>
The loop invariant could be broken when users modify their code.
However, we could probably cache previously working loop invariants and attempt to reuse them when users modify their code.
Even if the cached loop invariants are not enough to prove the post-condition, they could still be used as a starting point for the synthesizer to find new loop invariants.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>We say an integer variable is unbounded if there is no other bound on its value besides the width of its bit-vector representation. </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> The <code>kani::should_panic</code> attribute (<code>should-panic-attr</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/600">https://github.com/model-checking/kani/issues/600</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2272">https://github.com/model-checking/kani/pull/2272</a></li>
<li><strong>Status:</strong> Unstable</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong></li>
</ul>
<ul>
<li>Version 0: <a href="https://github.com/model-checking/kani/pull/2315">https://github.com/model-checking/kani/pull/2315</a></li>
<li>Version 1: <a href="https://github.com/model-checking/kani/pull/2532">https://github.com/model-checking/kani/pull/2532</a></li>
</ul>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Users may want to express that a verification harness should panic.
This RFC proposes a new harness attribute <code>#[kani::should_panic]</code> that informs Kani about this expectation.</p>
<h2 id="user-impact-5"><a class="header" href="#user-impact-5">User Impact</a></h2>
<p>Users may want to express that a verification harness should panic.
In general, a user adding such a harness wants to demonstrate that the verification fails because a panic is reachable from the harness.</p>
<p>Let's refer to this concept as <em>negative verification</em>,
so the relation with <a href="https://en.wikipedia.org/wiki/Negative_testing">negative testing</a> becomes clearer.
Negative testing can be exercised in Rust unit tests using <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics">the <code>#[should_panic]</code> attribute</a>.
If the <code>#[should_panic]</code> attribute is added to a test, <code>cargo test</code> will check that the execution of the test results in a panic.
This capability doesn't exist in Kani at the moment, but it would be useful for the same reasons
(e.g., to show that invalid inputs result in verification failures, or increase the overall verification coverage).</p>
<p>We propose an attribute that allows users to exercise negative verification in Kani.</p>
<p>We also acknowledge that, in other cases, users may want to express more granular expectations for their harnesses.
For example, a user may want to specify that a given check is unreachable from the harness.
An ergonomic mechanism for informing Kani about such expectations is likely to require other improvements in Kani (a comprehensive classification for checks reported by Kani, a language to describe expectations for checks and cover statements, and general output improvements).
Moving forward, we consider that such a mechanism and this proposal solve different problems, so they don't need to be discussed together.
This is further discussed in the <a href="rfcs/0005-should-panic-attr.html#rationale-and-alternatives">rationale and alternatives</a> and <a href="rfcs/0005-should-panic-attr.html#future-possibilities">future possibilities</a> sections.</p>
<h2 id="user-experience-5"><a class="header" href="#user-experience-5">User Experience</a></h2>
<p>The scope of this functionality is <strong>limited to the overall verification result</strong>.
The <a href="rfcs/0005-should-panic-attr.html#rationale-and-alternatives">rationale section</a> discusses the granularity of failures, and how this attribute could be extended.</p>
<h3 id="single-harness"><a class="header" href="#single-harness">Single Harness</a></h3>
<p>Let's look at this code:</p>
<pre><code class="language-rust">struct Device {
    is_init: bool,
}

impl Device {
    fn new() -&gt; Self {
        Device { is_init: false }
    }

    fn init(&amp;mut self) {
        assert!(!self.is_init);
        self.is_init = true;
    }
}

#[kani::proof]
fn cannot_init_device_twice() {
    let mut device = Device::new();
    device.init();
    device.init();
}
</code></pre>
<p>This is what a negative harness may look like.
The user wants to verify that calling <code>device.init()</code> more than once should result in a panic.</p>
<blockquote>
<p><strong>NOTE</strong>: We could convert this into a Rust unit test and add the <code>#[should_panic]</code> attribute to it.
However, there are a few good reasons to have a verification-specific attribute that does the same:</p>
<ol>
<li>To ensure that other unexpected behaviors don't occur (e.g., overflows).</li>
<li>Because <code>#[should_panic]</code> cannot be used if the test harness contains calls to Kani's API.</li>
<li>To ensure that a panic still occurs after stubbing out code which is expected to panic.</li>
</ol>
</blockquote>
<p>Currently, this example produces a <code>VERIFICATION:- FAILED</code> result.
In addition, it will return a non-successful code.</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::should_panic]
fn cannot_init_device_twice() {
    let mut device = Device::new();
    device.init();
    device.init();
}
</code></pre>
<p>Since we added <code>#[kani::should_panic]</code>, running this example would produce a successful code.</p>
<p>Now, we've considered two ways to represent this result in the verification output.
Note that it's important that we provide the user with this feedback:</p>
<ol>
<li><strong>(Expectation)</strong> Was Kani expecting the harness to panic?</li>
<li><strong>(Outcome)</strong>: What's the actual result that Kani produced after the analysis?
This will avoid a potential scenario where the user doesn't know for sure if the attribute has had an effect when verifying the harness.</li>
</ol>
<p>Therefore, the representation must make clear both the expectation and the outcome.
Below, we show how we'll represent this result.</p>
<h4 id="recommended-representation-as-a-global-condition"><a class="header" href="#recommended-representation-as-a-global-condition">Recommended Representation: As a Global Condition</a></h4>
<p>The <code>#[kani::should_panic]</code> attribute essentially behaves as a property that depends on other properties.
This makes it well-suited for integration within the framework of <a href="https://model-checking.github.io/kani/rfc/rfcs/0007-global-conditions.html">Global Conditions</a>.</p>
<p>Using the <code>#[kani::should_panic]</code> attribute will enable the global condition with name <code>should_panic</code>.
Following the format for global conditions, the outcome will be one of the following:</p>
<ol>
<li><code> - `should_panic`: FAILURE (encountered no panics, but at least one was expected)</code> if there were no failures.</li>
<li><code> - `should_panic`: FAILURE (encountered failures other than panics, which were unexpected)</code> if there were failures but not all them had <code>prop.property_class() == &quot;assertion&quot;</code>.</li>
<li><code> - `should_panic`: SUCCESS (encountered one or more panics as expected)</code> otherwise.</li>
</ol>
<p>Note that the criteria to achieve a <code>SUCCESS</code> status depends on all failed properties having the property class <code>&quot;assertion&quot;</code>.
If they don't, then the failed properties may contain UB, so we return a <code>FAILURE</code> status instead.</p>
<h3 id="multiple-harnesses"><a class="header" href="#multiple-harnesses">Multiple Harnesses</a></h3>
<p>When there are multiple harnesses, we'll implement the single-harness changes in addition to the following ones.
Currently, a &quot;Summary&quot; section appears<sup class="footnote-reference"><a href="#footnote-summary">1</a></sup> after reporting the results for each harness:</p>
<pre><code>Verification failed for - harness3
Verification failed for - harness2
Verification failed for - harness1
Complete - 0 successfully verified harnesses, 3 failures, 3 total.
</code></pre>
<p>Harnesses marked with <code>#[kani::should_panic]</code> won't show unless the expected result was different from the actual result.
The summary will consider harnesses that match their expectation as &quot;successfully verified harnesses&quot;.</p>
<p>Therefore, if we added <code>#[kani::should_panic]</code> to all harnesses in the previous example, we'd see this output:</p>
<pre><code>Complete - 3 successfully verified harnesses, 0 failures, 3 total.
</code></pre>
<h3 id="multiple-panics"><a class="header" href="#multiple-panics">Multiple panics</a></h3>
<p>In a verification context, an execution can branch into multiple executions that depend on a condition.
This may result in a situation where different panics are reachable, as in this example:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::should_panic]
fn branch_panics() {
    let b: bool = kani::any();

    do_something();

    if b {
        call_panic_1(); // leads to a panic-related failure
    } else {
        call_panic_2(); // leads to a different panic-related failure
    }
}
</code></pre>
<p>Note that we could safeguard against these situations by checking that only one panic-related failure is reachable.
However, users have expressed that a <em>coarse</em> version (i.e., checking that at least one panic can be reached) is preferred.
Users also anticipate that <code>#[kani::should_panic]</code> will be used to exercise <a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">smoke testing</a> in many cases.
Additionally, restricting <code>#[kani::should_panic]</code> to the verification of single panic-related failures could be confusing for users and reduce its overall usefulness.</p>
<h3 id="availability"><a class="header" href="#availability">Availability</a></h3>
<p>This feature <strong>will only be available as an attribute</strong>.
That means this feature won't be available as a CLI option (i.e., <code>--should-panic</code>).
There are good reasons to avoid the CLI option:</p>
<ul>
<li>It'd make the design and implementation unnecessarily complex.</li>
<li>It'd only be useful when combined with <code>--harness</code> to filter negative harnesses.</li>
<li>We could have trouble extending its functionality (see <a href="rfcs/0005-should-panic-attr.html#future-possibilities">Future possibilities</a> for more details).</li>
</ul>
<h3 id="pedagogy-1"><a class="header" href="#pedagogy-1">Pedagogy</a></h3>
<p>The <code>#[kani::should_panic]</code> attribute will become one of the most basic attributes in Kani.
As such, it'll be mentioned in the tutorial and added to the dedicated section planned in <a href="https://github.com/model-checking/kani/issues/2208">#2208</a>.</p>
<p>In general, <strong>we'll also advise against negative verification</strong> when a harness can be written both as a regular (positive) harness and a negative one.
The feature, as it's presented in this proposal, won't allow checking that the panic failure is due to the panic we expected. 
So there could be cases where the panic changes, but it goes unnoticed while running Kani.
Because of that, it'll preferred that users write positive harnesses instead.</p>
<h2 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed Design</a></h2>
<p>At a high level, we expect modifications in the following components:</p>
<ul>
<li><code>kani-compiler</code>: Changes required to (1) process the new attribute, and (2) extend <code>HarnessMetadata</code> with a <code>should_panic: bool</code> field.</li>
<li><code>kani-driver</code>: Changes required to (1) edit information about harnesses printed by <code>kani-driver</code>,  (2) edit verification output when post-processing CBMC verification results, and (3) return the appropriate exit status after post-processing CBMC verification results.</li>
</ul>
<p>We don't expect these changes to require new dependencies.
Besides, we don't expect these changes to be updated unless we decide to extend the attribute with further fields (see <a href="rfcs/0005-should-panic-attr.html#future-possibilities">Future possibilities</a> for more details).</p>
<h2 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h2>
<p>This proposal would enable users to exercise negative verification with a relatively simple mechanism.
Not adding such a mechanism could impact Kani's usability by limiting the harnesses that users can write.</p>
<h3 id="alternative-1-generic-failures"><a class="header" href="#alternative-1-generic-failures">Alternative #1: Generic failures</a></h3>
<p>This proposal <strong>doesn't consider generic failures but only panics</strong>.
In principle, it's not clear that a mechanism for generic failures would be useful.
Such a mechanism would allow users to expect UB in their harness, but there isn't a clear motivation for doing that.</p>
<h3 id="alternative-2-name"><a class="header" href="#alternative-2-name">Alternative #2: Name</a></h3>
<p>We have considered two alternatives for the &quot;expectation&quot; part of the attribute's name: <code>should</code> and <code>expect</code>.
We avoid <code>expect</code> altogether for two reasons:</p>
<ul>
<li>We may consider adding the <code>expected</code> argument to <code>#[kani::should_panic]</code>.</li>
<li>We may consider a more granular approach to indicate expectations regarding individual checks and cover statements in the future. One possible name for the attribute is <code>#[kani::expect]</code>.</li>
<li>We heavily use this word for testing in Kani: there is an <code>expected</code> mode, which works with <code>*.expected</code> files. Other modes also use such files.</li>
</ul>
<h3 id="alternative-3-the-expected-argument"><a class="header" href="#alternative-3-the-expected-argument">Alternative #3: The <code>expected</code> argument</a></h3>
<p>We could consider an <code>expected</code> argument, similar to <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics">the <code>#[should_panic]</code> attribute</a>.
To be clear, the <code>#[should_panic]</code> attribute may receive an argument <code>expected</code> which allows users to specify the expected panic string:</p>
<pre><code class="language-rust">    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
</code></pre>
<p>In principle, we anticipate that we'll extend this proposal to include the <code>expected</code> argument at some point.
The implementation could compare the <code>expected</code> string against the panic string.</p>
<p>At present, the only technical limitation is that panic strings printed in Kani aren't formatted.
One option is to use substrings to compare.
However, the long-term solution is to use concrete playback to <em>replay</em> the panic and match against the expected panic string.
By doing this, we would achieve feature parity with Rust's <code>#[should_panic]</code>.</p>
<h3 id="alternative-4-granularity"><a class="header" href="#alternative-4-granularity">Alternative #4: Granularity</a></h3>
<p>As mentioned earlier, users may want to express more granular expectations for their harnesses.</p>
<p>There could be problems with this proposal if we attempt to do both:</p>
<ul>
<li>What if users don't want to only check for failures (e.g., reachability)?</li>
<li>In the previous case, would they expect the overall verification to fail or not?</li>
<li>How do we want these expectations to be declared?</li>
</ul>
<p>We don't have sufficient data about the use-case considered in this alternative.
This proposal can also contribute to collect this data: once users can expect panics, they may want to expect other things.</p>
<h3 id="alternative-5-kani-api"><a class="header" href="#alternative-5-kani-api">Alternative #5: Kani API</a></h3>
<p>This functionality could be part of the Kani API instead of being an attribute.
For example, some contributors proposed a function that takes a predicate closure to filter executions and check that they result in a panic.</p>
<p>However, such a function couldn't be used in external code, limiting its usability to the user's code.</p>
<h2 id="open-questions-5"><a class="header" href="#open-questions-5">Open questions</a></h2>
<p>Once the feature is available, it'd be good to gather user feedback to answer these questions:</p>
<ul>
<li>Do we need a mechanism to express more granular expectations?</li>
<li>If we need the mechanism in (2), do we really want to collapse them into one feature?</li>
</ul>
<h3 id="resolved-questions"><a class="header" href="#resolved-questions">Resolved questions</a></h3>
<ul>
<li><em>What is the best representation to use for this feature?</em> A representation that changes the overall result seems to be preferred, according to feedback we received during a discussion.</li>
<li><em>Do we want to extend <code>#[kani::should_panic]</code> with an <code>expected</code> field?</em> Yes, but not in this version.</li>
<li><em>Do we want to allow multiple panic-related failures with <code>#[kani::should_panic]</code>?</em> Yes (this is now discussed in <a href="rfcs/0005-should-panic-attr.html#user-experience">User Experience</a>).</li>
</ul>
<h2 id="future-possibilities-4"><a class="header" href="#future-possibilities-4">Future possibilities</a></h2>
<ul>
<li>The attribute could be an argument to <code>kani::proof</code> (<code>#[kani::proof(should_panic)]</code> reads very well).</li>
<li>Add an <code>expected</code> argument to <code>#[kani::should_panic]</code>, and <em>replay</em> the harness with concrete playback to get the actual panic string.</li>
</ul>
<div class="footnote-definition" id="footnote-representation"><sup class="footnote-definition-label">2</sup>
<p>Double negation may not be the best representation, but it's at least accurate with respect to the original result.</p>
</div>
<div class="footnote-definition" id="footnote-summary"><sup class="footnote-definition-label">1</sup>
<p>This summary is printed in both the default and terse outputs.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Unstable APIs (<code>unstable-api</code>)</li>
<li><strong>RFC Tracking Issue</strong>: <a href="https://github.com/model-checking/kani/issues/2279">https://github.com/model-checking/kani/issues/2279</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2281">https://github.com/model-checking/kani/pull/2281</a></li>
<li><strong>Status:</strong> Unstable</li>
<li><strong>Version:</strong> 0</li>
</ul>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Provide a standard option for users to enable experimental APIs and features in Kani,
and ensure that those APIs are off by default.</p>
<h2 id="user-impact-6"><a class="header" href="#user-impact-6">User Impact</a></h2>
<p>Add an opt-in model for users to try experimental APIs.
The goal is to enable users to try features that aren't stable yet,
which allow us to get valuable feedback during the development of new features and APIs.</p>
<p>The opt-in model empowers the users to control when some instability is acceptable,
which makes Kani UX more consistent and safe.</p>
<p>Currently, each new unstable feature will introduce a new switch, some of them will look like <code>--enable-&lt;feature&gt;</code>,
while others will be a plain switch which allows further feature configuration <code>--&lt;feature-config&gt;=[value]</code>.
For example, we today have the following unstable switches <code>--enable-stubbing</code>, <code>--concrete-playback</code>, <code>--gen-c</code>.
In all cases, users are still required to provide the additional <code>--enable-unstable</code> option.
Some unstable features are included in the <code>--help</code> section, and only a few mention the requirement
to include <code>--enable-unstable</code>. There is no way to list all unstable features.
The transition to stable switches is also ad-hoc.</p>
<p>In order to reduce friction, we will also standardize how users opt-in to any Kani unstable feature.
We will use similar syntax to the one used by the Rust compiler and Cargo.
As part of this work, we will also deprecate and remove <code>--enable-unstable</code> option.</p>
<p>Note that although Kani is still on v0, which means that everything is somewhat unstable,
this allow us to set different bars when it comes to what kind of changes is expected,
as well as what kind of support we will provide for a feature.</p>
<h2 id="user-experience-6"><a class="header" href="#user-experience-6">User Experience</a></h2>
<p>Users will have to invoke Kani with:</p>
<pre><code>-Z &lt;feature_identifier&gt;
</code></pre>
<p>in order to enable any unstable feature in Kani, including unstable APIs in the Kani library.
For unstable command line options, we will add <code>-Z unstable-options</code>, similar to the Rust compiler.
E.g.:</p>
<pre><code>-Z unstable-options --concrete-playback=print
</code></pre>
<p>Users will also be able to enable unstable features in their <code>Cargo.toml</code> in the <code>unstable</code> table
under <code>kani</code> table. E.g:</p>
<pre><code class="language-toml">[package.metadata.kani.unstable]
unstable-options = true

[workspace.metadata.kani]
flags = { concrete-playback = true }
unstable = { unstable-options = true }
</code></pre>
<p>In order to mark an API as unstable, we will add the following attribute to the APIs marked as unstable:</p>
<pre><code class="language-rust">#[kani::unstable(feature=&quot;&lt;IDENTIFIER&gt;&quot;, issue=&quot;&lt;TRACKING_ISSUE_NUMBER&gt;&quot;, reason=&quot;&lt;DESCRIPTION&gt;&quot;)]
pub fn unstable_api() {}
</code></pre>
<p>This is similar to the interface used by <a href="https://rustc-dev-guide.rust-lang.org/stability.html#unstable">the standard library</a>.</p>
<p>If the user tries to use an unstable feature in Kani without explicitly enabling it,
Kani will trigger an error. For unstable APIs, the error will be triggered during the crate
compilation.</p>
<h2 id="detailed-design-5"><a class="header" href="#detailed-design-5">Detailed Design</a></h2>
<p>We will add the <code>-Z</code> option to both <code>kani-driver</code> and <code>kani-compiler</code>.
Kani driver will pass the information to the compiler.</p>
<p>For unstable APIs, the compiler will check if any reachable function uses an unstable feature that was not enabled.
If that is the case, the compiler will trigger a compilation error.</p>
<p>We will also change the compiler to only generate code for harnesses that match the harness filter.
The filter is already passed to the compiler, but it is currently only used for stubbing.</p>
<h3 id="api-stabilization"><a class="header" href="#api-stabilization">API Stabilization</a></h3>
<p>Once an API has been stabilized, we will remove the <code>unstable</code> attributes from the given API.
If the user tries to enable a feature that was already stabilized,
Kani will print a warning stating that the feature has been stabilized.</p>
<h3 id="api-removal"><a class="header" href="#api-removal">API Removal</a></h3>
<p>If we decide to remove an API that is marked as unstable, we should follow a regular deprecation
path (using <code>#[deprecated]</code> attribute), and keep the <code>unstable</code> flag + attributes, until we are
ready to remove the feature completely.</p>
<h2 id="rational-and-alternatives-1"><a class="header" href="#rational-and-alternatives-1">Rational and Alternatives</a></h2>
<p>For this RFC, the suggestion is to only enable experimental features globally for simplicity of use and implementation.</p>
<p>For now, we will trigger a compilation error if an unstable API is reachable from a user crate
unless if the user opts in for the unstable feature.</p>
<p>We could allow users to specify experimental features on a per-harness basis,
but it could be tricky to make it clear to the user which harness may be affected by which feature.
The extra granularity would also be painful when we decide a feature is no longer experimental,
whether it is stabilized or removed.
In those cases, users would have to edit each harness that enables the affected feature.</p>
<h2 id="open-questions-6"><a class="header" href="#open-questions-6">Open questions</a></h2>
<ul>
<li>Should we also add a <code>stable</code> attribute that documents when an API was stabilized?</li>
</ul>
<h2 id="future-possibilities-5"><a class="header" href="#future-possibilities-5">Future possibilities</a></h2>
<ul>
<li>Delay the error due to the usage of a unstable API, and only fail at runtime if the API is reachable.</li>
<li>Allow users to enable unstable features on a per-harness basis.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Global Conditions (<code>global-conditions</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2525">https://github.com/model-checking/kani/issues/2525</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2516">https://github.com/model-checking/kani/pull/2516</a></li>
<li><strong>Status:</strong> <em>Unstable</em></li>
<li><strong>Version:</strong> 0</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/model-checking/kani/pull/2532">https://github.com/model-checking/kani/pull/2532</a></li>
</ul>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>A new section in Kani's output to summarize the status of properties that depend on other properties. We use the term <em>global conditions</em> to refer to such properties. </p>
<h2 id="user-impact-7"><a class="header" href="#user-impact-7">User Impact</a></h2>
<p>The addition of new options that affect the overall verification result depending on certain property attributes demands some consideration.
In particular, the addition of a new option to fail verification if there are uncoverable (i.e., unsatisfiable or unreachable) <code>cover</code> properties (requested in <a href="https://github.com/model-checking/kani/issues/2299">#2299</a>) is posing new challenges to our current architecture and UI.</p>
<p>This concept isn't made explicit in Kani, but exists in some ways.
For example, the <code>kani::should_panic</code> attribute is a global condition because it can be described in terms of other properties (checks).
The request in <a href="https://github.com/model-checking/kani/issues/2299">#2299</a> is essentially another global conditions, and we may expect more to be requested in the future.</p>
<p>In this RFC, we propose a new section in Kani's output focused on reporting global conditions.
The goal is for users to receive useful information about hyperproperties without it becoming overwhelming.
This will help users to understand better options that are enabled through global conditions and ease the addition of such options to Kani.</p>
<h2 id="user-experience-7"><a class="header" href="#user-experience-7">User Experience</a></h2>
<p><strong>The output will refer to properties that depend on other properties as &quot;global conditions&quot;</strong>, which is a simpler term.
The options to enable different global conditions will depend on a case-by-case basis<sup class="footnote-reference"><a href="#enable-options">1</a></sup>.</p>
<p>The main UI change in this proposal is a new <code>GLOBAL CONDITIONS</code> section that <strong>won't be printed if no global conditions have been enabled</strong>.
This section will only appear in Kani's default output after the <code>RESULTS</code> section (used for individual checks) and have the format:</p>
<pre><code>GLOBAL CONDITIONS:
 - `&lt;name&gt;`: &lt;status&gt; (&lt;reason&gt;)
 - `&lt;name&gt;`: &lt;status&gt; (&lt;reason&gt;)
 [...]
</code></pre>
<p>where:</p>
<ul>
<li><code>&lt;name&gt;</code> is the name given to the global condition.</li>
<li><code>&lt;status&gt;</code> is the status determined for the global condition.</li>
<li><code>&lt;reason&gt;</code> is an explanation that depends on the status of the global condition.</li>
</ul>
<p>For example, let's assume we implement the option requested in <a href="https://github.com/model-checking/kani/issues/2299">#2299</a>.
A concrete example of this output would be:</p>
<pre><code>GLOBAL CONDITIONS:
 - `fail_uncoverable`: SUCCESS (all cover statements were satisfied as expected)
</code></pre>
<p>A <code>FAILED</code> status in any enabled global condition will cause verification to fail.
In that case, the overall verification result will point out that one or more global conditions failed, as in:</p>
<pre><code>VERIFICATION:- FAILURE (one or more global conditions failed)
</code></pre>
<p>This last UI change will also be implemented for the terse output.
Finally, checks that cause an enabled global condition to fail will be reported using the same interface we use for failed checks<sup class="footnote-reference"><a href="#failed-checks">2</a></sup>.</p>
<p><strong>Global conditions which aren't enabled won't appear in the <code>GLOBAL CONDITIONS</code> section</strong>.
Their status will be computed regardless<sup class="footnote-reference"><a href="#status-computation">3</a></sup>, and we may consider showing this status when the <code>--verbose</code> option is passed.</p>
<p>The documentation of global conditions will depend on how they're enabled, which depends on a case-by-case basis.
However, we may consider adding a new subsection <code>Global conditions</code> to the <code>Reference</code> section that collects all of them so it's easier for users to consult all of them in one place.</p>
<h2 id="detailed-design-6"><a class="header" href="#detailed-design-6">Detailed Design</a></h2>
<p>The only component to be modified is <code>kani-driver</code> since that's where verification results are built and determined.
But we should consider moving this logic into another crate.</p>
<p>We don't need new dependencies.
The corner cases will depend on the specific global conditions to be implemented.</p>
<h2 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h2>
<p>As mentioned earlier, we're proposing this change to help users understand global conditions and how they're determined.
In many cases, global conditions empower users to write harnesses which weren't possible to write before.
As an example, the <code>#[kani::should_panic]</code> attribute allowed users to write harnesses expecting panic-related failures.</p>
<p>Also, we don't really know if more global conditions will be requested in the future.
We may consider discarding this proposal and waiting for the next feature that can be implemented as a global condition to be requested.</p>
<h3 id="alternative-global-conditions-as-regular-checks"><a class="header" href="#alternative-global-conditions-as-regular-checks">Alternative: Global conditions as regular checks</a></h3>
<p>One option we've considered in the past is to enable global conditions as a regular checks.
While it's technically doable, it doesn't feel appropriate for global conditions to reported through regular checks since generally a higher degree of visibility may be appreciated.</p>
<h2 id="open-questions-7"><a class="header" href="#open-questions-7">Open questions</a></h2>
<p>No open questions.</p>
<h2 id="future-possibilities-6"><a class="header" href="#future-possibilities-6">Future possibilities</a></h2>
<p>A redesign of Kani's output is likely to change the style/architecture to report global conditions.</p>
<div class="footnote-definition" id="status-computation"><sup class="footnote-definition-label">3</sup>
<p>The results for global conditions would be computed during postprocessing based on the results of other checks.
Global conditions' checks aren't part of the SAT, therefore this computation won't impact verification time.</p>
</div>
<div class="footnote-definition" id="failed-checks"><sup class="footnote-definition-label">2</sup>
<p>We do not discuss the specific interface to report the failed checks because it needs improvements (for both global conditions and standard verification).
In particular, the description field is the only information printed for properties (such as <code>cover</code> statements) without trace locations.
There are additional improvements we should consider: printing the actual status (for global conditions, this won't always be <code>FAILED</code>), avoid the repetition of <code>Failed Checks: </code>, etc.
<a href="https://github.com/model-checking/kani/pull/2516#issuecomment-1597524184">This comment</a> discusses problems with the current interface on some examples.</p>
</div>
<div class="footnote-definition" id="enable-options"><sup class="footnote-definition-label">1</sup>
<p>In other words, global conditions won't force a specific mechanism to be enabled.
For example, if the <code>#[kani::should_panic]</code> attribute is converted into a global condition, it will continue to be enabled through the attribute itself.
Other global conditions may be enabled through CLI flags only (e.g., <code>--fail-uncoverable</code>), or a combination of options in general.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Line coverage (<code>line-coverage</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2610">https://github.com/model-checking/kani/issues/2610</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2609">https://github.com/model-checking/kani/pull/2609</a></li>
<li><strong>Status:</strong> Cancelled</li>
<li><strong>Version:</strong> 0</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/model-checking/kani/pull/2609">https://github.com/model-checking/kani/pull/2609</a> (Kani) + <a href="https://github.com/model-checking/kani-vscode-extension/pull/122">https://github.com/model-checking/kani-vscode-extension/pull/122</a> (Kani VS Code Extension)</li>
</ul>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Add verification-based line coverage reports to Kani.</p>
<h2 id="user-impact-8"><a class="header" href="#user-impact-8">User Impact</a></h2>
<p>Nowadays, users can't easily obtain verification-based coverage reports in Kani.
Generally speaking, coverage reports show which parts of the code under verification are covered and which are not.
Because of that, coverage is often seen as a great metric to determine the quality of a verification effort.</p>
<p>Moreover, some users prefer using coverage information for harness development and debugging.
That's because coverage information provides users with more familiar way to interpret verification results.</p>
<p>This RFC proposes adding a new option for verification-based line coverage reports to Kani.
As mentioned earlier, we expect users to employ this coverage-related option on several stages of a verification effort:</p>
<ul>
<li><strong>Learning:</strong> New users are more familiar with coverage reports than property-based results.</li>
<li><strong>Development:</strong> Some users prefer coverage results to property-based results since they are easier to interpret.</li>
<li><strong>CI Integration</strong>: Users may want to enforce a minimum percentage of code coverage for new contributions.</li>
<li><strong>Debugging:</strong> Users may find coverage reports particularly helpful when inputs are over-constrained (missing some corner cases).</li>
<li><strong>Evaluation:</strong> Users can easily evaluate where and when more verification work is needed (some projects aim for 100% coverage).</li>
</ul>
<p>Moreover, adding this option directly to Kani, instead of relying on another tools, is likely to:</p>
<ol>
<li>Increase the speed of development</li>
<li>Improve testing for coverage features</li>
</ol>
<p>Which translates into faster and more reliable coverage options for users.</p>
<h2 id="user-experience-8"><a class="header" href="#user-experience-8">User Experience</a></h2>
<p>The goal is for Kani to generate code coverage report per harness in a well established format, such as <a href="https://github.com/linux-test-project/lcov">LCOV</a>, and possibly a summary in the output.
For now, we will focus on an interim solution that will enable us to assess the results of <a href="rfcs/0008-line-coverage.html#injection-of-coverage-checks">our instrumentation</a> and enable integration with the Kani VS Code extension.</p>
<h3 id="high-level-changes"><a class="header" href="#high-level-changes">High-level changes</a></h3>
<p>For the first version, this experimental feature will report verification results along coverage reports.
Because of that, we'll add a new section <code>Coverage results</code> that shows coverage results for each individual harness.</p>
<p>In the following, we describe an experimental output format.
Note that the final output format and overall UX is to be determined.</p>
<h3 id="experimental-output-format-for-coverage-results"><a class="header" href="#experimental-output-format-for-coverage-results">Experimental output format for coverage results</a></h3>
<p>The <code>Coverage results</code> section for each harness will produce coverage information in a CSV format as follows:</p>
<pre><code>&lt;file&gt;, &lt;line&gt;, &lt;status&gt;
</code></pre>
<p>where <code>&lt;status&gt;</code> is either <code>FULL</code>, <code>PARTIAL</code> or <code>NONE</code>.</p>
<p>As mentioned, this format is designed for evaluating the <a href="rfcs/0008-line-coverage.html#detailed-design">native instrumentation-based design</a> and is likely to be substituted with another well-established format as soon as possible.</p>
<p><strong>Users are not expected to consume this output directly.</strong>
Instead, coverage data is to be consumed by the <a href="https://github.com/model-checking/kani-vscode-extension">Kani VS Code extension</a> and displayed as in <a href="https://github.com/model-checking/kani-vscode-extension/pull/122">the VS Code Extension prototype</a>.</p>
<p>How to activate and display coverage information in the extension is out of scope for this RFC.
That said, a proof-of-concept implementation is available <a href="https://github.com/model-checking/kani-vscode-extension/pull/122">here</a>.</p>
<h2 id="detailed-design-7"><a class="header" href="#detailed-design-7">Detailed Design</a></h2>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>We will add a new unstable <code>--coverage</code> verification option to Kani which will require <code>-Z line-coverage</code> until this feature is stabilized.
We will also add a new <code>--coverage-checks</code> option to <code>kani-compiler</code>, which will result in the injection of coverage checks before each Rust statement and terminator<sup class="footnote-reference"><a href="#coverage-experiments">1</a></sup>.
This option will be supplied by <code>kani-driver</code> when the <code>--coverage</code> option is selected.
These options will cause Kani to inject coverage checks during compilation and postprocess them to produce the coverage results sections described earlier.</p>
<h3 id="coverage-checks"><a class="header" href="#coverage-checks">Coverage Checks</a></h3>
<p>Coverage checks are a new class of checks similar to <a href="https://model-checking.github.io/kani/rfc/rfcs/0003-cover-statement.html"><code>cover</code> checks</a>.
The main difference is that users cannot directly interact with coverage checks (i.e., they cannot add or remove them manually).
Coverage checks are encoded as an <code>assert(false)</code> statement (to test reachability) with a fixed description.
In addition, coverage checks are:</p>
<ul>
<li>Hidden from verification results.</li>
<li>Postprocessed to produce coverage results.</li>
</ul>
<p>In the following, we describe the injection and postprocessing procedures to generate coverage results.</p>
<h4 id="injection-of-coverage-checks"><a class="header" href="#injection-of-coverage-checks">Injection of Coverage Checks</a></h4>
<p>The injection of coverage checks will be done while generating code for basic blocks.
This allows us to add one coverage check before each statement and terminator, which provides the most accurate results<sup class="footnote-reference"><a href="#coverage-experiments">1</a></sup>.
It's not completely clear how this compares to the coverage instrumentation done in the Rust compiler, but an exploration to use the compiler APIs revealed that they're quite similar<sup class="footnote-reference"><a href="#coverage-api">2</a></sup>.</p>
<h4 id="postprocessing-coverage-checks"><a class="header" href="#postprocessing-coverage-checks">Postprocessing Coverage Checks</a></h4>
<p>The injection of coverage checks often results in one or more checks per line (assuming a well-formatted program).
We'll postprocess these checks so for each line</p>
<ul>
<li>if all checks are <code>SATISFIED</code>: return <code>FULL</code></li>
<li>if all checks are <code>UNSATISFIED</code>: return <code>NONE</code></li>
<li>otherwise: return <code>PARTIAL</code></li>
</ul>
<p>We won't report coverage status for lines which don't include a coverage check.</p>
<h2 id="rationale-and-alternatives-5"><a class="header" href="#rationale-and-alternatives-5">Rationale and alternatives</a></h2>
<h3 id="benefits-from-a-native-coverage-solution"><a class="header" href="#benefits-from-a-native-coverage-solution">Benefits from a native coverage solution</a></h3>
<p>Kani has relied on <a href="https://github.com/model-checking/cbmc-viewer"><code>cbmc-viewer</code></a> to report coverage information since the beginning.
In essence, <code>cbmc-viewer</code> consumes data from coverage-focused invocations of CBMC and produces an HTML report containing (1) coverage information and (2) counterexample traces.
Recently, there have been some issues with the coverage information reported by <code>cbmc-viewer</code> (e.g., <a href="https://github.com/model-checking/kani/issues/2048">#2048</a> or <a href="https://github.com/model-checking/kani/issues/1707">#1707</a>), forcing us to mark the <code>--visualize</code> option as unstable and disable coverage results in the reports (in <a href="https://github.com/model-checking/kani/pull/2206">#2206</a>).</p>
<p>However, it's possible for Kani to report coverage information without <code>cbmc-viewer</code>, as explained before.
This would give Kani control on both ends:</p>
<ul>
<li><strong>The instrumentation performed</strong> on the program. Eventually, this would allow us to report more precise coverage information (maybe similar to <a href="https://doc.rust-lang.org/rustc/instrument-coverage.html">Rust's instrument-based code coverage</a>).</li>
<li><strong>The format of the coverage report</strong> to be generated. Similarly, this would allow us to generate coverage data in different formats (see <a href="https://github.com/model-checking/kani/issues/1706">#1706</a> for GCOV, or <a href="https://github.com/model-checking/kani/issues/1777">#1777</a> for LCOV). While technically this is also doable from <code>cbmc-viewer</code>'s output, development is likely to be faster this way.</li>
</ul>
<h4 id="coverage-through-cbmc-viewer"><a class="header" href="#coverage-through-cbmc-viewer">Coverage through <code>cbmc-viewer</code></a></h4>
<p>As an alternative, we could fix and use <code>cbmc-viewer</code> to report line coverage.</p>
<p>Most of the issues with <code>cbmc-viewer</code> are generally due to:</p>
<ol>
<li>Missing locations due to non-propagation of locations in either Kani or CBMC.</li>
<li>Differences in the definition of a basic block in CBMC and Rust's MIR.</li>
<li>Scarce documentation for coverage-related options (i.e., <code>--cover &lt;option&gt;</code>) in CBMC.</li>
<li>Limited testing with Rust code in <code>cbmc-viewer</code>.</li>
</ol>
<p>Note that (1) is not exclusive to coverage results from <code>cbmc-viewer</code>.
Finding checks with missing locations and propagating them if possible (as suggested in <a href="https://github.com/model-checking/kani/issues/2048#issuecomment-1599680694">this comment</a>) should be done regardless of the approach used for line coverage reports.</p>
<p>In contrast, (2) and (3) can be considered the main problems for Kani contributors to develop coverage options on top of <code>cbmc-viewer</code> and CBMC.
It's not clear how much effort this would involve, but (3) is likely to require substantial documentation contributions.
But (4) shouldn't be an issue if we decided to invest in <code>cbmc-viewer</code>.</p>
<p>Finally, the following downside must be considered:
<code>cbmc-viewer</code> can report line coverage but <strong>the path to report region-based coverage may involve a complete rewrite</strong>.</p>
<h4 id="other-output-formats"><a class="header" href="#other-output-formats">Other output formats</a></h4>
<p>One of the long-term goals for this feature is to provide a UX that is familiar for users.
This is particularly relevant when talking about output formats.
Some services and frameworks working with certain coverage output formats have become quite popular.</p>
<p>However, this version doesn't consider common output formats (i.e., GCOV or LCOV) since coverage results will only be consumed by the Kani VS Code Extension at first.
But other output formats will be considered in the future.</p>
<h2 id="open-questions-8"><a class="header" href="#open-questions-8">Open questions</a></h2>
<p>Open questions:</p>
<ul>
<li>Do we want to report line coverage as <code>COVERED</code>/<code>UNCOVERED</code> or <code>FULL</code>/<code>PARTIAL</code>/<code>NONE</code>?</li>
<li>Should we report coverage results and verification results or not? Doing both is likely to result in worse performance. We have to perform an experimental evaluation with hard benchmarks.</li>
<li>Should we instrument dependencies or not? Doing so is likely to result in worse performance. We have to perform an experimental evaluation.</li>
<li>What should be the final UX for this feature? For instance, we could print a coverage summary and generate a report file per harness. But it's not clear if individual results are relevant to users, so another possibility is to automatically combine results.</li>
<li>What's the most appropriate and well-established output format we can emit?</li>
<li>Determine if there are cases in which coverage information is confusing for users (due to, e.g., constant propagation or other compiler optimizations). How can work around such cases?</li>
<li>Do we want to report coverage information for dependencies? For CI, most users may be only interested in their code. Most coverage frameworks have an aggregation tool with <a href="https://doc.rust-lang.org/rustc/instrument-coverage.html#compiling-with-coverage-enabled">an option to exclude dependencies</a> from coverage metrics.</li>
</ul>
<p>Feedback to gather before stabilization:</p>
<ul>
<li>Compare the injection-based approach in this RFC with <a href="https://doc.rust-lang.org/rustc/instrument-coverage.html">Rust's instrument-based code coverage</a>?</li>
</ul>
<h2 id="future-possibilities-7"><a class="header" href="#future-possibilities-7">Future possibilities</a></h2>
<p>We expect many incremental improvements in the coverage area:</p>
<ol>
<li>Consuming the output produced in coverage results from the <a href="https://github.com/model-checking/kani-vscode-extension">Kani VS Code extension</a>.</li>
<li>Building a tool that produces coverage results by combining the coverage results of more than one harness.</li>
<li>Including span information in coverage checks and building region-based coverage reports.</li>
<li>Adding new user-requested coverage formats such as GCOV <a href="https://github.com/model-checking/kani/issues/1706">#1706</a> or LCOV <a href="https://github.com/model-checking/kani/issues/1777">#1777</a>.</li>
</ol>
<div class="footnote-definition" id="coverage-experiments"><sup class="footnote-definition-label">1</sup>
<p>We have experimented with different options for injecting coverage checks.
For example, we have tried injecting one before each basic block, or one before each statement, etc.
The proposed option (one before each statement AND each terminator) gives us the most accurate results.</p>
</div>
<div class="footnote-definition" id="coverage-api"><sup class="footnote-definition-label">2</sup>
<p>In particular, comments in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpan.html"><code>CoverageSpan</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.generate_coverage_spans"><code>generate_coverage_spans</code></a> hint that the initial set of spans come from <code>Statement</code>s and <code>Terminators</code>. <a href="https://github.com/model-checking/kani/pull/2612#issuecomment-1646312827">This comment</a> goes in detail about the attempt to use the compiler APIs.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Function Contracts</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2652">#2652</a> and <a href="https://github.com/model-checking/kani/milestone/31">Milestone</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/2620">#2620</a></li>
<li><strong>Status:</strong> Unstable</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/model-checking/kani/tree/features/contracts">features/contracts</a></li>
<li><strong>Feature Gate:</strong> <code>-Zfunction-contracts</code>, enforced by compile time error<sup class="footnote-reference"><a href="#gate">1</a></sup></li>
</ul>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>Function contracts are a means to specify and check function behavior. On top of
that the specification can then be used as a sound<sup class="footnote-reference"><a href="#simple-unsoundness">2</a></sup>
abstraction to replace the concrete implementation, similar to <a href="https://model-checking.github.io/kani/rfc/rfcs/0002-function-stubbing.html">stubbing</a>.</p>
<p>This allows for a modular verification.</p>
<!-- Shorter? -->
<h2 id="user-impact-9"><a class="header" href="#user-impact-9">User Impact</a></h2>
<!-- Is basically the pitch and addressing the user. -->
<p>Function contracts provide an interface for a verified,
sound<sup class="footnote-reference"><a href="#simple-unsoundness">2</a></sup> function abstraction. This is similar to <a href="https://model-checking.github.io/kani/rfc/rfcs/0002-function-stubbing.html">stubbing</a>
but with verification of the abstraction instead of blind trust. This allows for
modular verification, which paves the way for the following two ambitious goals.</p>
<ul>
<li><strong>Scalability:</strong> A function contract is an abstraction (sound
overapproximation) of a function's behavior. After verifying the contract
against its implementation we can subsequently use the (cheaper) abstraction
instead of the concrete implementation when analyzing its callers.
Verification is thus modularized and even cacheable.</li>
<li><strong>Unbounded Verification:</strong> Contracts enable inductive reasoning for recursive
functions where the first call is checked against the contract and recursive
calls are stubbed out using the abstraction.</li>
</ul>
<p>Function contracts are completely optional with no user impact if unused. This
RFC proposes the addition of new attributes, and functions, that shouldn't
interfere with existing functionalities.</p>
<h2 id="user-experience-9"><a class="header" href="#user-experience-9">User Experience</a></h2>
<p>A function contract specifies the behavior of a function as a predicate that
can be checked against the function implementation and also used as an
abstraction of the implementation at the call sites.</p>
<p>The lifecycle of a contract is split into three phases: specification,
verification and call abstraction, which we will explore on this example:</p>
<pre><code class="language-rs">fn my_div(dividend: u32, divisor: u32) -&gt; u32 {
  dividend / divisor
}
</code></pre>
<ol>
<li>
<p>In the first phase we <strong>specify</strong> the contract. Kani provides two new
annotations: <code>requires</code> (preconditions) to describe the expectations this
function has as to the calling context and <code>ensures</code> (postconditions) which
approximates function outputs in terms of function inputs.</p>
<pre><code class="language-rs">#[kani::requires(divisor != 0)]
#[kani::ensures(|result : &amp;u32| *result &lt;= dividend)]
fn my_div(dividend: u32, divisor: u32) -&gt; u32 {
  dividend / divisor
}
</code></pre>
<p><code>requires</code> here indicates this function expects its <code>divisor</code> input to never
be 0, or it will not execute correctly (for instance panic or cause undefined
behavior).</p>
<p><code>ensures</code> puts a bound on the output, relative to the <code>dividend</code> input.</p>
<p>Conditions in contracts are Rust expressions which reference the
function arguments and, in case of <code>ensures</code>, the return value of the
function. The return value is passed into the ensures closure statement by reference. Syntactically
Kani supports any Rust expression, including function calls, defining types
etc. However they must be side-effect free (see also side effects
<a href="rfcs/0009-function-contracts.html#changes-to-other-components">here</a>) or Kani will throw a compile error.</p>
<p>Multiple <code>requires</code> and <code>ensures</code> clauses are allowed on the same function,
they are implicitly logically conjoined.</p>
</li>
<li>
<p>Next, Kani ensures that the function implementation respects all the conditions specified in its contract.</p>
<p>To perform this check Kani needs a suitable harness to verify the function
in. The harness is mainly responsible for providing the function arguments
but also set up a valid heap that pointers may refer to and properly
initialize <code>static</code> variables.</p>
<p>Kani demands of us, as the user, to provide this harness; a limitation of
this proposal. See also <a href="rfcs/0009-function-contracts.html#future-possibilities">future possibilities</a> for a
discussion about the arising soundness issues and their remedies.</p>
<p>Harnesses for checking contract are defined with the
<code>proof_for_contract(TARGET)</code> attribute which references <code>TARGET</code>, the
function for which the contract is supposed to be checked.</p>
<pre><code class="language-rs">#[kani::proof_for_contract(my_div)]
fn my_div_harness() {
  my_div(kani::any(), kani::any())
}
</code></pre>
<p>Similar to a verification harness for any other function, we are supposed to
create all possible input combinations the function can encounter, then call
the function at least once with those abstract inputs. If we forget to call
<code>my_div</code> Kani reports an error. Unlike other harnesses we only need to create
suitable data structures but we don't need to add any checks as Kani will
use the conditions we specified in the contract. </p>
<p>Kani inserts preconditions (<code>requires</code>) as <code>kani::assume</code> <em>before</em> the call
to <code>my_div</code>, limiting inputs to those the function is actually defined for.
It inserts postconditions (<code>ensures</code>) as <code>kani::assert</code> checks <em>after</em> the
call to <code>my_div</code>, enforcing the contract.</p>
<p>The expanded version of our harness that Kani generates looks roughly like
this:</p>
<pre><code class="language-rs">#[kani::proof]
fn my_div_harness() {
  let dividend = kani::any();
  let divisor = kani::any();
  kani::assume(divisor != 0); // requires
  let result_kani_internal = my_div(dividend, divisor);
  kani::assert((|result : &amp;u32| *result &lt;= dividend)(result_kani_internal)); // ensures
}
</code></pre>
<p>Kani verifies the expanded harness like any other harness, giving the
green light for the next step: call abstraction.</p>
</li>
<li>
<p>In the last phase the <strong>verified</strong> contract is ready for us to use to
abstract the function at its call sites.</p>
<p>Kani requires that there has to be at least one associated
<code>proof_for_contract</code> harness for each abstracted function, otherwise an error is
thrown. In addition, by default, it requires all <code>proof_for_contract</code>
harnesses to pass verification before attempting verification of any
harnesses that use the contract as a stub.</p>
<p>A possible harness that uses our <code>my_div</code> contract could be the following:</p>
<pre><code class="language-rs">#[kani::proof]
#[kani::stub_verified(my_div)]
fn use_div() {
  let v = vec![...];
  let some_idx = my_div(v.len() - 1, 3);
  v[some_idx];
}
</code></pre>
<p>At a call site where the contract is used as an abstraction Kani
<code>kani::assert</code>s the preconditions (<code>requires</code>) and produces a
nondeterministic value (<code>kani::any</code>) which satisfies the postconditions.</p>
<p>Mutable memory is similarly made non-deterministic, discussed later in
<a href="rfcs/0009-function-contracts.html#memory-predicates-and-havocking">havocking</a>.</p>
<p>An expanded stubbing of <code>my_div</code> looks like this:</p>
<pre><code class="language-rs">fn my_div_stub(dividend: u32, divisor: u32) -&gt; u32 {
  kani::assert(divisor != 0); // pre-condition
  kani::any_where(|result| { /* post-condition */ result &lt;= dividend })
}
</code></pre>
<p>Notice that this performs no actual computation for <code>my_div</code> (other than the
conditions) which allows us to avoid something potentially costly.</p>
</li>
</ol>
<p>Also notice that Kani was able to express both contract checking and abstracting
with existing capabilities; the important feature is the enforcement. The
checking is, by construction, performed <strong>against the same condition</strong> that is
later used as the abstraction, which ensures soundness (see discussion on
lingering threats to soundness in the <a href="rfcs/0009-function-contracts.html#future-possibilities">future</a> section)
and guarding against abstractions diverging from their checks.</p>
<h3 id="write-sets-and-havocking"><a class="header" href="#write-sets-and-havocking">Write Sets and Havocking</a></h3>
<p>Functions can have side effects on data reachable through mutable references or
pointers. To overapproximate all such modifications a function could apply to
pointed-to data, the verifier &quot;havocs&quot; those regions, essentially replacing
their content with non-deterministic values.</p>
<p>Let us consider a simple example of a <code>pop</code> method.</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    ...
  }
}
</code></pre>
<p>This function can, in theory, modify any memory behind <code>&amp;mut self</code>, so this is
what Kani will assume it does by default. It infers the &quot;write set&quot;, that is the
set of memory locations a function may modify, from the type of the function
arguments. As a result, any data pointed to by a mutable reference or pointer is
considered part of the write set<sup class="footnote-reference"><a href="#write-set-recursion">3</a></sup>. In addition, a static
analysis of the source code discovers any <code>static mut</code> variables the function or
it's dependencies reference and adds all pointed-to data to the write set also.</p>
<p>During havocking the verifier replaces all locations in the write set with
non-deterministic values. Kani emits a set of automatically generated
postconditions which encode the expectations from the Rust type system and
<code>assume</code>s them for the havocked locations to ensure they are valid. This
encompasses both limits as to what values are acceptable for a given type, such
as <code>char</code> or the possible values of an enum discriminator, as well as lifetime
constraints.</p>
<p>While the inferred write set is sound and enough for successful contract
checking<sup class="footnote-reference"><a href="#inferred-footprint">4</a></sup> in many cases this inference is too coarse
grained. In the case of <code>pop</code> every value in this vector will be made
non-deterministic.</p>
<p>To address this the proposal also adds a <code>modifies</code> and <code>frees</code> clause which
limits the scope of havocking. Both clauses represent an assertion that the
function will modify only the specified memory regions. Similar to
requires/ensures the verifier enforces the assertion in the checking stage to
ensure soundness. When the contract is used as an abstraction, the <code>modifies</code>
clause is used as the write set to havoc.</p>
<p>In our <code>pop</code> example the only modified memory location is the last element and
only if the vector was not already empty, which would be specified thusly.</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  #[modifies(if !self.is_empty() =&gt; (*self).buf.ptr.pointer.pointer[self.len])]
  #[modifies(if self.is_empty())]
  fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    ...
  }
}
</code></pre>
<p>The <code>#[modifies(when = CONDITION, targets = { MODIFIES_RANGE, ... })]</code> consists
of a <code>CONDITION</code> and zero or more, comma separated <code>MODIFIES_RANGE</code>s which are
essentially a place expression.</p>
<p>Place expressions describe a position in the abstract program memory. You may
think of it as what goes to the left of an assignment. They compose of the name
of one function argument (or static variable) and zero or more projections
(dereference <code>*</code>, field access <code>.x</code> and slice indexing <code>[1]</code><sup class="footnote-reference"><a href="#slice-exprs">5</a></sup>).</p>
<p>If no <code>when</code> is provided the condition defaults to <code>true</code>, meaning the modifies
ranges apply to all invocations of the function. If <code>targets</code> is omitted it
defaults to <code>{}</code>, e.g. an empty set of targets meaning under this condition the
function modifies no mutable memory.</p>
<p>Because place expressions are restricted to using projections only, Kani must
break Rusts <code>pub</code>/no-<code>pub</code> encapsulation here<sup class="footnote-reference"><a href="#assigns-encapsulation-breaking">6</a></sup>.
If need be we can reference fields that are usually hidden, without an error
from the compiler.</p>
<p>In addition to a place expression, a <code>MODIFIES_RANGE</code> can also be terminated
with more complex <em>slice</em> expressions as the last projection. This only applies
to <code>*mut</code> pointers to arrays. For instance this is needed for <code>Vec::truncate</code>
where all of the latter section of the allocation is assigned (dropped).</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  #[modifies(self.buf.ptr.pointer.pointer[len..])]
  fn truncate(&amp;mut self, len: usize) {
    ...
  }
}
</code></pre>
<p><code>[..]</code> denotes the entirety of an allocation, <code>[i..]</code>, <code>[..j]</code> and <code>[i..j]</code> are
ranges of pointer offsets<sup class="footnote-reference"><a href="#slice-exprs">5</a></sup>. The slice indices are offsets with sizing <code>T</code>, e.g.
in Rust <code>p[i..j]</code> would be equivalent to
<code>std::slice::from_raw_parts(p.offset(i), i - j)</code>. <code>i</code> must be smaller or equal
than <code>j</code>.</p>
<p>A <code>#[frees(when = CONDITION, targets = { PLACE, ... })]</code> clause works similarly
to <code>modifies</code> but denotes memory that is deallocated. Like <code>modifies</code> it applies
only to pointers but unlike modifies it does not admit slice syntax, only
place expressions, because the whole allocation has to be freed.</p>
<h3 id="history-expressions"><a class="header" href="#history-expressions">History Expressions</a></h3>
<p>Kani's contract language contains additional support to reason about changes of
mutable memory. One case where this is necessary is whenever <code>ensures</code> needs to
refer to state before the function call. By default variables in the ensures
clause are interpreted in the post-call state whereas history expressions are
interpreted in the pre-call state.</p>
<p>Returning to our <code>pop</code> function from before we may wish to describe in which
case the result is <code>Some</code>. However that depends on whether <code>self</code> is empty
<em>before</em> <code>pop</code> is called. To do this Kani provides the <code>old(EXPR)</code> pseudo
function (see <a href="rfcs/0009-function-contracts.html#open-questions">this section</a> about a discussion on naming),
which evaluates <code>EXPR</code> before the call (e.g. to <code>pop</code>) and makes the result
available to <code>ensures</code>. It is used like so:</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  #[kani::ensures(|result : &amp;Option&lt;T&gt;| old(self.is_empty()) || result.is_some())]
  fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    ...
  }
}
</code></pre>
<p><code>old</code> allows evaluating any Rust expression in the pre-call context, so long as
it is free of side-effects. See also <a href="rfcs/0009-function-contracts.html#changes-to-other-components">this
explanation</a>. The borrow checker enforces that the
mutations performed by e.g. <code>pop</code> cannot be observed by the history expression, as
that would defeat the purpose. If you wish to return borrowed content from
<code>old</code>, make a copy instead (using e.g. <code>clone()</code>).</p>
<p>Note also that <code>old</code> is syntax, not a function and implemented as an extraction
and lifting during code generation. It can reference e.g. <code>pop</code>'s arguments but
not local variables. Compare the following</p>
<p><strong>Invalid ❌:</strong> <code>#[kani::ensures(|result : &amp;Option&lt;T&gt;| { let x = self.is_empty(); old(x) } || result.is_some())]</code></br>
<strong>Valid ✅:</strong> <code>#[kani::ensures(|result : &amp;Option&lt;T&gt;| old({ let x = self.is_empty(); x }) || result.is_some())]</code></p>
<p>And it will only be recognized as <code>old(...)</code>, not as <code>let old1 = old; old1(...)</code> etc.</p>
<h3 id="workflow-and-attribute-constraints-overview"><a class="header" href="#workflow-and-attribute-constraints-overview">Workflow and Attribute Constraints Overview</a></h3>
<ol>
<li>By default <code>kani</code> or <code>cargo kani</code> first verifies all contract harnesses
(<code>proof_for_contract</code>) reachable from the file or in the local workspace
respectively.</li>
<li>Each contract (from the local
crate<sup class="footnote-reference"><a href="#external-contract-checking-expectations">7</a></sup>) that is used in a
<code>stub_verified</code> is required to have at least one associated contract harness.
Kani reports any missing contract harnesses as errors.</li>
<li>Kani verifies all regular harnesses <em>if</em> their <code>stub_verified</code> contracts
passed step 1 and 2.</li>
</ol>
<p>When specific harnesses are selected (with <code>--harness</code>) contracts are not
verified.</p>
<p>Kani reports a compile time error if any of the following constraints are violated:</p>
<ul>
<li>
<p>A function may have any number of <code>requires</code>, <code>ensures</code>, <code>modifies</code> and <code>frees</code>
attributes. Any function with at least one such annotation is considered as
&quot;having a contract&quot;.</p>
<p>Harnesses (general or for contract checking) may not have any such annotation.</p>
</li>
<li>
<p>A harness may have up to one <code>proof_for_contract(TARGET)</code> annotation where <code>TARGET</code> must
&quot;have a contract&quot;. One or more <code>proof_for_contract</code> harnesses may have the
same <code>TARGET</code>. </p>
<p>A <code>proof_for_contract</code> harness may use any harness attributes, including
<code>stub</code> and <code>stub_verified</code>, though the <code>TARGET</code> may not appear in either. </p>
</li>
<li>
<p>Kani checks that <code>TARGET</code> is reachable from the <code>proof_for_contract</code> harness,
but it does not warn if abstracted functions use <code>TARGET</code><sup class="footnote-reference"><a href="#stubcheck">8</a></sup>.</p>
</li>
<li>
<p>A <code>proof_for_contract</code> function may not have the <code>kani::proof</code> attribute (it
is already implied by <code>proof_for_contract</code>).</p>
</li>
<li>
<p>A harness may have multiple <code>stub_verified(TARGET)</code> attributes. Each <code>TARGET</code>
must &quot;have a contract&quot;. No <code>TARGET</code> may appear twice. Each local <code>TARGET</code> is
expected to have at least one associated <code>proof_for_contract</code> harness which
passes verification, see also the discussion on when to check contracts in
<a href="rfcs/0009-function-contracts.html#open-questions">open questions</a>.</p>
</li>
<li>
<p>Harnesses may combine <code>stub(S_TARGET, ..)</code> and <code>stub_verified(V_TARGET)</code>
annotations, though no target may occur in <code>S_TARGET</code>s and <code>V_TARGET</code>s
simultaneously.</p>
</li>
<li>
<p>For mutually recursive functions using <code>stub_verified</code>, Kani will check their
contracts in non-deterministic order and assume each time the respective other
check succeeded.</p>
</li>
</ul>
<h2 id="detailed-design-8"><a class="header" href="#detailed-design-8">Detailed Design</a></h2>
<!-- For the implementors or the hackers -->
<p>Kani implements the functionality of function contracts in three places.</p>
<ol>
<li>Code generation in the <code>requires</code> and <code>ensures</code> macros (<code>kani_macros</code>).</li>
<li>GOTO level contracts using CBMC's contract language generated in
<code>kani-compiler</code> for <code>modifies</code> clauses.</li>
<li>Dependencies and ordering among harnesses in <code>kani-driver</code> to enforce
contract checking before replacement. Also plumbing between compiler and
driver for enforcement of assigns clauses.</li>
</ol>
<h3 id="code-generation-in-kani_macros"><a class="header" href="#code-generation-in-kani_macros">Code generation in <code>kani_macros</code></a></h3>
<p>The <code>requires</code> and <code>ensures</code> macros perform code generation in the macro,
creating a <code>check</code> and a <code>replace</code> function which use <code>assert</code> and <code>assume</code> as
described in the <a href="rfcs/0009-function-contracts.html#user-experience">user experience</a> section. Both are attached
to the function they are checking/replacing by  <code>kanitool::checked_with</code> and
<code>kanitool::replaced_with</code> attributes respectively. See also the
<a href="rfcs/0009-function-contracts.html#rationale-and-alternatives">discussion</a> about why we decided to generate check
and replace functions like this.</p>
<p>The code generation in the macros is straightforward, save two aspects: <code>old</code>
and the borrow checker.</p>
<p>The special <code>old</code> builtin function is implemented as an AST rewrite. Consider
the below example:</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  #[kani::ensures(|result : &amp;Option&lt;T&gt;| self.is_empty() || self.len() == old(self.len()) - 1)]
  fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    ...
  }
}
</code></pre>
<p>The <code>ensures</code> macro performs an AST rewrite consisting of an extraction of the
expressions in <code>old</code> and a replacement with a fresh local variable, creating the
following:</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  fn check_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    let old_1 = self.len();
    let result_kani_internal = Self::pop(self);
    kani::assert((|result : &amp;Option&lt;T&gt;| self.is_empty() || self.len() == old_1 - 1)(result_kani_internal))
  }
}
</code></pre>
<p>Nested invocations of <code>old</code> are prohibited (Kani throws an error) and the
expression inside may only refer to the function arguments and not other local
variables in the contract (Rust will report those variables as not being in
scope). </p>
<p>The borrow checker also ensures for us that none of the temporary variables
borrow in a way that would be able to observe the modification in <code>pop</code> which
would occur for instance if the user wrote <code>old(self)</code>. Instead of borrowing
copies should be created (e.g. <code>old(self.clone())</code>). This is only enforced for
safe Rust though.</p>
<p>The second part relevant for the implementation is how we deal with the borrow
checker for postconditions. They reference the arguments of the function after
the call which is problematic if part of an input is borrowed mutably in the
return value. For instance the <code>Vec::split_at_mut</code> function does this and a
sensible contract for it might look as follows:</p>
<pre><code class="language-rs">impl&lt;T&gt; Vec&lt;T&gt; {
  #[ensures(|result : &amp;(&amp;mut [T], &amp;mut [T])| self.len() == result.0.len() + result.1.len())]
  fn split_at_mut(&amp;mut self, i: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
    ...
  }
}
</code></pre>
<p>This contract refers simultaneously to <code>self</code> and the result. Since the method
however borrows <code>self</code> mutably, it would no longer be accessible in the
postcondition. To work around this we strategically break the borrowing rules
using a new hidden builtin <code>kani::unchecked_deref</code> with the type signature <code>for &lt;T&gt; fn (&amp;T) -&gt; T</code> which is essentially a C-style dereference operation. Breaking
the borrow checker like this is safe for 2 reasons:</p>
<ol>
<li>Postconditions are not allowed perform mutation and</li>
<li>Post conditions are of type <code>bool</code>, meaning they cannot leak references to
the arguments and cause the race conditions the Rust type system tries to
prevent.</li>
</ol>
<p>The &quot;copies&quot; of arguments created by <code>unsafe_deref</code> are stored as fresh local
variables and their occurrence in the postcondition is renamed. In addition a
<code>mem::forget</code> is emitted for each copy to avoid a double free.</p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Kani verifies contracts for recursive functions inductively. Reentry of the
function is detected with a function-specific static variable. Upon detecting
reentry we use the replacement of the contract instead of the function body.</p>
<p>Kani generates an additional wrapper around the function to add the detection.
The additional wrapper is there so we can place the <code>modifies</code> contract on
<code>check_pop</code> and <code>replace_pop</code> instead of <code>recursion_wrapper</code> which prevents CBMC
from triggering its recursion induction as this would skip our replacement checks.</p>
<pre><code class="language-rs">#[checked_with = &quot;recursion_wrapper&quot;]
#[replaced_with = &quot;replace_pop&quot;]
fn pop(&amp;mut self) { ... }

fn check_pop(&amp;mut self) { ... }

fn replace_pop(&amp;mut self) { ... }

fn recursion_wrapper(&amp;mut self) { 
  static mut IS_ENTERED: bool = false;

  if unsafe { IS_ENTERED } {
    replace_pop(self)
  } else {
    unsafe { IS_ENTERED = true; }
    let result = check_pop(self);
    unsafe { IS_ENTERED = false; }
    result
  };
}
</code></pre>
<p>Note that this is insufficient to verify all types of recursive functions, as
the contract specification language has no support for inductive lemmas (for
instance in <a href="https://frama-c.com/download/acsl.pdf">ACSL</a> section 2.6.3
&quot;inductive predicates&quot;). Inductive lemmas are usually needed for recursive
data structures.</p>
<h3 id="changes-to-other-components"><a class="header" href="#changes-to-other-components">Changes to Other Components</a></h3>
<p>Contract enforcement and replacement (<code>kani::proof_for_contract(f)</code>,
<code>kani::stub_verified(f)</code>) both dispatch to the <strong>stubbing logic</strong>, stubbing <code>f</code>
with the generated check and replace function respectively. If <code>f</code> has no
contract, Kani throws an error.</p>
<p>For <strong>write sets</strong> Kani relies on CBMC. <code>modifies</code> clauses (whether derived from
types or from explicit clauses) are emitted from the compiler as GOTO contracts
in the artifact. Then the driver invokes <code>goto-instrument</code> with the name of the
GOTO-level function names to enforce or replace the memory contracts. The
compiler communicates the names of the function via harness metadata.</p>
<p>Code used in contracts is required to be <strong>side effect</strong> free which means it
must not perform I/O, mutate memory (<code>&amp;mut</code> vars and such) or (de)allocate heap
memory. This is enforced in two layers. First with an MIR traversal over all
code reachable from a contract expression. An error is thrown if known
side-effecting actions are performed such as <code>ptr::write</code>, <code>malloc</code>, <code>free</code> or
functions which we cannot check, such as e.g. <code>extern &quot;C&quot;</code>, with the exception
of known side effect free functions in e.g. the standard library.</p>
<!-- 
This is the technical portion of the RFC. Please provide high level details of the implementation you have in mind:

- What are the main components that will be modified? (E.g.: changes to `kani-compiler`, `kani-driver`, metadata,
  installation...)
- How will they be modified? Any changes to how these components communicate?
- Will this require any new dependency?
- What corner cases do you anticipate? 
-->
<h2 id="rationale-and-alternatives-6"><a class="header" href="#rationale-and-alternatives-6">Rationale and alternatives</a></h2>
<!-- For Developers -->
<!-- `old` discussion here -->
<p>We developed the <code>old</code> contract for history expressions via understanding it as a <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">modality</a> originating from <a href="https://www.sciencedirect.com/science/article/pii/0890540191900524">Moggi 1991</a>.
The <code>old</code> monad links the &quot;language of the past&quot; to the &quot;language of the present&quot;.
Implementing the full generality of the monad is rather difficult, so we focus on a particular usage of the monad.</p>
<p>We have an external syntax representation which is what the user inputs. We then parse this and logically manipulate it as a monad, prefixing all the <code>bind</code> operations. We then output the final compiled macro output as Rust code.</p>
<p>In particular, if we have an ensures statement like</p>
<pre><code class="language-rust">#[kani::ensures(old(*ptr)+1==*ptr)]
</code></pre>
<p>Then we comprehend this as syntax for the statement (not within Rust)</p>
<pre><code>bind (*ptr : O(u32)) (|remember : u32| remember + 1 == *ptr)
</code></pre>
<p>Here, the <code>O(u32)</code> is taking the type of the past <code>u32</code> and converting it into a type in the present <code>O(u32)</code> while the bind operation lets you use the value of the past <code>u32</code> to express a type in the present <code>bool</code>.</p>
<p>This then gets compiled to (within Rust)</p>
<pre><code class="language-rust">let remember = *ptr;
let result = ...;
kani::assert(remember + 1 == *ptr)
</code></pre>
<p>This means that the underlying principle of the monad is there, but external syntax appears to be less like a monad because otherwise it would be too difficult to implement, and the user most likely only cares about this particular construction of prefixing all the <code>bind</code> operations.</p>
<p>This construction requires that <code>old</code> expressions are closed with resprect to the input parameters. This is due to the lifting into the prefixed <code>bind</code> operations.</p>
<p>A major drawback is that eta expansion fails. If we eta expand a function f, it becomes |x|f(x). Note that eta expansions guarantee that the original f and the |x|f(x) are equivalent which makes a lot of sense since you’re just calling the same function. However, we have that <code>old(y)</code> is not equivalent to <code>(|x|old(x))(y)</code>. <code>y</code> is a closed expression, so the first statement works. <code>x</code> is a bound variable, so it is an open expression, so compilation will fail.</p>
<p>The reason for this restriction is that the user will most likely only want to use this particular prefixed <code>bind</code> structure for their code, so exposing the concept of monads to the user level would only confuse the user. It is also simpler from an implementation perspective to limit the monad to this particular usage.</p>
<p>As for nested old, such as <code>old(old(*ptr)+*ptr)</code>, it is reasonable to interpret this as syntax representing</p>
<pre><code>bind (bind(*ptr)(|remember_1| remember_1 + *ptr)) (|remember_0| ...)
</code></pre>
<p>which compiles to</p>
<pre><code class="language-rust">let remember_1 = *ptr;
let remember_0 = remember_1 + *ptr;
let result = ...;
...
</code></pre>
<p>so the restriction is just a matter of there not being implementation support for this kind of statement rather than the theory itself. It is not particularly useful to implement this because we claim that there should be no effectful computation within the contracts, so you can substitute the <code>remember_1</code> into the second line without worrying about the effects. Hence, we opt for simply restricting this behavior instead of implementing it. (Note: it can be implemented by changing <code>denier.visit_expr_mut(e);</code> into <code>self.visit_expr_mut(e);</code>)</p>
<!-- 
- What are the pros and cons of this design?
- What is the impact of not doing this?
- What other designs have you considered? Why didn't you choose them? 
-->
<h3 id="kani-side-implementation-vs-cbmc"><a class="header" href="#kani-side-implementation-vs-cbmc">Kani-side implementation vs CBMC</a></h3>
<p>Instead of generating check and replace functions in Kani, we could use the contract instrumentation provided by CBMC.</p>
<p>We tried this earlier but came up short, because it is difficult to implement,
while supporting arbitrary Rust syntax. We exported the conditions into
functions so that Rust would do the parsing/type checking/lowering for us and
then call the lowered function in the CBMC contract. </p>
<p>The trouble is that CBMC's <code>old</code> is only supported directly in the contract, not
in functions called from the contract. This means we either need to inline the
contract function body, which is brittle in the presence of control flow, or we
must extract the <code>old</code> expressions, evaluate them in the contract directly and
pass the results to the check function. However this means we must restrict the
expressions in <code>old</code>, because we now need to lower those by hand and even if we
could let <code>rustc</code> do it, CBMC's <code>old</code> has no support for function calls in its
argument expression.</p>
<h3 id="expanding-all-contract-macros-at-the-same-time"><a class="header" href="#expanding-all-contract-macros-at-the-same-time">Expanding all contract macros at the same time</a></h3>
<p>Instead of expanding contract macros one-at-a-time and layering the checks we
could expand all subsequent one's with the outermost one in one go.</p>
<p>This is however brittle with respect to renaming. If a user does <code>use kani::requires as my_requires</code> and then does multiple
<code>#[my_requires(condition)]</code> macro would not collect them properly since it can
only match syntactically and it does not know about the <code>use</code> and neither can we
restrict this kind of use or warn the user. By contrast, the collection with
<code>kanitool::checked_with</code> is safe, because that attribute is generated by our
macro itself, so we can rely on the fact that it uses the canonical
representation.</p>
<h3 id="generating-nested-functions-instead-of-siblings"><a class="header" href="#generating-nested-functions-instead-of-siblings">Generating nested functions instead of siblings</a></h3>
<p>Instead of generating the <code>check</code> and <code>replace</code> functions as siblings to the
contracted function we could nest them like so</p>
<pre><code class="language-rs">fn my_div(dividend: u32, divisor: u32) -&gt; u32 {
  fn my_div_check_5e3713(dividend: u32, divisor: u32) -&gt; u32 {
    ...
  }
  ...
}
</code></pre>
<p>This could be beneficial if we want to be able to allow contracts on trait impl
items, in which case generating sibling functions is not allowed. On the other
hand this makes it harder to implement contracts on <em>trait definitions</em>,
because there is no body available which we could nest the function into.
Ultimately we may require both so that we can support both.</p>
<p>What is required to make this work is an additional pass over the condition that
replaces every <code>self</code> with a fresh identifier that now becomes the first
argument of the function. In addition there are open questions as to how to
resolve the nested name inside the compiler.</p>
<h3 id="explicit-command-line-checkingsubstitution-vs-attributes"><a class="header" href="#explicit-command-line-checkingsubstitution-vs-attributes">Explicit command line checking/substitution vs attributes:</a></h3>
<p>Instead of
adding a new special <code>proof_for_contact</code> attributes we could have instead done:</p>
<ol>
<li><strong>Check contracts on the command line</strong> like CBMC does. This makes contract
checking a separate <code>kani</code> invocation with something like a
<code>--check-contract</code> flag that directs the system to instrument the function.
This is a very flexible design, but also easily used incorrectly.
Specifically nothing in the source indicates which harnesses are supposed
to be used for which contract, users must remember to invoke the check and
are also responsible for ensuring they really do verify <em>all</em> contacts they
will later be replacing and lastly.</li>
<li><strong>Check contracts with a <code>#[kani::proof]</code> harness.</strong> This would have used
e.g. a <code>#[kani::for_contract]</code> attributes on a <code>#[kani::proof]</code>. Since
<code>#[kani::for_contract]</code> is <em>only</em> valid on a proof, we decided to just
imply it and save the user some headache. Contract checking harnesses are
not meant to be reused for other purposes anyway and if the user <em>really</em>
wants to the can just factor out the actual contents of the harness to
reuse it.</li>
</ol>
<h3 id="polymorphism-during-contract-checking"><a class="header" href="#polymorphism-during-contract-checking">Polymorphism during contract checking</a></h3>
<p>A current limitation with how contracts are enforced means that if the target of
a <code>proof_for_contract</code> is polymorphic, only one monomorphization is permitted to
occur in the harness. This does not limit the target to a single occurrence,
<em>but</em> to a single instantiation of its generic parameters.</p>
<p>This is because we rely on CBMC for enforcing the <code>modifies</code> contract. At the
GOTO level all monomorphized instances are distinct functions <em>and</em> CBMC only
allows checking one function contract at a time, hence this restriction.</p>
<h3 id="user-supplied-harnesses"><a class="header" href="#user-supplied-harnesses">User supplied harnesses</a></h3>
<p>We make the user supply the harnesses for checking contracts. This is our major
source of unsoundness, if corner cases are not adequately covered. Having Kani
generate the harnesses automatically is a non-trivial task (because heaps are
hard) and will be the subject of <a href="rfcs/0009-function-contracts.html#future-possibilities">future improvements</a>. </p>
<p>In limited cases we could generate harnesses, for instance if only bounded types
(integers, booleans, enums, tuples, structs, references and their combinations)
were used. We could restrict the use of contracts to cases where only such types
are involved in the function inputs and outputs, however this would drastically
limit the applicability, as even simple heap data structures such as <code>Vec</code>,
<code>String</code> and even <code>&amp;[T]</code> and <code>&amp;str</code> (slices) would be out of scope. These data
structures however are ubiquitous and users can avoid the unsoundness with
relative confidence by overprovisioning (generating inputs that are several
times larger than what they expect the function will touch).</p>
<h2 id="open-questions-9"><a class="header" href="#open-questions-9">Open questions</a></h2>
<!-- For Developers -->
<ul>
<li>
<p>Returning <strong><code>kani::any()</code> in a replacement isn't great</strong>, because it wouldn't work
for references as they can't have an <code>Arbitrary</code> implementation. Plus the
soundness then relies on a correct implementation of <code>Arbitrary</code>. Instead it
may be better to allow for the user to specify type invariants which can the
be used to generate correct values in replacement but also be checked as part
of the contract checking.</p>
</li>
<li>
<p>Making result special. Should we use special syntax here like <code>@result</code> or
<code>kani::result()</code>, though with the latter I worry that people may get confused
because it is syntactic and not subject to usual <code>use</code> renaming and import
semantics. Alternatively we can let the user pick the name with an additional
argument to <code>ensures</code>, e.g. <code>ensures(my_result_var, CONDITION)</code></p>
<p>Similar concerns apply to <code>old</code>, which may be more appropriate to be special
syntax, e.g. <code>@old</code>.</p>
<p>See <a href="https://github.com/model-checking/kani/issues/2597">#2597</a></p>
</li>
<li>
<p>How to <strong>check the right contracts at the right time</strong>. By default <code>kani</code> and
<code>cargo kani</code> check all contracts in a crate/workspace. This represents the
safest option for the user but may be too costly in some cases.</p>
<p>The user should be provided with options to disable contract checking for the
sake of efficiency. Such options may look like this:</p>
<ul>
<li><strong>By default</strong> (<code>kani</code>/<code>cargo kani</code>) all local contracts are checked,
harnesses are only checked if the contracts they depend on succeeded their check.</li>
<li><strong>With harness selection</strong> (<code>--harness</code>) only those contracts which the
selected harnesses depend on are checked.</li>
<li><strong>For high assurance</strong> passing a <code>--paranoid</code> flag also checks contracts for
dependencies (other crates) when they are used in abstractions.</li>
<li><strong>Per harness</strong> the users can disable the checking for specific contracts
via attribute, like <code>#[stub_verified(TARGET, trusted)]</code> or
<code>#[stub_unverified(TARGET)]</code>. This also plays nicely with <code>cfg_attr</code>.</li>
<li><strong>On the command line</strong> users can similarly disable contract checks by
passing (multiple times) <code>--trusted TARGET</code> to skip checking those
contracts.</li>
<li><strong>The bold</strong> (or naïve) user can skip all contracts with <code>--all-trusted</code>.</li>
<li><strong>For the lawyer</strong> that is only interested in checking contracts and nothing
else a <code>--litigate</code> flag checks only contract harnesses.</li>
</ul>
<p>Aside: I'm obviously having some fun here with the names, happy to change,
it's really just about the semantics.</p>
</li>
<li>
<p><strong>Can <code>old</code> accidentally break scope?</strong> The <code>old</code> function cannot reference local
variables. For instance <code>#[ensures({let x = ...; old(x)})]</code> cannot work as an
AST rewrite because the expression in <code>old</code> is lifted out of it's context into
one where the only bound variables are the function arguments (see also
<a href="rfcs/0009-function-contracts.html#history-expressions">history expressions</a>). In most cases this will be a
compiler error complaining that <code>x</code> is unbound, however it is possible that
<em>if</em> there is also a function argument <code>x</code>, then it may silently succeed the
code generation but confusingly fail verification. For instance <code>#[ensures({ let x = 1; old(x) == x })]</code> on a function that has an argument named <code>x</code> would
<em>not</em> hold.</p>
<p>To handle this correctly we would need an extra check that detects if <code>old</code>
references local variables. That would also enable us to provide a better
error message than the default &quot;cannot find value <code>x</code> in this scope&quot;.</p>
</li>
<li>
<p><strong>Can panicking be expected behavior?</strong> Usually preconditions are used to rule
out panics but it is conceivable that a user would want to specify that a
function panics under certain conditions. Specifying this would require an
extension to the current interface.</p>
</li>
<li>
<p><strong>UB checking.</strong> With unsafe rust it is possible to break the type system
guarantees in Rust without causing immediate errors. Contracts must be
cognizant of this and enforce the guarantees as part of the contract <em>or</em>
require users to explicitly defer such checks to use sites. The latter case
requires dedicated support because the potential UB must be reflected in the
havoc.</p>
</li>
<li>
<p><strong><code>modifies</code> clauses over patterns.</strong> Modifies clauses mention values bound in
the function header and as a user I would expect that if I use a pattern in
the function header then I can use the names bound in that pattern as base
variables in the <code>modifies</code> clause. However <code>modifies</code> clauses are implemented
as <code>assigns</code> clauses in CBMC which does not have a notion of function header
patterns. Thus it is necessary to project any <code>modifies</code> ranges deeper by the
fields used in the matched pattern.</p>
</li>
</ul>
<!-- 
- Is there any part of the design that you expect to resolve through the RFC process?
- What kind of user feedback do you expect to gather before stabilization? How will this impact your design? 
-->
<h2 id="future-possibilities-8"><a class="header" href="#future-possibilities-8">Future possibilities</a></h2>
<!-- For Developers -->
<ul>
<li>
<p><strong>Quantifiers:</strong> Quantifiers are like logic-level loops and a powerful
reasoning helper. CBMC has support for both <code>exists</code> and <code>forall</code>, but the
code generation is difficult. The most ergonomic and easy way to implement
quantifiers on the Rust side is as higher-order functions taking <code>Fn(T) -&gt; bool</code>, where <code>T</code> is some arbitrary type that can be quantified over. This
interface is familiar to developers, but the code generation is tricky, as
CBMC level quantifiers only allow certain kinds of expressions. This
necessitates a rewrite of the <code>Fn</code> closure to a compliant expression.</p>
</li>
<li>
<p>Letting the user supply the <strong>harnesses for checking contracts</strong> is a source of
unsoundness, if corner cases are not adequately covered. Ideally Kani would
generate the check harness automatically, but this is difficult both because
heap data structures are potentially infinite, and also because it must observe
user-level type invariants.</p>
<p>A complete solution for this is not known to us but there are ongoing
investigations into harness generation mechanisms in CBMC.</p>
<p>Function inputs that are non-inductive could be created from the type as the
safe Rust type constraints describe a finite space.</p>
<p>For dealing with pointers one applicable mechanism could be <em>memory
predicates</em> to declaratively describe the state of the heap both before and
after the function call. </p>
<p>In CBMC's implementation memory predicates are part of the pre/postconditions.
This does not easily translate to Kani, since we handle pre/postconditions
manually and mainly in proc-macros. There are multiple ways to bridge this
gap, perhaps the easiest being to add memory predicates <em>separately</em> to Kani
instead of as part of pre/postconditions, so they can be handled by forwarding
them to CBMC. However this is also tricky, because memory predicates are used
to describe pointers and pointers only. Meaning that if they are encapsulated
in a structure (such as <code>Vec</code> or <code>RefCell</code>) there is no way of specifying the
target of the predicate without breaking encapsulation (similar to
<code>modifies</code>). In addition there are limitations also on the pointer predicates
in CBMC itself. For instance they cannot be combined with quantifiers.</p>
<p>A better solution would be for the data structure to declare its own
invariants at definition site which are automatically swapped in on every
contract that uses this type.</p>
</li>
<li>
<p>What about mutable trait inputs (wrt memory access patters), e.g. a <code>mut impl AccessMe</code></p>
</li>
<li>
<p><strong>Trait contracts:</strong> Our proposal could be extended easily to handle simple
trait contracts. The macros would generate new trait methods with default
implementations, similar to the functions it generates today. Using sealed
types we can prevent the user from overwriting the generated contract methods.
Contracts for the trait and contracts on it's <code>impl</code>s are combined by abstracting
the original method depending on context. The occurrence inside the contract
generated from the trait method is replaced by the <code>impl</code> contract. Any other
occurrence is replaced by the just altered trait method contract.</p>
</li>
<li>
<p><strong>Cross Session Verification Caching:</strong> This proposal focuses on scalability
benefits within a single verification session, but those verification results
could be cached across sessions and speed up verification for large projects
using contacts in the future.</p>
</li>
<li>
<p><strong>Inductive Reasoning:</strong> Describing recursive functions can require that the
contract also recurse, describing a fixpoint logic. This is needed for
instance for linked data structures like linked lists or trees. Consider for
instance a reachability predicate for a linked list:</p>
<pre><code class="language-rs">struct LL&lt;T&gt; { head: T, next: *const LL&lt;T&gt; }

fn reachable(list: &amp;LL&lt;T&gt;, t: &amp;T) -&gt; bool {
    list.head == t
    || unsafe { next.as_ref() }.map_or(false, |p| reachable(p, t))
}

</code></pre>
</li>
<li>
<p><strong>Compositional Contracts:</strong> The proposal in this document lacks a
comprehensive handling of type parameters. Contract checking harnesses require
monomorphization. However this means the contract is only checked against a
finite number of instantiations of any type parameter (at most as many as
contract checking harnesses were defined). There is nothing preventing the
user from using different instantiations of the function's type parameters.</p>
<p>A function (<code>f()</code>) can only interact with its type parameters <code>P</code> through the
traits (<code>T</code>) they are constrained over. We can require <code>T</code> to carry contracts
on each method <code>T::m()</code>. During checking we can use a synthetic type that
abstracts <code>T::m()</code> with its contract. This way we check <code>f()</code> against <code>T</code>s
contract. Then we later abstract <code>f()</code> we can ensure any instantiations of <code>P</code>
have passed verification of the contract of <code>T::m()</code>. This makes the
substitution safe even if the particular type has not been used in a checking
harness.</p>
<p>For higher order functions this gets a bit more tricky, as closures are ad-hoc
defined types. Here the contract for the closure could be attached to <code>f()</code>
and then checked for each closure that may be provided. However this does not
work so long as the user has to provide the harnesses, as they cannot recreate
the closure type.</p>
</li>
</ul>
<hr />
<div class="footnote-definition" id="gate"><sup class="footnote-definition-label">1</sup>
<p>Enforced gates means all uses of constructs (functions, annotations,
macros) in this RFC are an error.</p>
</div>
<div class="footnote-definition" id="simple-unsoundness"><sup class="footnote-definition-label">2</sup>
<p>The main remaining threat to soundness in the use of
contracts, as defined in this proposal, is the reliance on user-supplied
harnesses for contract checking (explained in item 2 of <a href="rfcs/0009-function-contracts.html#user-experience">user
experience</a>). A more thorough discussion on the dangers
and potential remedies can be found in the <a href="rfcs/0009-function-contracts.html#future-possibilities">future</a>
section.</p>
</div>
<div class="footnote-definition" id="write-set-recursion"><sup class="footnote-definition-label">3</sup>
<p>For inductively defined types the write set inference
will only add the first &quot;layer&quot; to the write set. If you wish to modify
deeper layers of a recursive type an explicit <code>modifies</code> clause is required.</p>
</div>
<div class="footnote-definition" id="inferred-footprint"><sup class="footnote-definition-label">4</sup>
<p>While inferred memory footprints are sound for both safe
and unsafe Rust certain features in unsafe rust (e.g. <code>RefCell</code>) get
inferred incorrectly and will lead to a failing contract check.</p>
</div>
<div class="footnote-definition" id="slice-exprs"><sup class="footnote-definition-label">5</sup>
<p>Slice indices can be place expressions referencing function
arguments, constants and integer arithmetic expressions. Take for example
this <code>Vec</code> method (places simplified vs. actual implementation in <code>std</code>):
<code>fn truncate(&amp;mut self, len: usize)</code>. A relatively precise contract for this
method can be achieved with slice indices like so:
<code>#[modifies(self.buf[len..self.len], self.len)]</code></p>
</div>
<div class="footnote-definition" id="assigns-encapsulation-breaking"><sup class="footnote-definition-label">6</sup>
<p>Breaking the <code>pub</code> encapsulation has
unfortunate side effects because it means the contract depends on non-public
elements which are not expected to be stable and can drastically change even
in minor versions. For instance if your project depends on crate <code>a</code> which
in turn depends on crate <code>b</code>, and <code>a::foo</code> has a contract that takes as
input a pointer data structure <code>b::Bar</code> then <code>a::foo</code>s <code>assigns</code> contract
must reference internal fields of <code>b::Bar</code>. Say your project depends on the
<em>replacement</em> of <code>a::foo</code>, if <code>b</code> changes the internal representation of
<code>Bar</code> in a minor version update cargo could bump your version of <code>b</code>,
breaking the contract of <code>a::foo</code> (it now crashes because it e.g. references
non-existent fields).
You cannot easily update the contract for <code>a::foo</code>, since it is a
third-party crate; in fact even the author of <code>a</code> could not properly update
to the new contract since their old version specification would still admit
the new, broken version of <code>b</code>. They would have to yank the old version and
explicitly nail down the exact minor version of <code>b</code> which defeats the whole
purpose of semantic versioning.</p>
</div>
<div class="footnote-definition" id="external-contract-checking-expectations"><sup class="footnote-definition-label">7</sup>
<p>Contracts for functions from
external crates (crates from outside the workspace, which is not quite the
definition of <code>extern crate</code> in Rust) are not checked by default. The
expectation is that the library author providing the contract has performed
this check. See also <a href="rfcs/0009-function-contracts.html#open-questions">open question</a> for a discussion on
defaults and checking external contracts.</p>
</div>
<div class="footnote-definition" id="stubcheck"><sup class="footnote-definition-label">8</sup>
<p>Kani cannot report the occurrence of a contract function to check
in abstracted functions as errors, because the mechanism is needed to verify
mutually recursive functions.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Quantifiers</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2546">#2546</a> and <a href="https://github.com/model-checking/kani/issues/836">#836</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/">#</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 1.0</li>
</ul>
<hr />
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Quantifiers are logical operators that allow users to express that a property or condition applies to some or all objects within a given domain.</p>
<h2 id="user-impact-10"><a class="header" href="#user-impact-10">User Impact</a></h2>
<p>There are two primary quantifiers: the existential quantifier (∃) and the universal quantifier (∀).</p>
<ol>
<li>
<p>The existential quantifier (∃): represents the statement &quot;there exists.&quot; We use to express that there is at least one object in the domain that satisfies a given condition. For example, &quot;∃x P(x)&quot; means &quot;there exists a value x such that P(x) is true.&quot;</p>
</li>
<li>
<p>The universal quantifier (∀): represents the statement &quot;for all&quot; or &quot;for every.&quot; We use it to express that a given condition is true for every object in the domain. For example, &quot;∀x P(x)&quot; means &quot;for every value x, P(x) is true.&quot;</p>
</li>
</ol>
<p>Rather than exhaustively listing all elements in a domain, quantifiers enable users to make statements about the entire domain at once. This compact representation is crucial when dealing with large or unbounded inputs. Quantifiers also facilitate abstraction and generalization of properties. Instead of specifying properties for specific instances, quantified properties can capture general patterns and behaviors that hold across different objects in a domain. Additionally, by replacing loops in the specification with quantifiers, Kani can encode the properties more efficiently within the specified bounds, making the verification process more manageable and computationally feasible.</p>
<p>This new feature doesn't introduce any breaking changes to users. It will only allow them to write properties using the existential (∃) and universal (∀) quantifiers.</p>
<h2 id="user-experience-10"><a class="header" href="#user-experience-10">User Experience</a></h2>
<p>The syntax of existential (i.e., <code>kani::exists</code>) and universal (i.e., <code>kani::forall</code>) quantifiers are:</p>
<pre><code class="language-rust">kani::exists(|&lt;var&gt;: &lt;type&gt; [in (&lt;range-expr&gt;)] | &lt;boolean-expression&gt;)
kani::forall(|&lt;var&gt;: &lt;type&gt; [in (&lt;range-expr&gt;)] | &lt;boolean-expression&gt;)
</code></pre>
<p>If <code>&lt;range-expr&gt;</code> is not provided, we assume <code>&lt;var&gt;</code> can range over all possible values of the given <code>&lt;type&gt;</code> (i.e., syntactic sugar for full range <code>|&lt;var&gt;: &lt;type&gt; as .. |</code>). CBMC's SAT backend only supports bounded quantification under <strong>constant</strong> lower and upper bounds (for more details, see the <a href="https://diffblue.github.io/cbmc/contracts-quantifiers.html">documentation for quantifiers in CBMC</a>). The SMT backend, on the other hand, supports arbitrary Boolean expressions. In any case, <code>&lt;boolean-expression&gt;</code> should not have side effects, as the purpose of quantifiers is to assert a condition over a domain of objects without altering the state.</p>
<p>Consider the following example adapted from the documentation for the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.from_raw_parts">from_raw_parts</a> function:</p>
<pre><code class="language-rust">use std::mem;

#[kani::proof]
fn main() {
    let v = vec![kani::any::&lt;usize&gt;(); 100];

    // Prevent running `v`'s destructor so we are in complete control
    // of the allocation.
    let mut v = mem::ManuallyDrop::new(v);

    // Pull out the various important pieces of information about `v`
    let p = v.as_mut_ptr();
    let len = v.len();
    let cap = v.capacity();

    unsafe {
        // Overwrite memory
        for i in 0..len {
            *p.add(i) += 1;
        }

        // Put everything back together into a Vec
        let rebuilt = Vec::from_raw_parts(p, len, cap);
    }
}
</code></pre>
<p>Given the <code>v</code> vector has non-deterministic values, there are potential arithmetic overflows that might happen in the for loop. So we need to constrain all values of the array. We may also want to check all values of <code>rebuilt</code> after the operation. Without quantifiers, we might be tempted to use loops as follows:</p>
<pre><code class="language-rust">use std::mem;

#[kani::proof]
fn main() {
    let original_v = vec![kani::any::&lt;usize&gt;(); 100];
    let v = original_v.clone();
    for i in 0..v.len() {
        kani::assume(v[i] &lt; 5);
    }

    // Prevent running `v`'s destructor so we are in complete control
    // of the allocation.
    let mut v = mem::ManuallyDrop::new(v);

    // Pull out the various important pieces of information about `v`
    let p = v.as_mut_ptr();
    let len = v.len();
    let cap = v.capacity();

    unsafe {
        // Overwrite memory
        for i in 0..len {
            *p.add(i) += 1;
        }

        // Put everything back together into a Vec
        let rebuilt = Vec::from_raw_parts(p, len, cap);
        for i in 0..len {
            assert_eq!(rebuilt[i], original_v[i]+1);
        }
    }
}
</code></pre>
<p>This, however, might unnecessary increase the complexity of the verification process. We can achieve the same effect using quantifiers as shown below.</p>
<pre><code class="language-rust">use std::mem;

#[kani::proof]
fn main() {
    let original_v = vec![kani::any::&lt;u32&gt;(); 3];
    let v = original_v.clone();
    let v_len = v.len();
    let v_ptr = v.as_ptr();
    let original_v_ptr = original_v.as_ptr();
    unsafe {
        kani::assume(
            kani::forall!(|i in (0,v_len) | *v_ptr.wrapping_byte_offset(4*i as isize) &lt; 5),
        );
    }

    // Prevent running `v`'s destructor so we are in complete control
    // of the allocation.
    let mut v = mem::ManuallyDrop::new(v);

    // Pull out the various important pieces of information about `v`
    let p = v.as_mut_ptr();
    let len = v.len();
    let cap = v.capacity();

    unsafe {
        // Overwrite memory
        for i in 0..len {
            *p.add(i) += 1;
            if i == 1 {
                *p.add(i) = 0;
            }
        }

        // Put everything back together into a Vec
        let rebuilt = Vec::from_raw_parts(p, len, cap);
        let rebuilt_ptr = v.as_ptr();
        assert!(
            kani::exists!(| i in (0, len) | *rebuilt_ptr.wrapping_byte_offset(4*i as isize) == original_v_ptr.wrapping_byte_offset(4*i as isize) + 1)
        );
    }
}
</code></pre>
<p>The same principle applies if we want to use the existential quantifier.</p>
<pre><code class="language-rust">use std::mem;

#[kani::proof]
fn main() {
    let original_v = vec![kani::any::&lt;u32&gt;(); 3];
    let v = original_v.clone();
    let v_len = v.len();
    let v_ptr = v.as_ptr();
    unsafe {
        kani::assume(
            kani::forall!(|i in (0,v_len) | *v_ptr.wrapping_byte_offset(4*i as isize) &lt; 5),
        );
    }

    // Prevent running `v`'s destructor so we are in complete control
    // of the allocation.
    let mut v = mem::ManuallyDrop::new(v);

    // Pull out the various important pieces of information about `v`
    let p = v.as_mut_ptr();
    let len = v.len();
    let cap = v.capacity();

    unsafe {
        // Overwrite memory
        for i in 0..len {
            *p.add(i) += 1;
            if i == 1 {
                *p.add(i) = 0;
            }
        }

        // Put everything back together into a Vec
        let rebuilt = Vec::from_raw_parts(p, len, cap);
        let rebuilt_ptr = v.as_ptr();
        assert!(
            kani::exists!(| i in (0, len) | *rebuilt_ptr.wrapping_byte_offset(4*i as isize) == 0)
        );
    }
}
</code></pre>
<p>The usage of quantifiers should be valid in any part of the Rust code analysed by Kani.</p>
<h2 id="detailed-design-9"><a class="header" href="#detailed-design-9">Detailed Design</a></h2>
<!-- For the implementors or the hackers -->
<p>Kani should have the same support that CBMC has for quantifiers. For more details, see <a href="https://github.com/diffblue/cbmc/blob/0a69a64e4481473d62496f9975730d24f194884a/doc/cprover-manual/contracts-quantifiers.md">Quantifiers</a>.</p>
<p>The implementation of quantifiers in Kani will be based on the following principle:</p>
<ul>
<li><strong>Single expression without function calls</strong>: CBMC's quantifiers only support
single expressions without function calls. This means that the CBMC expressions generated
from the quantifiers in Kani should be limited to a single expression without any
function calls.</li>
</ul>
<p>To achieve this, we will need to implement the function inlining pass in Kani. This
pass will inline all function calls in quantifiers before they are codegened to CBMC
expressions. This will ensure that the generated expressions are compliant with CBMC's
quantifier support.</p>
<h2 id="open-questions-10"><a class="header" href="#open-questions-10">Open questions</a></h2>
<!-- For Developers -->
<ul>
<li><strong>Function Contracts RFC</strong> - CBMC has support for both <code>exists</code> and <code>forall</code>, but the
code generation is difficult. The most ergonomic and easy way to implement
quantifiers on the Rust side is as higher-order functions taking <code>Fn(T) -&gt; bool</code>, where <code>T</code> is some arbitrary type that can be quantified over. This
interface is familiar to developers, but the code generation is tricky, as
CBMC level quantifiers only allow certain kinds of expressions. This
necessitates a rewrite of the <code>Fn</code> closure to a compliant expression.
<ul>
<li>Which kind of expressions should be accepted as a &quot;compliant expression&quot;?</li>
</ul>
</li>
</ul>
<h2 id="future-possibilities-9"><a class="header" href="#future-possibilities-9">Future possibilities</a></h2>
<!-- For Developers -->
<ul>
<li>CBMC has an SMT backend which allows the use of quantifiers with arbitrary Boolean expressions. Kani must include an option for users to experiment with this backend.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Source-based code coverage (<code>source-coverage</code>)</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2640">https://github.com/model-checking/kani/issues/2640</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/3143">https://github.com/model-checking/kani/pull/3143</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong> <a href="https://github.com/model-checking/kani/pull/3119">https://github.com/model-checking/kani/pull/3119</a> (Kani) + <a href="https://github.com/model-checking/kani/pull/3121">https://github.com/model-checking/kani/pull/3121</a> (<code>kani-cov</code>)</li>
</ul>
<hr />
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>A source-based code coverage feature for Kani built on top of Rust's coverage instrumentation.</p>
<h2 id="user-impact-11"><a class="header" href="#user-impact-11">User Impact</a></h2>
<p>In our first attempt to add a coverage feature fully managed by Kani, we introduced and made available a line coverage option
(see <a href="rfcs/0008-line-coverage.html">RFC: Line coverage</a> for more details).
This option has since then allowed us to gather more data around the expectations for a coverage feature in Kani.</p>
<p>For example, the line coverage output we produced was not easy to interpret
without knowing some implementation details.
Aside from that, the feature requested in
<a href="https://github.com/model-checking/kani/issues/2795">#2795</a> alludes to the need
of providing coverage-specific tooling in Kani.
Nevertheless, as captured in
<a href="https://github.com/model-checking/kani/issues/2640">#2640</a>, source-based
coverage results provide the clearest and most precise coverage information.</p>
<p>In this RFC, we propose an integration with <a href="https://doc.rust-lang.org/rustc/instrument-coverage.html">Rust's source-based code coverage
instrumentation</a>.
This integration would allow us to report source-based code coverage results from Kani.
Also, we propose adding a new user-facing, coverage-focused tool called <code>kani-cov</code>.
The tool would allow users to process coverage results generated by Kani and produce
coverage artifacts such as summaries and reports according to their preferences.
In the <a href="rfcs/0011-source-coverage.html#user-experience">next section</a>, we will explain in more detail how we
expect <code>kani-cov</code> to assist with coverage-related tasks.</p>
<p>With these changes, we expect our coverage options to become more flexible,
precise and efficient. These options are expected to replace the previous
options available through the line coverage feature.
In the <a href="rfcs/0011-source-coverage.html#future-possibilities">last section</a> of this RFC, we will also discuss
the requirements for a potential integration of this coverage feature with the
LLVM toolchain.</p>
<h2 id="user-experience-11"><a class="header" href="#user-experience-11">User Experience</a></h2>
<p>The proposed experience is partially inspired by that of the most popular
coverage frameworks.
First, let us delve into the LLVM coverage workflow, followed by an explanation
of our proposal.</p>
<h3 id="the-llvm-code-coverage-workflow"><a class="header" href="#the-llvm-code-coverage-workflow">The LLVM code coverage workflow</a></h3>
<p>The LLVM project is home to one of the most popular code coverage frameworks.
The workflow associated to the LLVM framework is described in the documentation for
<a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">source-based code coverage</a><sup class="footnote-reference"><a href="#note-source">1</a></sup>,
but we briefly describe it here to better relate it with our proposal.</p>
<p>In short, the LLVM code coverage workflow follows three steps:</p>
<ol>
<li><strong>Compiling with coverage enabled.</strong> This causes the compiler to generate an instrumented program.</li>
<li><strong>Running the instrumented program.</strong> This generates binary-encoded <code>.profraw</code> files.</li>
<li><strong>Using tools to aggregate and export coverage information into other formats.</strong></li>
</ol>
<p>When working in a <code>cargo</code> project, step 1 can be done through this command:</p>
<pre><code class="language-sh">RUSTFLAGS='-Cinstrument-coverage' cargo build
</code></pre>
<p>The same flag must to be used for step 2:</p>
<pre><code class="language-sh">RUSTFLAGS='-Cinstrument-coverage' cargo run
</code></pre>
<p>This should populate the directory with at least one <code>.profraw</code> file.
Each <code>.profraw</code> file corresponds to a specific source code file in your project.</p>
<p>At this point, we will have produced the artifacts that we generally require for
the LLVM tools:</p>
<ol>
<li><strong>The instrumented binary</strong> which, in addition to the instrumented program,
contains additional information (e.g., the coverage mappings) required to
interpret the profiling results.</li>
<li><strong>The <code>.profraw</code> files</strong> which essentially includes the profiling results
(e.g., counter values) for each function of the corresponding source code file.</li>
</ol>
<p>For step 3, the commands will depend on what kind of results we want.
Most likely we will have to merge the <code>.profraw</code> files and produce a <code>.profdata</code>
file as follows:</p>
<pre><code class="language-sh">llvm-profdata merge -sparse *.profraw -o output.profdata
</code></pre>
<p>The resulting <code>.profdata</code> file will contain the aggregated coverage results from
the <code>.profraw</code> files passed to the <code>merge</code> command.</p>
<p>Then, we can use a command such as</p>
<pre><code class="language-sh">llvm-cov show target/debug/binary —instr-profile=output.profdata -show-line-counts-or-regions
</code></pre>
<p>to visualize the code coverage through the terminal as in the image:</p>
<p><img src="https://github.com/model-checking/kani/assets/73246657/4f8a973d-8977-4c0b-822d-e73ed6d223aa" alt="Source-based code coverage with llvm-cov" /></p>
<p>or the command</p>
<pre><code class="language-sh">llvm-cov report target/debug/binary --instr-profile=output.profdata --show-region-summary
</code></pre>
<p>to produce coverage summaries like this:</p>
<pre><code>Filename                                             Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover    Branches   Missed Branches     Cover
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/long/long/path/to/my/project/binary/src/main.rs           9                 3    66.67%           3                 1    66.67%          14                 4    71.43%           0                 0         -
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TOTAL                                                      9                 3    66.67%           3                 1    66.67%          14                 4    71.43%           0                 0         -
</code></pre>
<div class="footnote-definition" id="note-source"><sup class="footnote-definition-label">1</sup>
<p>The LLVM project refers to their own coverage feature as
<em>source-based code coverage</em>. It is not rare to see the term <em>region
coverage</em> being used instead to refer to the same thing. That is because
LLVM's source-based code coverage feature can report coverage for code
regions, but other coverage frameworks do not support the concept of code
regions.</p>
</div>
<h3 id="the-kani-coverage-workflow"><a class="header" href="#the-kani-coverage-workflow">The Kani coverage workflow</a></h3>
<p>The two main components of the Kani coverage workflow that we propose are the
following:</p>
<ol>
<li>The existing <code>--coverage</code> flag that drives the coverage workflow in Kani,
emits raw coverage data (as in the <code>.profraw</code> files), and produces basic
coverage results by default.</li>
<li>A new subcommand <code>cov</code> that allows users to further process raw coverage
information emitted by Kani to produce customized coverage results (i.e.,
different to the ones produced by default with the <code>--coverage</code> option).
The <code>cov</code> subcommand is an alias for the <code>kani-cov</code> tool.</li>
</ol>
<p>In contrast to the LLVM workflow, where human-readable coverage results can
be produced only after a sequence of LLVM tool commands, we provide some
coverage results by default.
This aligns better with our UX philosophy, and removes the need for a wrapper
around our coverage features like
<a href="https://github.com/taiki-e/cargo-llvm-cov"><code>cargo-llvm-cov</code></a>.
Alternatively, the <code>cov</code> subcommand offers the ability of producing more
specific coverage results if needed.
We anticipate the <code>cov</code> subcommand being particularly useful in less standard
project setups, giving the users the flexibility required to produce coverage
results tailored to their specific needs.</p>
<p>In the following, we describe each one of these components in more detail.</p>
<h4 id="the---coverage-option"><a class="header" href="#the---coverage-option">The <code>--coverage</code> option</a></h4>
<p>The default coverage workflow will be kicked off through the unstable
<code>--coverage</code> option:</p>
<pre><code class="language-sh">cargo kani --coverage -Zsource-coverage
</code></pre>
<p>The main difference with respect to the regular verification workflow is that,
at the end of the verification-based coverage run, Kani will generate two coverage
results:</p>
<ul>
<li>A coverage summary corresponding to the coverage achieved by the harnesses
included in the verification run. This summary will be printed after the
verification output.</li>
<li>A coverage report corresponding to the coverage achieved by the harnesses
included in the verification run. The report will be placed in the same target
directory where the raw coverage files are put. The path to the report will
also be printed after the verification output.</li>
</ul>
<p>Therefore, a typical <code>--coverage</code> run could look like this:</p>
<pre><code>VERIFICATION:- SUCCESSFUL

Coverage Results:

| Filename | Regions | Missed Regions | Cover | Functions | Missed Functions | Cover |
| -------- | ------- | -------------- | ----- | --------- | ---------------- | ----- |
| main.rs  |       9 |              3 | 66.67 |         3 |                1 | 33.33 |
| file.rs  |      11 |              5 | 45.45 |         2 |                1 | 50.00 |

Coverage report available in target/kani/x86_64-unknown-linux-gnu/cov/kani_2024-04-26_15-30-00/report/index.html
</code></pre>
<h4 id="the-cov-subcommand"><a class="header" href="#the-cov-subcommand">The <code>cov</code> subcommand</a></h4>
<p>The <code>cov</code> subcommand will be used to process raw coverage information generated
by Kani and produce coverage outputs as indicated by the user.
Hence, the <code>cov</code> subcommand corresponds to the set of LLVM tools
(<code>llvm-profdata</code>, <code>llvm-cov</code>, etc.) that are used to produce coverage outputs
through the LLVM coverage workflow.</p>
<p>In contrast to LLVM, we will have a single subcommand for all Kani
coverage-related needs. The <code>cov</code> subcommand will just call the <code>kani-cov</code> tool,
which is expected to be shipped along the rest of Kani binaries.</p>
<p>We suggest that the subcommand initially offers two options:</p>
<ol>
<li>An option to merge the coverage results from one or more files and coverage
mappings<sup class="footnote-reference"><a href="#note-snapshot">2</a></sup> into a single file.</li>
<li>An option to produce coverage outputs from coverage results, including summaries
or coverage reports in human-readable formats (e.g., HTML).</li>
</ol>
<p>Let's assume that we have run <code>cargo kani --coverage -Zsource-coverage</code> and
generated coverage files in the <code>my-coverage</code> folder. Then, we would use <code>cargo kani cov</code> as follows to combine the coverage results<sup class="footnote-reference"><a href="#note-exclude">3</a></sup> for all
harnesses:</p>
<pre><code class="language-sh">cargo kani cov --merge my-coverage/*.kaniraw -o my-coverage.kanicov
</code></pre>
<p>Let's say the user is first interested in reading a coverage summary through the
terminal.
They can use the <code>--summary</code> option for that:</p>
<pre><code class="language-sh">cargo kani cov --summary my-coverage/default.kanimap -instr-profile=my-coverage.kanicov
</code></pre>
<p>The command could print a coverage summary like:</p>
<pre><code>| Filename | Regions | Missed Regions | Cover | Functions | ...
| -------- | ------- | -------------- | ----- | --------- | ...
| main.rs  |       9 |              3 | 66.67 |         3 | ...
[...]
</code></pre>
<p>Now, let's say the user wants to produce an HTML report of the coverage results.
They will have to use the <code>--report</code> option for that:</p>
<pre><code class="language-sh">cargo kani cov --report my-coverage/default.kanimap -format=html -instr-profile=my-coverage.kanicov -o coverage-report
</code></pre>
<p>This time, the command will generate a <code>coverage-report</code> folder including a
browsable HTML webpage that highlights the regions covered in the source
according to the coverage results in <code>my-coverage.kanicov</code>.</p>
<div class="footnote-definition" id="note-export"><sup class="footnote-definition-label">4</sup>
<p>The <code>llvm-cov</code> tool includes the option
<a href="https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov"><code>gcov</code></a> to
export into GCC's coverage format <a href="https://en.wikipedia.org/wiki/Gcov">Gcov</a>,
and the option
<a href="https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-export"><code>export</code></a>
to export into the LCOV format. These may be good options to consider for
<code>kani-cov</code> in the future but we should focus on basic formats for now.</p>
</div>
<div class="footnote-definition" id="note-exclude"><sup class="footnote-definition-label">3</sup>
<p>Options to exclude certain coverage results (e.g, from the
standard library) will likely be part of this option.</p>
</div>
<div class="footnote-definition" id="note-snapshot"><sup class="footnote-definition-label">2</sup>
<p>Coverage mappings essentially provide a snapshot of the source
code reports for items that otherwise are unreachable or have been sliced
away during the compilation process.</p>
</div>
<h4 id="integration-with-the-kani-vs-code-extension"><a class="header" href="#integration-with-the-kani-vs-code-extension">Integration with the Kani VS Code Extension</a></h4>
<p>We will update the coverage feature of the
<a href="https://github.com/model-checking/kani-vscode-extension">Kani VS Code Extension</a>
to follow this new coverage workflow.
In other words, the extension will first run Kani with the <code>--coverage</code> option and
use <code>kani cov</code> to produce a <code>.kanicov</code> file with the coverage results.
The extension will consume the source-based code coverage results and
highlight region coverage in the source code seen from VS Code.</p>
<p>We could also consider other coverage-related features in order to enhance the
experience through the Kani VS Code Extension. For example, we could
automatically show the percentage of covered regions in the status bar by
additionally extracting a summary of the coverage results.</p>
<p>Finally, we could also consider an integration with other code coverage tools.
For example, if we wanted to integrate with the VS Code extensions
<a href="https://marketplace.visualstudio.com/items?itemName=markis.code-coverage">Code Coverage</a> or
<a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">Coverage Gutters</a>,
we would only need to extend <code>kani-cov</code> to export coverage results to the LCOV
format or integrate Kani with LLVM tools as discussed in <a href="rfcs/0011-source-coverage.html#integration-with-llvm">Integration with LLVM</a>.</p>
<h2 id="detailed-design-10"><a class="header" href="#detailed-design-10">Detailed Design</a></h2>
<p>In this section, we provide more details on:</p>
<ul>
<li>The Rust coverage instrumentation and how it can be integrated into
Kani to produce source-based code coverage results.</li>
<li>The proposed coverage workflow to be run by default in Kani when the
<code>--coverage</code> option is used.</li>
</ul>
<p>This information is mostly intended as a reference for Kani contributors.
Currently, the Rust coverage instrumentation continues to be developed. Because
of that, Rust toolchain upgrades may result in breaking changes to our own
coverage feature. This section should help developers to understand the general
approach and resolve such issues by themselves.</p>
<h3 id="the-rust-coverage-instrumentation"><a class="header" href="#the-rust-coverage-instrumentation">The Rust coverage instrumentation</a></h3>
<p>The Rust compiler includes two code coverage implementations:</p>
<ul>
<li>A source-based coverage implementation which uses LLVM's coverage
instrumentation to generate precise coverage data. This implementation can be
enabled with <code>-C instrument-coverage</code>.</li>
<li>A Gcov-based coverage implementation that derives coverage data based on
DebugInfo. This implementation can be enabled with <code>-Z profile</code>.</li>
</ul>
<p>The <a href="https://doc.rust-lang.org/rustc/instrument-coverage.html">Instrumentation-based Code Coverage</a>
chapter from the <code>rustc</code> book describes in detail how to enable and use the LLVM
instrumentation-based coverage feature. In contrast, the
<a href="https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html">LLVM Source-Based Code Coverage</a>
chapter from the <code>rustc</code> development guide documents how the LLVM
coverage instrumentation is performed in the Rust compiler.</p>
<p>In this section, we will first summarize some information from the
<a href="https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html">LLVM Source-Based Code Coverage</a>
chapter, limited to details which are relevant to the development of the
source-based coverage feature in Kani. Then, we will explain how Kani taps into
the Rust coverage instrumentation to perform its own coverage instrumentation
and be able to report source-based code coverage results. This will also include
mentions to current issues with this implementation, which we plan to further
discuss in <a href="rfcs/0011-source-coverage.html#future-possibilities">Future possibilities</a>.</p>
<h4 id="understanding-the-rust-coverage-instrumentation"><a class="header" href="#understanding-the-rust-coverage-instrumentation">Understanding the Rust coverage instrumentation</a></h4>
<p>The LLVM coverage instrumentation is implemented in the Rust compiler as a
<a href="https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html#mir-pass-instrumentcoverage">MIR pass called <code>InstrumentCoverage</code></a>.</p>
<p>The MIR pass first builds a coverage-specific version of the MIR Control Flow
Graph (CFG) from the MIR. The initial version of this CFG is based on the MIR's
<code>BasicBlock</code>s, which then gets refined by combining blocks that can be chained
from a coverage-relevant point of view. The final version of the coverage CFG is
then used to determine where to inject the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.Coverage"><code>StatementKind::Coverage</code></a>
statements in order to measure coverage for a single region coverage span.</p>
<p>The injection of <code>StatementKind::Coverage</code> statements is the main result we are
interested in for the integration with Kani. Additionally, the instrumentation
will also attach the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.FunctionCoverageInfo.html"><code>FunctionCoverageInfo</code></a>
structure to each function's body.<sup class="footnote-reference"><a href="#note-coverage-info">5</a></sup>
This result is also needed at the moment because coverage statements do not
include information on the code region they are supposed to cover.
However, <code>FunctionCoverageInfo</code> contains the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.Mapping.html">coverage mappings</a>,
which represent the relation between
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CovTerm.html">coverage counters</a>
and code regions.</p>
<p>As explained in <a href="https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html#mir-pass-instrumentcoverage">MIR Pass:
<code>InstrumentCoverage</code></a>,
many coverage statements will not be converted into a physical
counter<sup class="footnote-reference"><a href="#note-physical-counter">6</a></sup>. Instead, they will be converted into a
<em>coverage-counter expression</em> that can be calculated based on other coverage
counters. We highly recommend looking at the example in <a href="https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html#mir-pass-instrumentcoverage">MIR Pass:
<code>InstrumentCoverage</code></a>
to better understand how this works. This optimization is mainly done for
performance reasons because incrementing a physical counter causes a
non-negligible overhead, especially within loops.</p>
<p>The (<code>StatementKind::</code>)<code>Coverage</code> statements that are injected by the Rust coverage
instrumentation contain a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html"><code>CoverageKind</code></a> field indicating the type of coverage counter. The variant
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html#variant.CounterIncrement"><code>CounterIncrement</code></a>
represents physical counters, while
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html#variant.ExpressionUsed"><code>ExpressionUsed</code></a>
represents the counter expressions that we just discussed.
Other variants such as <code>SpanMarker</code> or <code>BlockMarker</code> are not relevant to this
work since they should have been erased after the <code>InstrumentCoverage</code> pass.</p>
<div class="footnote-definition" id="note-coverage-info"><sup class="footnote-definition-label">5</sup>
<p>It is important to note that the <code>rustc_public</code> interface does
not include <code>FunctionCoverageInfo</code> in function bodies. Because of that, we
need to pull it from the internal <code>rustc</code> function bodies.</p>
</div>
<div class="footnote-definition" id="note-physical-counter"><sup class="footnote-definition-label">6</sup>
<p>By <em>physical counter</em>, we refer to a global program
variable that is initialized to zero and incremented by one each time that
the execution passes through.</p>
</div>
<h4 id="integrating-the-instrumentation-into-kani"><a class="header" href="#integrating-the-instrumentation-into-kani">Integrating the instrumentation into Kani</a></h4>
<p>Now that we have explained what the Rust coverage instrumentation does at a high
level, we should be ready to discuss how it can be used from Kani. Here, we will
follow an approach where, during the codegen stage, we generate a Kani
reachability check for each code region and, after the verification stage, we
postprocess the information in those checks to generate the coverage
information. So this section will essentially be a retelling of the
implementation in <a href="https://github.com/model-checking/kani/pull/3119">#3119</a>, and
we will discuss variations/extensions of this approach in the
<a href="rfcs/0011-source-coverage.html#rationale-and-alternatives">appropriate</a> <a href="rfcs/0011-source-coverage.html#future-possibilities">sections</a>.</p>
<p>Clearly, the first step is adding <code>-C instrument-coverage</code> to the <code>rustc</code> flags
we use when calling the compiler to codegen. This flag enables the Rust coverage
instrumentation that we discussed earlier, resulting in</p>
<ol>
<li>the injection of
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.Coverage"><code>Coverage</code></a>
statements in the MIR code, and</li>
<li>the inclusion of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.FunctionCoverageInfo.html"><code>FunctionCoverageInfo</code></a> in function bodies.</li>
</ol>
<p>The next step is handling the <code>Coverage</code> statements from <code>codegen_statement</code>.</p>
<p>Each <code>Coverage</code> statement contains opaque coverage
information<sup class="footnote-reference"><a href="#note-opaque-coverage">7</a></sup> of the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html"><code>CoverageKind</code></a>
type which can be processed to determine the type of coverage counter
(<code>CounterIncrement</code> for physical counters, <code>ExpressionUsed</code> for counter
expressions) and the ID number of the counter. These two pieces of information allow us to
uniquely identify the counter within a given function. For example,
<code>CounterIncrement(0)</code> would generally refer to the first physical counter in the
function.</p>
<p>Unfortunately, the <code>CoverageKind</code> information does not tell us anything about
the code region that the counter covers. However, data about the code region can
be pulled from the coverage mappings included in the <code>FunctionCoverageInfo</code> that
is attached to the (internal) function body. Note that the coverage mappings
includes information about all the coverage counters in a function, even for
counters which have been dropped. Matching the <code>CoverageKind</code> information with
that of the counters in the coverage mappings allows us to retrieve the code
region for any counter.</p>
<p>Using all this data, for each coverage statement<sup class="footnote-reference"><a href="#note-expression-integration">8</a></sup> we generate a coverage check
that maintains the essence of the coverage checks described in the <a href="https://model-checking.github.io/kani/rfc/rfcs/0008-line-coverage.html">RFC for line
coverage</a>:</p>
<blockquote>
<p>Coverage checks are a new class of checks similar to <a href="https://model-checking.github.io/kani/rfc/rfcs/0003-cover-statement.html"><code>cover</code> checks</a>.
The main difference is that users cannot directly interact with coverage checks (i.e., they cannot add or remove them manually).
Coverage checks are encoded as an <code>assert(false)</code> statement (to test reachability) with a fixed description.
In addition, coverage checks are:</p>
<ul>
<li>Hidden from verification results.</li>
<li>Postprocessed to produce coverage results.</li>
</ul>
</blockquote>
<p>Therefore, the last step is to postprocess the results from coverage checks to
produce coverage results. This is not too complicated to do since the checks
already include the counter information (type + ID) and the function name in
the check's description. If the span of the code region is also included
(this is what <a href="https://github.com/model-checking/kani/pull/3119">#3119</a> is
currently doing), we can directly generate a primitive output like this:</p>
<pre><code>&lt;file_path&gt; (&lt;function_name&gt;)
 * &lt;region_start&gt; - &lt;region_end&gt; &lt;status&gt;
 * ...
 * &lt;region_start&gt; - &lt;region_end&gt; &lt;status&gt;
</code></pre>
<p>For example, for the test case in
<a href="https://github.com/model-checking/kani/pull/3119">#3119</a> we report this:</p>
<pre><code>src/main.rs (main)
 * 14:1 - 19:2 COVERED

src/main.rs (test_cov)
 * 5:1 - 6:15 COVERED
 * 6:19 - 6:28 UNCOVERED
 * 7:9 - 7:13 COVERED
 * 9:9 - 9:14 UNCOVERED
 * 11:1 - 11:2 COVERED
</code></pre>
<blockquote>
<p><strong>NOTE: This section has been written according to the implementation in
<a href="https://github.com/model-checking/kani/pull/3119">#3119</a>, which currently
produces a text-based output like the one shown above. There is ongoing work to
store the coverage mappings in a separate file (as described in the next
section), which would save us the need to attach code region data to the
coverage checks.</strong></p>
</blockquote>
<div class="footnote-definition" id="note-opaque-coverage"><sup class="footnote-definition-label">7</sup>
<p>The Rust compiler uses the <code>Opaque</code> type to prevent
others from interfacing with unstable types (e.g., the <code>Coverage</code> type
<a href="https://github.com/rust-lang/rust/blob/f7eefec4e03f5ba723fbc04d94dbc1203b7c9bff/compiler/stable_mir/src/mir/body.rs#L389">here</a>).
Nonetheless, this can be worked around by serializing its contents and parsing
it back into an internal data type.</p>
</div>
<div class="footnote-definition" id="note-expression-integration"><sup class="footnote-definition-label">8</sup>
<p>We could follow an alternative approach where we
do not instrument each coverage statement, but only those that correspond to
physical counters. Unfortunately, doing so would lead to incorrect coverage
results due to the arithmetic nature of expression-based counters. We elaborate
on this topic in the later parts of this document.</p>
</div>
<h3 id="the-default-coverage-workflow-in-kani"><a class="header" href="#the-default-coverage-workflow-in-kani">The default coverage workflow in Kani</a></h3>
<p>In this section, we describe the default <code>--coverage</code> workflow from a
developer's point of view. This will hopefully help developers understand how
the different coverage components in Kani are connected. For example, we'll
describe the raw coverage information that gets produced throughout the default
<code>--coverage</code> workflow and define the basic <code>cov</code> commands that it will execute.</p>
<p>The main difference with respect to the regular verification workflow is that,
at the end of the verification-based coverage run, Kani will generate two types
of files:</p>
<ul>
<li>One single file <code>.kanimap</code> file for the project. This file will contain the
coverage mappings for the project's source code.</li>
<li>One <code>.kaniraw</code> file for each harness. This file will contain the
verification-based results for the coverage-oriented properties corresponding
to a given harness.</li>
</ul>
<p>Note that <code>.kaniraw</code> files correspond to <code>.profraw</code> files in the LLVM coverage
workflow. Similarly, the <code>.kanimap</code> file corresponds to the coverage-related
information that's embedded into the project's binaries in the LLVM coverage
workflow.<sup class="footnote-reference"><a href="#note-kanimap">9</a></sup></p>
<p>The files will be written into a new timestamped directory associated with the
coverage run. The path to this directory will be printed to standard output in
by default. For example, the <a href="https://github.com/model-checking/kani/pull/3119">draft implementation</a>
writes the coverage files into the <code>target/kani/&lt;target_triple&gt;/cov/</code> directory.</p>
<p>Users aren't expected to read the information in any of these files.
Therefore, there's no need to restrict their format.
The <a href="https://github.com/model-checking/kani/pull/3119">draft implementation</a>
uses the JSON format but we might consider using a binary format if it doesn't
scale.</p>
<p>In addition, Kani will produce two types of coverage results:</p>
<ol>
<li>A coverage summary with the default options.</li>
<li>A terminal-based coverage report with the default options. However, we will
only do this if the program is composed of a single source
file<sup class="footnote-reference"><a href="#note-conditional-report">10</a></sup>.</li>
</ol>
<div class="footnote-definition" id="note-kanimap"><sup class="footnote-definition-label">9</sup>
<p>Note that the <code>.kanimap</code> generation isn't implemented in
<a href="https://github.com/model-checking/kani/pull/3119">#3119</a>. The <a href="https://github.com/model-checking/kani/pull/3121">draft
implementation of
<code>kani-cov</code></a> simply reads
the source files referred to by the code coverage checks, but it doesn't get
information about code trimmed out by the MIR linker.</p>
</div>
<div class="footnote-definition" id="note-conditional-report"><sup class="footnote-definition-label">10</sup>
<p>In other words, standalone <code>kani</code> would always emit
these terminal-based reports, but <code>cargo kani</code> would not unless the project
contains a single Rust file (for example, <code>src/main.rs</code>).</p>
</div>
<h2 id="rationale-and-alternatives-7"><a class="header" href="#rationale-and-alternatives-7">Rationale and alternatives</a></h2>
<h3 id="other-coverage-implementations"><a class="header" href="#other-coverage-implementations">Other coverage implementations</a></h3>
<p>In a previous version of this feature, we used an ad-hoc coverage implementation.
In addition to being very inefficient<sup class="footnote-reference"><a href="#note-benchmarks">11</a></sup>, the line-based coverage
results were not trivial to interpret by users.
At the moment, there's only another unstable, GCC-compatible code coverage implementation
based on the Gcov format. The Gcov format is line-based so it's not able
to report region coverage results.
In other words, it's not as advanced nor precise as the source-based implementation.</p>
<div class="footnote-definition" id="note-benchmarks"><sup class="footnote-definition-label">11</sup>
<p>Actual performance benchmarks to follow in
<a href="https://github.com/model-checking/kani/pull/3119">#3119</a>.</p>
</div>
<h2 id="open-questions-11"><a class="header" href="#open-questions-11">Open questions</a></h2>
<ul>
<li>Do we want to instrument dependencies by default? Preliminary benchmarking results show a slowdown of 100% and greater.
More evaluations are required to determine how we handle instrumentation for dependencies, and what options we might want
to provide to users.</li>
<li>How do we handle features/options for <code>kani-cov</code>? In particular, do we need more details in this RFC?</li>
</ul>
<h2 id="future-possibilities-10"><a class="header" href="#future-possibilities-10">Future possibilities</a></h2>
<h3 id="integration-with-llvm"><a class="header" href="#integration-with-llvm">Integration with LLVM</a></h3>
<p>As part of this work, we explored a potential integration with the LLVM
framework. The idea behind such an integration would essentially involve
producing coverage results in formats compatible with the LLVM framework (e.g.,
the <code>.profraw</code> format). The main advantage of integrating with the LLVM
framework in this way is that we would not need a tool like <code>kani-cov</code> to
aggregate coverage results; we could just use LLVM tools such as <code>llvm-profdata</code>
and <code>llvm-cov</code> to consume them.</p>
<p>However, at this time we recommend against integrating with LLVM due to these reasons:</p>
<ol>
<li>Generating the instrumented binary used in the <a href="rfcs/0011-source-coverage.html#the-llvm-code-coverage-workflow">LLVM coverage
workflow</a> requires a standard <code>rustc</code>
compilation with <code>--cfg kani</code> in addition to other flags including <code>-C instrument-coverage</code>. This is likely to result in compilation errors since the
standard <code>rustc</code> backend cannot produce code for Kani APIs, for example.</li>
<li>Producing the <code>.profraw</code> files requires executing the instrumented binary at
least once. This would be an issue for Rust projects which assume a particular
environment for their execution.</li>
<li>There are no stable interfaces to create or modify files in formats
compatible with the LLVM framework. Even though the documentation for the <a href="https://llvm.org/docs/CoverageMappingFormat.html">LLVM
Code Coverage Mapping Format</a>
is excellent, the easiest way to interact with files on these format is through
LLVM tools (e.g.,
<a href="https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-cov"><code>llvm-cov</code></a>)
which bring in many other LLVM dependencies. During our exploration, we
attempted to decode and re-encode files in the <code>.profraw</code> to set the counter
data to the values obtained during verification. To this end, we tried tools
like <a href="https://github.com/xd009642/llvm-profparser/"><code>llvm-profparser</code></a> which
can be used as a replacement for <code>llvm-profdata</code> and <code>llvm-cov</code> but failed to
parse coverage files emitted by the Rust compiler (this is also related to the
next point). Another crate that we used is
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/coverage-dump"><code>coverage-dump</code></a>,
a recent tool in the Rust compiler used for testing purposes. <code>coverage-dump</code>
extracts coverage mappings from LLVM IR assembly files (i.e., human-readable
<code>*.ll</code> files) but does not work with the binary-encoded formats. Finally, we
also built some ad-hoc tooling to perform these modifications but it soon
became evident that we would need to develop it further in order to handle any
program.</li>
<li>LLVM releases a new version approximately every six months. This would
likely result in another &quot;toolchain update&quot; problem for Kani in order to
provide compatibility with newer LLVM versions. Moreover, the Rust compiler
supplies their own version of LLVM tools (<code>rust-profdata</code>, <code>rust-cov</code>, etc.)
which are fully compatible with coverage-related artifacts produced by <code>rustc</code>.</li>
</ol>
<h3 id="optimization-with-coverage-counter-expressions"><a class="header" href="#optimization-with-coverage-counter-expressions">Optimization with coverage-counter expressions</a></h3>
<p>In the <a href="rfcs/0011-source-coverage.html#integrating-the-instrumentation-into-kani">subsection related to the
integration</a>, we noted that we could
follow an alternative approach where we only instrument coverage statements that
correspond to physical counters. In fact, this would be the logical choice since
the replacement of physical counters by expression-based counters would also be
a performance optimization for us.</p>
<p>However, the expressions used in expression-based counters are built with the
arithmetic operators <code>Add</code> (<code>+</code>) and <code>Sub</code> (<code>-</code>). On the other hand, the
coverage checks performed by Kani have a boolean meaning: you either cover a
region or you do not. Thus, there are many cases where these two notions of
coverage counters are incompatible. For example, let's say we have this
function:</p>
<pre><code class="language-rust">fn check_value(val: u32) {
   if val == VALUE {
      do_this();
   } else {
      do_that();
   }
   do_something_else();
}
</code></pre>
<p>One way to optimize the counters in this function is to have two physical
counters for the branches of the <code>if</code> statement (<code>c1</code> and <code>c2</code>), and then an
expression-based counter associated to the <code>do_something_else()</code> statement
adding those (i.e., <code>c3 = c1 + c2</code>). If we have, for example, two executions for
this program, with each one taking a different branch, then the results for the
coverage counters will be <code>c1 = 1</code>, <code>c2 = 1</code> and <code>c3 = c1 + c2 = 2</code>.</p>
<p>But what does <code>c3 = 2</code> mean in the context of a verification-based coverage
result? That is not clear. For instance, in a Kani trace, you could have a
nondeterministic value for <code>val</code> which just happens to be <code>val == VALUE</code> and not
at the same time. This would result in the same counters (<code>c1 = 1</code>, <code>c2 = 1</code> and
<code>c3 = 2</code>), but the program is being run only once!</p>
<p>Note that finding a verification-based replacement for the runtime operators in
counter-based expressions is an interesting research topic. If we could
establish a relation between the runtime and verification expressions, then we
could avoid the instrumentation of coverage checks for expression-based
counters. For example, could we replace the <code>Add</code> operator (<code>+</code>) with an <code>Or</code>
operator (<code>||</code>)? Intuitively, this makes sense since verification-based coverage
counters are binary. It also seems to work for our example since covering any of
the branches should result in the <code>do_something_else()</code> statement being covered
as well, with the counter values now being <code>c1 = 1</code>, <code>c2 = 1</code> and <code>c3 = 1</code>.
However, it is not clear that this would work for all cases, nor it is clear
that we can replace <code>Sub</code> with another verification-based operator.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> Loop Contracts</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/3168">#3168</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/3167">#3167</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 1</li>
<li><strong>Proof-of-concept:</strong> </li>
</ul>
<hr />
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>Loop contracts provide way to safely abstract loops of a program, typically
in order to accelerate the verification process, and remove the loop unwinding
bounds. The key idea is to over-approximate the possible set of program states,
while still being precise enough to be able to prove the desired property.</p>
<h2 id="user-impact-12"><a class="header" href="#user-impact-12">User Impact</a></h2>
<p>Loop contracts provide an interface for a verified, sound abstraction.
The goal for specifying loop contracts in the source code is two fold:</p>
<ul>
<li>Unbounded verification: Currently, proving correctness
(i.e. assertions never fail) on programs with unbounded control flow (e.g. 
loops with dynamic bounds) Kani requires unwinding loops for a large number of
times, which is not always feasible. Loop contracts provide a way to abstract
out loops, and hence remove the need for unwinding loops.</li>
<li>Faster CI runs: In most cases, the provided contracts would also significantly
improve Kani's verification time since all loops would be unrolled only to
a single iteration.</li>
</ul>
<p>Loop contracts are completely optional with no user impact if unused. This
RFC proposes the addition of new attributes, and functions, that shouldn't
interfere with existing functionalities.</p>
<h2 id="user-experience-12"><a class="header" href="#user-experience-12">User Experience</a></h2>
<p>A loop contract specifies the behavior of a loop as a boolean predicate
(loop invariants clauses) with certain frames conditions (loop modifies clauses)
that can be checked against the loop implementation, and used to abstract out
the loop in the verification process.</p>
<p>We illustrate the usage of loop contracts with an example.
Consider the following program:</p>
<pre><code class="language-rs">fn simple_loop() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    while x &gt; 1{
        x = x - 1;
    };

    assert!(x == 1);
}
</code></pre>
<p>The loop in the <code>simple_loop</code> function keep subtracting 1 from <code>x</code> until <code>x</code> is 1.
However, Kani currently needs to unroll the loop for <code>u64::MAX</code> number of times
to verify the assertion at the end of the program. </p>
<p>With loop contracts, the user can specify the behavior of the loop as follows:</p>
<pre><code class="language-rs">fn simple_loop_with_loop_contracts() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    #[kani::loop_invariant(x &gt;= 1)]
    while x &gt; 1{
        x = x - 1;
    };

    assert!(x == 1);
}
</code></pre>
<p>The loop invariant clause <code>#[kani::loop_invariant(x &gt;= 1)]</code> specifies the loop
invariants that must hold at the beginning of each iteration of the loop right before
checking the loop guard.</p>
<p>In this case, Kani verifies that the loop invariant <code>x &gt;= 1</code> is inductive, i.e.,
<code>x</code> is always greater than or equal to 1 at each iteration before checking <code>x &gt; 1</code>.</p>
<p>Also, once Kani proved that the loop invariant is inductive, it can safely use the loop
invariants to abstract the loop out of the verification process.
The idea is, instead of exploring all possible branches of the loop, Kani only needs to
prove those branches reached from an arbitrary program state that satisfies the loop contracts,
after the execution of one iteration of the loop.</p>
<p>So, for loops without break statements, we can assume all post-states of the loop satisfying
<code>inv &amp;&amp; !loop_guard</code> for proving post-loops properties.
The requirement of satisfying the negation of the loop guard comes from the fact that a path
exits loops without break statements must fail the loop guard.</p>
<p>For example, applying loop contracts in <code>simple_loop</code> function is equivalent to the following:</p>
<pre><code class="language-rs">fn simple_loop_transformed() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    x = kani::any(); // Arbitrary program state that
    kani::assume( !(x &gt; 1) &amp;&amp; x &gt;= 1); // satisfies !`guard` &amp;&amp; `inv` 

    assert!(x == 1);
}
</code></pre>
<p>The assumption above is actually equivalent to <code>x == 1</code>, hence the assertion at the end
of the program is proved.</p>
<h3 id="write-sets-and-havocking-1"><a class="header" href="#write-sets-and-havocking-1">Write Sets and Havocking</a></h3>
<p>For those memory locations that are not modified in the loop, loop invariants state
that they stay unchanged throughout the loop are inductive. In other words, Kani should
only havoc the memory locations that are modified in the loop. This is achieved by
specifying the <code>modifies</code> clause for the loop. For example, the following program:</p>
<pre><code class="language-rs">fn simple_loop_two_vars() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);
    let mut y: u64 = 1;

    #[kani::loop_invariant(x &gt;= 1)]
    #[kani::loop_modifies(x)]
    while x &gt; 1{
        x = x - 1;
    };

    assert!(x == 1);
    assert!(y == 1);
}
</code></pre>
<p>write to only <code>x</code> in the loop, hence the <code>modifies</code> clause contains only <code>x</code>.
Then when use the loop contracts to abstract the loop, Kani will only havoc the memory
location <code>x</code> and keep <code>y</code> unchanged. Note that if the <code>modifies</code> clause contains also
<code>y</code>, Kani will havoc both <code>x</code> and <code>y</code>, and hence violate the assertion <code>y == 1</code>.</p>
<p>Kani can employs CBMC's write set inference to infer the write set of the loop.
So users have to specify the <code>modifies</code> clauses by their self only when the inferred write
sets are not complete---there exists some target that could be written to in the loop but 
is not in the inferred write set.</p>
<h3 id="proof-of-termination"><a class="header" href="#proof-of-termination">Proof of termination</a></h3>
<p>Loop contracts also provide a way to prove the termination of the loop.
Without the proof of termination, Kani could report success of some assertions that
are actually unreachable due to non-terminating loops.
For example, consider the following program:</p>
<pre><code class="language-rs">fn simple_loop_non_terminating() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    #[kani::loop_invariant(x &gt;= 1)]
    while true{
        x = x;
    };

    assert!(x &gt;= 1);
}
</code></pre>
<p>After abstracting the loop, the loop will be transformed to no-op, and the assertion
<code>x &gt;= 1</code> will be proved. However, the loop is actually an infinite loop, and the
assertion will never be reached.</p>
<p>For this reason, Kani will also require the user to provide a <code>decreases</code> clause that
specifies a decreasing expression to prove the termination of the loop. For example, in</p>
<pre><code class="language-rs">fn simple_loop_terminating() {
    let mut x: u64 = kani::any_where(|i| *i &gt;= 1);

    #[kani::loop_invariant(x &gt;= 1)]
    #[kani::loop_decreases(x)]
    while x &gt; 1{
        x = x - 1;
    };

    assert!(x &gt;= 1);
}
</code></pre>
<p>, the <code>decreases</code> clause <code>#[kani::loop_decreases(x)]</code> specifies that the value of <code>x</code>
decreases at each iteration of the loop, and hence the loop will terminate.</p>
<h2 id="detailed-design-11"><a class="header" href="#detailed-design-11">Detailed Design</a></h2>
<p>Kani implements the functionality of loop contracts in three places.</p>
<ol>
<li>Procedural macros <code>loop_invariant</code>, <code>loop_modifies</code>, and <code>loop_decreases</code>.</li>
<li>Code generation for builtin functions expanded from the above macros.</li>
<li>GOTO-level loop contracts using CBMC's contract language generated in
<code>kani-compiler</code>.</li>
</ol>
<h3 id="procedural-macros-loop_invariant-loop_modifies-and-loop_decreases"><a class="header" href="#procedural-macros-loop_invariant-loop_modifies-and-loop_decreases">Procedural macros <code>loop_invariant</code>, <code>loop_modifies</code>, and <code>loop_decreases</code>.</a></h3>
<p>We will implement the three proc-macros <code>loop_invariant</code>, <code>loop_modifies</code>, and <code>loop_decreases</code> to
embed the annotation logic as Rust code. Kani will then compile them into MIR-level code.</p>
<h3 id="code-generation-for-builtin-functions"><a class="header" href="#code-generation-for-builtin-functions">Code Generation for Builtin Functions</a></h3>
<p>Then in the MIR, we codegen the loop contracts as GOTO-level expressions and annotate them
into the corresponding loop latches---the jumps back to the loop head.</p>
<p>The artifact <code>goto-instrument</code> in CBMC will extract the loop contracts from the named-subs
of the loop latch, and then apply and prove the extracted loop contracts.</p>
<h3 id="goto-level-havocing"><a class="header" href="#goto-level-havocing">GOTO-Level Havocing</a></h3>
<p>The ordinary havocing in CBMC is not aware of the type constraints of Rust type.
Hence, we will use customized havocing functions for modifies targets. In detail,
Kani will generate code for the definition of corresponding <code>kani::any()</code> functions
for each modifies target. Then Kani will create a map from the modifies target to the
the name of its <code>kani::any()</code> function, and add the map to the loop latch too.</p>
<p>On the CBMC site, <code>goto-instrument</code> will extract the map and instrument the customized
havocing functions for the modifies targets.</p>
<h3 id="for-loop-rewrite"><a class="header" href="#for-loop-rewrite">For-loop rewrite</a></h3>
<p>When there is a loop invariant for a <code>for</code> loop, the <code>loop_invariant</code> procedural macro
will rewrite <code>for-loop</code> into a <code>while-loop</code>, but not exactly the same way as 
https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops. 
Let's use the following example to demonstrate the disadvantages of rewriting 
using the original Rust <code>into_iter</code> function:</p>
<pre><code class="language-Rust">let a: [u8; 10] = kani::any();
#[kani::loop_invariant(...)]
for i in a {
  ... //loop body
}
</code></pre>
<p>is rewritten into:</p>
<pre><code class="language-Rust">let a: [u8; 10] = kani::any();
let mut kani_iter = a.into_iter();
#[kani::loop_invariant(...)]
loop {
  match kani_iter.next() {
    Some(i) =&gt; { 
      ...  //loop body
      }
    None =&gt; { break; }
  }
}
</code></pre>
<p>The returned type of <code>into_iter</code> depends on the type of the caller that implements the <code>IntoIter</code> trait.
In this case, it is:</p>
<pre><code class="language-Rust">pub struct IntoIter&lt;T, const N: usize&gt; {
    inner: InnerSized&lt;T, N&gt;,
}
</code></pre>
<p>where the dependencies are:</p>
<pre><code class="language-Rust">type InnerSized&lt;T, const N: usize&gt; = iter_inner::PolymorphicIter&lt;[MaybeUninit&lt;T&gt;; N]&gt;;

pub(super) struct PolymorphicIter&lt;DATA: ?Sized&gt;
where
    DATA: PartialDrop,
{
    alive: IndexRange,
    data: DATA,
}
// and so on ...
</code></pre>
<p>In order to contract the loop, the user must provide the loop-invariant for the variable <code>kani_iter</code>, which is modified and 
will be havocked. 
The loop-invariant should include some propositions such as <code>kani_iter.inner.alive.start &lt;= kani_iter.inner.alive.end</code>,
<code>kani_iter.inner.data.as_ptr() == a.as_ptr()</code>, ... until the loop-invariant is successfully verified.
The obvious three disadvantages are:</p>
<ol>
<li>All the fields <code>inner</code>, <code>alive</code>, <code>start</code>, <code>end</code>, ... are private, so those propositions are not allowed by the Rust compiler.</li>
<li>The users must know about all the implementation designs and related internal types that the Rust standard library uses 
to implement the <code>into_iter</code> function, and everything are different for the types that implements the <code>IntoIter</code> trait. 
Even then, it is so complicated and tedious to write the loop-invariant. </li>
<li>The long call stack will slow down the performance.</li>
</ol>
<p>To avoid those disadvantages, we override the <code>into_iter</code> function and <code>IntoIter</code> trait by our own version (<code>kani_into_iter()</code> and <code>KaniIntoIter</code>) 
with a simplified implementation but keeping the same semantics.
Our rewritten version for the <code>for-loop</code> is as follows:</p>
<pre><code class="language-Rust">let a: [u8; 10] = kani::any();
let kani_iter_xxxx = kani::kani_into_iter(a);
let kani_iter_len = kani_iter_xxxx.len();
let mut i = kani_iter_xxxx.first()
let mut kani_index = 0;
#[kani::loop_invariant(...)]
while kani_index &lt; kani_iter_len {
  i = kani_iter_xxxx.nth(kani_index);
  kani_index += 1;
}
</code></pre>
<p>The advantages of our rewrite method are: </p>
<ol>
<li>Better user experience: the users can specify loop-invariants for <code>for-loop</code> based on their intuitive understanding of the code,
not the Rust standard library implementation.</li>
<li>Lower proof maintainence cost: the loop-invariant does not depend on Rust standard library implementation of Iterators,
so they are less likely to be broken by toolchain updates. </li>
<li>Faster verification performance because of shorter call stack.</li>
</ol>
<p>The disadvantages are: </p>
<ol>
<li>Kani can only support loop-invariants for <code>for-loop</code> for collections that implement <code>KaniIntoIter</code> trait.
We have to gradually implement them on-demand to extend the number of collection types that Kani supports.</li>
<li>We build <code>KaniIntoIter</code> implementations according the semantic of Rust <code>IntoIter</code> implementations, 
so the soundness of our verification result depends on the correctness of Rust standard library implementations, 
which should be verified separately.</li>
</ol>
<h2 id="rationale-and-alternatives-8"><a class="header" href="#rationale-and-alternatives-8">Rationale and alternatives</a></h2>
<h3 id="rust-level-transformation-vs-cbmc"><a class="header" href="#rust-level-transformation-vs-cbmc">Rust-Level Transformation vs CBMC</a></h3>
<p>Besides transforming the loops in GOTO level using <code>goto-instrument</code>,
we could also do the transformation in Rust level using procedural macros, or
in MIR level.</p>
<p>There are two reasons we prefer the GOTO-level transformation.
First, <code>goto-instrument</code> is a mature tool that can correctly instrument the frame
condition checking for the transformed loop, which will save us from reinventing
the error-prone wheel. Second, the loop contracts synthesis tool we developed and
are developing are all based on GOTO level. Hence, doing the transformation in
the GOTO level will make the integration of loop contracts with the synthesis tool
easier.</p>
<h2 id="open-questions-12"><a class="header" href="#open-questions-12">Open questions</a></h2>
<ul>
<li>How do we integrate loop contracts with the synthesis tool? When the user-provided
loop contracts are not enough prove the harness, we expect the loop-contract synthesizer
can fix the loop contracts.</li>
<li>How do we translate back modify targets that inferred by CBMC to Rust level? </li>
<li>It is not clear how the CBMC loop modifies inference works for Rust code. We need to
experiment more to decide what would be the best UX of using loop modifies.</li>
<li>How do we handle havocing in unsafe code where it is fine to break the safety invariant
of Rust? In that case, we may need havocing function that preserves validity invariant
but not safety invariant.</li>
<li>What is the proper mechanism for users to specify the loops that they want to opt-out from applying loop contracts, and (optionally) the unwind numbers for them. Such options should be per-harness.</li>
</ul>
<h2 id="future-possibilities-11"><a class="header" href="#future-possibilities-11">Future possibilities</a></h2>
<ul>
<li>We can employ CBMC's decreases inference to infer the decreases clauses to reduce the
user burden of specifying the decreases clauses.</li>
</ul>
<!-- For Developers -->
<hr />
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> List Subcommand</li>
<li><strong>Feature Request Issue:</strong> <a href="https://github.com/model-checking/kani/issues/2573">#2573</a>, <a href="https://github.com/model-checking/kani/issues/1612">#1612</a></li>
<li><strong>RFC PR:</strong> #3463</li>
<li><strong>Status:</strong> Stable</li>
<li><strong>Version:</strong> 3</li>
</ul>
<hr />
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>Add a subcommand <code>list</code> that, for each crate under verification, lists the information relevant to its verification.</p>
<h2 id="user-impact-13"><a class="header" href="#user-impact-13">User Impact</a></h2>
<p>Currently, there is no automated way for a user to gather metadata about Kani's integration with their project. If, for example, a user wants a list of harnesses for their project, they must search for all the relevant contract attributes (currently <code>#[proof]</code> or <code>#[proof_for_contract]</code>) themselves. If done manually, this process is tedious, especially for large projects. Even with a shell script, it is error-prone--if, for example, we introduce a new type of proof harness, users would have to account for it when searching their project.</p>
<p>Internally, this feature will be useful for tracking our customers' use of Kani and our progress with standard library verification. Externally, users can leverage this feature to get a high-level view of which areas of their projects have harnesses (and, by extension, which areas are still in need of verification).</p>
<p>This feature will not cause any regressions for exisiting users.</p>
<h2 id="user-experience-13"><a class="header" href="#user-experience-13">User Experience</a></h2>
<p>Users run a <code>list</code> subcommand, which prints metadata about the harnesses and contracts in each crate under verification. The subcommand takes two options:</p>
<ul>
<li><code>--format=[pretty|markdown|json]</code>: choose the output format. The default is <code>pretty</code>, which prints to the terminal. <code>markdown</code> and <code>json</code> write to Markdown and JSON files instead, respectively.</li>
<li><code>--std</code>: this option should be specified when listing the harnesses and contracts in the standard library. This option is only available for <code>kani list</code> (not <code>cargo kani list</code>), which mirrors the verification workflow for the standard library.</li>
</ul>
<p>This subcommand does not fail. In the case that it does not find any harnesses or contracts, it prints a message informing the user of that fact.</p>
<h3 id="pretty-format"><a class="header" href="#pretty-format">Pretty Format</a></h3>
<p>The default format, <code>pretty</code>, prints a &quot;Contracts&quot; table and a &quot;Standard Harnesses&quot; list.
Each row of the &quot;Contracts&quot; table consists of a function under contract and its contract harnesses.
The results are printed in lexicographic order.</p>
<p>For example:</p>
<pre><code>Kani Rust Verifier 0.65.0 (standalone)

Contracts:
+-------+----------+-------------------------------+----------------------------------------------------------------+
|       | Crate    | Function                      | Contract Harnesses (#[kani::proof_for_contract])               |
+===================================================================================================================+
|       | my_crate | example::implementation::bar  | example::verify::check_bar                                     |
|-------+------------+-----------------------------+----------------------------------------------------------------|
|       | my_crate | example::implementation::foo  | example::verify::check_foo_u32, example::verify::check_foo_u64 |
|-------+------------+-----------------------------+----------------------------------------------------------------|
|       | my_crate | example::implementation::func | example::verify::check_func                                    |
|-------+------------+-----------------------------+----------------------------------------------------------------|
|       | my_crate | example::prep::parse          | NONE                                                           |
|-------+----------+-------------------------------+----------------------------------------------------------------|
| Total |          | 4                             | 4                                                              |
+-------+----------+-------------------------------+----------------------------------------------------------------+

Standard Harnesses (#[kani::proof]):
+-------+----------+-------------------------------+
|       | Crate    | Harness                       |
+==================================================+
|       | my_crate | example::verify::check_modify |
|-------+----------+-------------------------------|
|       | my_crate | example::verify::check_new    |
|-------+----------+-------------------------------|
| Total |          | 2                             |
+-------+----------+-------------------------------+
</code></pre>
<p>All sections will be present in the output, regardless of the result.
If there are no harnesses for a function under contract, Kani inserts <code>NONE</code> in the &quot;Contract Harnesses&quot; column.
If the &quot;Contracts&quot; section is empty, Kani prints a message that &quot;No contracts or contract harnesses were found.&quot;
If the &quot;Standard Harnesses&quot; section is empty, Kani prints a message that &quot;No standard harnesses were found.&quot;</p>
<h3 id="json-format"><a class="header" href="#json-format">JSON Format</a></h3>
<p>If the user wants an output format that's more easily parsed by a script, they can use the <code>json</code> option. </p>
<p>The JSON format will contain the same information as the pretty format, with the addition of file paths and file version.
The file version will use semantic versioning.
This way, any users relying on this format for their scripts can detect when we've released a new major version and update their logic accordingly.</p>
<p>For example:</p>
<pre><code class="language-json">{
    kani-version: 0.65,
    file-version: 0.1,
    standard-harnesses: [
        {
            file: /Users/johnsmith/example/kani_standard_proofs.rs
            harnesses: [
                example::verify::check_modify,
                example::verify::check_new
            ]
        },
    ],
    contract-harnesses: [
        {
            file: /Users/johnsmith/example/kani_contract_proofs.rs
            harnesses: [
                example::verify::check_bar,
                example::verify::check_baz,
                example::verify::check_foo_u32,
                example::verify::check_foo_u64, 
                example::verify::check_func 
            ]
        },
    ],
    contracts: [
        {
            function: example::impl::bar
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_bar]
        },
        {
            function: example::impl::baz
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_baz]
        },
        {
            function: example::impl::foo
            file: /Users/johnsmith/example/impl.rs
            harnesses: [
                example::verify::check_foo_u32,
                example::verify::check_foo_u64
            ]
        },
        {
            function: example::impl::func
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_func]
        },
        {
            function: example::prep::parse
            file: /Users/johnsmith/example/prep.rs
            harnesses: []
        }
    ],
    totals: {
        standard-harnesses: 2,
        contract-harnesses: 5,
        functions-with-contracts: 5,
    }
}
</code></pre>
<p>All sections will be present in the output, regardless of the result.
If there is no result for a given field (e.g., there are no contracts), Kani will output an empty list (or zero for totals).</p>
<h2 id="software-design-1"><a class="header" href="#software-design-1">Software Design</a></h2>
<h3 id="drivermetdata-changes"><a class="header" href="#drivermetdata-changes">Driver/Metdata Changes</a></h3>
<p>We add a new <code>list</code> subcommand to <code>kani-driver</code>, which invokes the compiler to collect metadata, then post-processes that metadata and outputs the result.
We extend <code>KaniMetadata</code> to include a new field containing each function under contract and its contract harnesses.</p>
<h3 id="compiler-changes"><a class="header" href="#compiler-changes">Compiler Changes</a></h3>
<p>In <code>codegen_crate</code>, we update the generation of <code>KaniMetadata</code> to include the new contracts information.
We iterate through each local item in the crate.
Each time we find a function under contract or a contract harness, we include it in the metadata.</p>
<h2 id="rationale-and-alternatives-9"><a class="header" href="#rationale-and-alternatives-9">Rationale and alternatives</a></h2>
<p>Users of Kani may have many questions about their project--not only where their contracts and harnesses are, but also where their stubs are, what kinds of contracts they have, etc. Rather than try to answer every question a user might have, which would make the output quite verbose, we focus on these four:</p>
<ol>
<li>Where are the harnesses?</li>
<li>Where are the contracts?</li>
<li>Which contracts are verified, and by which harnesses?</li>
<li>How many harnesses and functions under contract are there?</li>
</ol>
<p>We believe these questions are the most important for our use cases of tracking verification progress for customers and the standard library. The UX is designed to answer these questions clearly and concisely.</p>
<p>We could have a more verbose or granular output, e.g., printing the metadata on a per-crate or per-module level, or including stubs or other attributes. Such a design would have the benefit of providing more information, with the disadvantage of being more complex to implement and more information for the user to process.
If we do not implement this feature, users will have to obtain this metadata through manual searching, or by writing a script to do it themselves. This feature will improve our internal productivity by automating the process.</p>
<p>The Contracts table is close to Markdown, but not quite Markdown--it includes line separators between each row, when Markdown would only have a separator for the header.
We include the separator because without it, it can be difficult to tell from reading the terminal output which entries are in the same row.
The user can transform the table to Markdown by deleting these separators, and we can trivially add a Markdown option in the future if there is demand for it.</p>
<h2 id="open-questions-13"><a class="header" href="#open-questions-13">Open questions</a></h2>
<ol>
<li>Do we want to include more contracts information? We could print more granular information about contracts, e.g., the text of the contracts or the number of contracts.</li>
<li>More generally, we could introduce additional options that collect information about other Kani attributes (e.g., stubs). The default would be to leave them out, but this way a user could get more verbose output if they so choose.</li>
<li>Do we want to add a filtering option? For instance, <code>--harnesses &lt;pattern&gt;</code> and <code>--contracts &lt;pattern&gt;</code>, where <code>pattern</code> corresponds to a Rust-style path. For example, <code>kani list --harnesses &quot;my_crate::my_module::*&quot;</code> would include all harnesses with that path prefix, while <code>kani list --contracts &quot;my_crate::my_module::*&quot;</code> would include all functions under contract with that path prefix. (If we do this work, we could use it to improve our <code>--harness</code> <a href="https://github.com/model-checking/kani/blob/main/kani-driver/src/metadata.rs#L187-L189">pattern handling for verification</a>).</li>
</ol>
<h2 id="out-of-scope--future-improvements-1"><a class="header" href="#out-of-scope--future-improvements-1">Out of scope / Future Improvements</a></h2>
<p>It would be nice to differentiate between regular Kani harnesses and Bolero harnesses. Bolero harnesses invoke Kani using conditional compilation, e.g.:</p>
<pre><code class="language-rust">#[cfg_attr(kani, kani::proof)]
fn check() {
    bolero::check!()...
}
</code></pre>
<p>See <a href="https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html">this blog post</a> for more information.</p>
<p>There's no easy way for us to know whether a harness comes from Bolero, since Bolero takes care of rewriting the test to use Kani syntax and invoking the Kani engine. By the time the harness gets to Kani, there's no way for us to tell it apart from a regular harness. Fixing this would require some changes to our Bolero integration.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
