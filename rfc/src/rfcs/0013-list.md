- **Feature Name:** List Subcommand
- **Feature Request Issue:** [#2573](https://github.com/model-checking/kani/issues/2573), [#1612](https://github.com/model-checking/kani/issues/1612)
- **RFC PR:** #3463
- **Status:** Unstable
- **Version:** 2

-------------------

## Summary

Add a subcommand `list` that, for each crate under verification, lists the information relevant to its verification.

## User Impact

Currently, there is no automated way for a user to gather metadata about Kani's integration with their project. If, for example, a user wants a list of harnesses for their project, they must search for all the relevant contract attributes (currently `#[proof]` or `#[proof_for_contract]`) themselves. If done manually, this process is tedious, especially for large projects. Even with a shell script, it is error-prone--if, for example, we introduce a new type of proof harness, users would have to account for it when searching their project.

Internally, this feature will be useful for tracking our customers' use of Kani and our progress with standard library verification. Externally, users can leverage this feature to get a high-level view of which areas of their projects have harnesses (and, by extension, which areas are still in need of verification).

This feature will not cause any regressions for exisiting users.

## User Experience

Users run a `list` subcommand, which prints metadata about the harnesses and contracts in each crate under verification. The subcommand takes two options:
- `--message-format=[pretty|json]`: change the output format. The default is `pretty`, which prints to the terminal. The `json` option creates and writes to a JSON file instead.
- `--std`: Include if we are running on the standard library. This option is only available for `kani list` (not `cargo kani list`), which mirrors the verification workflow for the standard library.

This subcommand does not fail. In the case that it does not find any harnesses or contracts, it prints a message informing the user of that fact.

### Pretty Format

The default format, `pretty`, prints a "Contracts" table and a "Standard Harnesses" list.
Each row of the "Contracts" table consists of a function, the number of contracts it has, and its contract harnesses.
A function is listed if it has contracts or it is the target of contract harness(es).
The results are printed in lexographic order.

For example:

```
Kani Rust Verifier 0.54.0 (standalone)

Contracts:
Each function in the table below either has contracts 
or is the target of a contract harness (#[kani::proof_for_contract]).

|-------|-------------------------|----------------|-------------------------------------|
|       | Function                | # of Contracts | Contract Harnesses                  |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::bar      | 4              | example::verify::check_bar          |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::baz      | 0              | example::verify::check_baz          |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::foo      | 2              | example::verify::check_foo_u32      |
|       |                         |                | example::verify::check_foo_u64      |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::func     | 1              | example::verify::check_func         |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::prep::parse    | 1              | NONE                                |
|-------|-------------------------|----------------|-------------------------------------|
| Total | 5                       | 8              | 5                                   |
|-------|-------------------------|----------------|-------------------------------------|

Standard Harnesses (#[kani::proof]):
1. example::verify::check_modify
2. example::verify::check_new
```

All sections will be present in the output, regardless of the result.
If there are no harnesses for a function under contract, Kani inserts `NONE` in the "Contract Harnesses" row.
If the "Contracts" section is empty, Kani prints a message that "No contracts or contract harnesses were found."
If the "Standard Harnesses" section is empty, Kani prints a message that "No standard harnesses were found."

### JSON Format

If the user wants an output format that's more easily parsed by a script, they can use the `json` option. 

The JSON format will contain the same information as the pretty format, with the addition of file paths and file version.
The file version will use semantic versioning.
This way, any users relying on this format for their scripts can detect when we've released a new major version and update their logic accordingly.

For example:

```json
{
    kani-version: 0.54,
    file-version: 0.1,
    standard-harnesses: [
        {
            file: /Users/johnsmith/example/kani_standard_proofs.rs
            harnesses: [
                example::verify::check_modify,
                example::verify::check_new
            ]
        },
    ],
    contract-harnesses: [
        {
            file: /Users/johnsmith/example/kani_contract_proofs.rs
            harnesses: [
                example::verify::check_bar,
                example::verify::check_baz,
                example::verify::check_foo_u32,
                example::verify::check_foo_u64, 
                example::verify::check_func 
            ]
        },
    ],
    contracts: [
        {
            function: example::impl::bar
            total_contracts: 4
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_bar]
        },
        {
            function: example::impl::baz
            total_contracts: 0
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_baz]
        },
        {
            function: example::impl::foo
            total_contracts: 2
            file: /Users/johnsmith/example/impl.rs
            harnesses: [
                example::verify::check_foo_u32,
                example::verify::check_foo_u64
            ]
        },
        {
            function: example::impl::func
            total_contracts: 1
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_func]
        },
        {
            function: example::prep::parse
            total_contracts: 1
            file: /Users/johnsmith/example/prep.rs
            harnesses: []
        }
    ],
    totals: {
        standard-harnesses: 2,
        contract-harnesses: 5,
        functions-with-contracts: 5,
        contracts: 8,
    }
}
```

All sections will be present in the output, regardless of the result.
If there is no result for a given field (e.g., there are no contracts), Kani will output an empty list (or zero for totals).

## Software Design

### Metdata Changes
We introduce a new `ContractedFunction` struct to `kani_metadata`:
```rust
pub struct ContractedFunction {
    /// The fully qualified name the user gave to the function (i.e. includes the module path).
    pub function: String,
    /// The (currently full-) path to the file this function was declared within.
    pub file: String,
    /// The number of contracts applied to this function
    pub total_contracts: usize,
    /// The pretty names of the proof harnesses (`#[kani::proof_for_contract]`) for this function
    pub harnesses: Vec<String>,
}
```
We extend `KaniMetadata` with a new `contracted_functions: Vec<ContractedFunction>` field.

### Driver Changes
We add a new subcommand to `kani-driver`.
This subcommand exists for both `cargo kani` and `kani` invocations.
The driver constructs a `Project` representing the input.
(For `kani` invocations, the driver either constructs a `standalone_project` or a `std_project` depending on whether the use passed the `--std` flag).
The `Project` is populated with `metadata: Vec<KaniMetadata>` from `kani-compiler`.
We iterate through this metadata to print a table with the results or output a `kani-list.json` file, depending on the user-specified `format` argument.

### Compiler Changes

In `codegen_crate`, we update the generation of `KaniMetadata` to include the new `contracted_functions` field.
We populate this field in two parts:

#### Part 1: Map Functions to Harnesses

First, we iterate through each local item in the crate and construct a map of functions under contract to their contract harnesses.
We iterate through each local item in the crate (`stable_mir::CrateItem`), not each local *instance* (`stable_mir::Instance`).
This is so that we can include generic functions with contracts in the output.
`Instances` are monomorphized.
When we're verifying a contract harness, this monomorphization assumption is fine; if the harness calls the function under contract, a monomorphized version of the function must exist.
However, if we are just trying to list metadata, we cannot rely on this assumption that the function under contract gets called, and therefore cannot assume that a monomorphized version of the generic function exists.
For example, imagine running `kani list` on a file with only these contents:
```rust
#[kani::requires(true)]
fn foo<T>(x: T) -> T { x }
```
Kani should be able to find `foo` and report it has a contract,
but we cannot construct a `stable_mir::Instance` from `foo` because it requires monomorphization.

#### Part 2: Count Contracts
Since we are counting the contracts at the MIR level, we work with the expanded version of the contract attribute macros.
We locate the body of the `kanitool::checked_with` closure, then count the number of `kani::assume()` and `kani::assert()` calls.
For example, given the following code (example taken from `kani_macros` contracts documentation):

```rust
#[kani::requires(divisor != 0)]
#[kani::ensures(|result : &u32| *result <= dividend)]
fn div(dividend: u32, divisor: u32) -> u32 {
    dividend / divisor
}
```

The generated `check` closure is:

```rust
let mut __kani_check_div =
    || -> u32
        {
            kani::assume(divisor != 0);
            let _wrapper_arg = ();
            #[kanitool::is_contract_generated(wrapper)]
            #[allow(dead_code, unused_variables, unused_mut)]
            let mut __kani_modifies_div =
                |_wrapper_arg| -> u32 { dividend / divisor };
            let result_kani_internal: u32 =
                __kani_modifies_div(_wrapper_arg);
            kani::assert(kani::internal::apply_closure(|result: &u32|
                        *result <= dividend, &result_kani_internal),
                "|result : &u32| *result <= dividend");
            result_kani_internal
        };
;
```

Observe that there is one `kani::assume()` call for the `requires` contract and one `kani::assert()`
call for the `ensures` contract, so we can obtain the total number of contracts by counting these calls.

Once these parts are complete, we generate a `ContractedFunction` object for each function under contract and populate it with the data gathered above.

## Rationale and alternatives

Users of Kani may have many questions about their project--not only where their contracts and harnesses are, but also where their stubs are, what kinds of contracts they have, etc. Rather than try to answer every question a user might have, which would make the output quite verbose, we focus on these four:

1. Where are the harnesses?
2. Where are the contracts?
3. Which contracts are verified, and by which harnesses?
4. How many harnesses and contracts are there?

We believe these questions are the most important for our use cases of tracking verification progress for customers and the standard library. The UX is designed to answer these questions clearly and concisely.

We could have a more verbose or granular output, e.g., printing the metadata on a per-crate or per-module level, or including stubs or other attributes. Such a design would have the benefit of providing more information, with the disadvantage of being more complex to implement and more information for the user to process.

If we do not implement this feature, users will have to obtain this metadata through manual searching, or by writing a script to do it themselves. This feature will improve our internal productivity by automating the process.

### Modifies Clauses
As discussed in [Software Design](#software-design), the contracts count includes `requires` and `ensures` contracts only.
We do not include `modifies` clauses for two reasons:
1. `modifies` clauses are not really "contracts" in the same way that `requires` and `ensures` are--they are important for our contracts instrumentation (c.f. [#2594](https://github.com/model-checking/kani/issues/2594)), but it's not as if Kani goes and verifies that the function actually modifies the pointer.
For example, if I write this:

```rust
#[kani::modifies(x)]
fn foo(x: &mut u32) {}

#[kani::proof_for_contract(foo)]
fn check_foo() {
    let mut x = 7;
    foo(&mut x);
}
```
verification succeeds even though `foo` does not modify the location to which `x` points.

2. `kani_macros` folds the arguments to each `modifies` into a single tuple, e.g.:
```rust
#[modifies(x)]
#[modifies(y)]
fn foo(x: &mut u32, y: &mut u32) {}
```

```rust
#[modifies(x, y)]
fn foo(x: &mut u32, y: &mut u32) {}
```

are indistinguishable once the macro expansion finishes.
We could of course count the modifies clauses before macro expansion, but even if we do, it's not clear whether counting the number of *attributes* or *arguments* is more intuitive.
In the latter example above, do we have two modifies clauses (one each for `x` and `y`), or just one, since we only wrote one `#[modifies]`?

I decided it was better to not include modifies clauses to avoid confusing the user.
Thus, for functions that only have modifies clauses, the subcommand will report that the user has zero contracts.
However, users could still be confused by this choice because Kani allows users to run `proof_for_contract` harnesses on functions that only have `modifies` clauses.
(If Kani detects no contract-related attributes at all, it errors.)
A user may be confused as to why the list subcommand reports zero contracts when they are running a `proof_for_contract` harness without errors.

### Compiler - Build Cache
The compiler is unaware of the list subcommand; i.e., there are no special arguments to indicate to the compiler that the list subcommand is running.
If the user only wants to invoke the list subcommand, this design wastes work, since Kani generates unnecessary GOTO files.
However, it also allows the compiler to take advantage of the build cache.
If a user verifies their code and then invokes `list` (or vice versa),
the compiler will be invoked with the same arguments both times, which means that it can just use the cached targets from the first compiler invocation.

## Open questions

1. Do we want to include more contracts information? We could print more granular information about contracts, e.g., the text of the contracts or the number of `requires` and `ensures` contracts.
2. More generally, we could introduce additional options that collect information about other Kani attributes (e.g., stubs). The default would be to leave them out, but this way a user could get more verbose output if they so choose.
3. Do we want to add a filtering option? For instance, `--harnesses <pattern>` and `--contracts <pattern>`, where `pattern` corresponds to a Rust-style path. For example, `kani list --harnesses "my_crate::my_module::*"` would include all harnesses with that path prefix, while `kani list --contracts "my_crate::my_module::*"` would include all functions under contract with that path prefix. (If we do this work, we could use it to improve our `--harness` [pattern handling for verification](https://github.com/model-checking/kani/blob/main/kani-driver/src/metadata.rs#L187-L189)).

## Out of scope / Future Improvements

It would be nice to differentiate between regular Kani harnesses and Bolero harnesses. Bolero harnesses invoke Kani using conditional compilation, e.g.:

```rust
#[cfg_attr(kani, kani::proof)]
fn check() {
    bolero::check!()...
}
```

See [this blog post](https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html) for more information.

There's no easy way for us to know whether a harness comes from Bolero, since Bolero takes care of rewriting the test to use Kani syntax and invoking the Kani engine. By the time the harness gets to Kani, there's no way for us to tell it apart from a regular harness. Fixing this would require some changes to our Bolero integration.
