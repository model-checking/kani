- **Feature Name:** List Subcommand
- **Feature Request Issue:** [#2573](https://github.com/model-checking/kani/issues/2573), [#1612](https://github.com/model-checking/kani/issues/1612)
- **RFC PR:** #3463
- **Status:** Under Review
- **Version:** 2

-------------------

## Summary

Add a subcommand `list` that, for each crate under verification, lists the information relevant to its verification.

## User Impact

Currently, there is no automated way for a user to gather metadata about Kani's integration with their project. If, for example, a user wants a list of harnesses for their project, they must search for all the relevant contract attributes (currently `#[proof]` or `#[proof_for_contract]`) themselves. If done manually, this process is tedious, especially for large projects. Even with a shell script, it is error-prone--if, for example, we introduce a new type of proof harness, users would have to account for it when searching their project.

Internally, this feature will be useful for tracking our customers' use of Kani and our progress with standard library verification. Externally, users can leverage this feature to get a high-level view of which areas of their projects have harnesses (and, by extension, which areas are still in need of verification).

This feature will not cause any regressions for exisiting users.

## User Experience

Users run a `list` subcommand, which prints metadata about the harnesses and contracts in each crate under verification. The subcommand takes two options:
- `--message-format=[pretty|json]`: change the output format. The default is `pretty`, which prints to the terminal. The `json` option creates and writes to a JSON file instead.
- `--std`: Include if we are running on the standard library. This option is only available for `kani list` (not `cargo kani list`), which mirrors the verification workflow for the standard library.

This subcommand does not fail. In the case that it does not find any harnesses or contracts, it prints a message informing the user of that fact.

### Pretty Format

The default format, `pretty`, prints a "Contracts" table and a "Standard Harnesses" list.
Each row of the "Contracts" table consists of a function, the number of contracts it has, and its contract harnesses.
A function is listed if it has contracts or it is the target of contract harness(es).

For example:

```
Kani Rust Verifier 0.54.0 (standalone)

Contracts:
Each function in the table below either has contracts 
or is the target of a contract harness (#[kani::proof_for_contract]).

|-------|-------------------------|----------------|-------------------------------------|
|       | Function                | # of Contracts | Contract Harnesses                  |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::bar      | 4              | example::verify::check_bar          |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::baz      | 0              | example::verify::check_baz          |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::foo      | 2              | example::verify::check_foo_u32      |
|       |                         |                | example::verify::check_foo_u64      |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::impl::func     | 1              | example::verify::check_func         |
|-------|-------------------------|----------------|-------------------------------------|
|       | example::prep::parse    | 1              | NONE                                |
|-------|-------------------------|----------------|-------------------------------------|
| Total | 5                       | 8              | 5                                   |
|-------|-------------------------|----------------|-------------------------------------|

Standard Harnesses (#[kani::proof]):
1. example::verify::check_new
2. example::verify::check_modify
```

All sections will be present in the output, regardless of the result.
If there are no harnesses for a function under contract, Kani inserts `NONE` in the "Contract Harnesses" row.
If the "Contracts" section is empty, Kani prints a message that "No contracts or contract harnesses were found."
If the "Standard Harnesses" section is empty, Kani prints a message that "No standard harnesses were found."

### JSON Format

If the user wants an output format that's more easily parsed by a script, they can use the `json` option. 

The JSON format will contain the same information as the pretty format, with the addition of file paths and file version.
The file version will use semantic versioning.
This way, any users relying on this format for their scripts can detect when we've released a new major version and update their logic accordingly.

For example:

```json
{
    kani-version: 0.54,
    file-version: 0.1,
    standard-harnesses: [
        {
            file: /Users/johnsmith/example/kani_standard_proofs.rs
            harnesses: [
                example::verify::check_modify,
                example::verify::check_new
            ]
        },
    ],
    contract-harnesses: [
        {
            file: /Users/johnsmith/example/kani_contract_proofs.rs
            harnesses: [
                example::verify::check_bar,
                example::verify::check_baz,
                example::verify::check_foo_u32,
                example::verify::check_foo_u64, 
                example::verify::check_func 
            ]
        },
    ],
    contracts: [
        {
            function: example::impl::bar
            total_contracts: 4
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_bar]
        },
        {
            function: example::impl::baz
            total_contracts: 0
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_baz]
        },
        {
            function: example::impl::foo
            total_contracts: 2
            file: /Users/johnsmith/example/impl.rs
            harnesses: [
                example::verify::check_foo_u32,
                example::verify::check_foo_u64
            ]
        },
        {
            function: example::impl::func
            total_contracts: 1
            file: /Users/johnsmith/example/impl.rs
            harnesses: [example::verify::check_func]
        },
        {
            function: example::prep::parse
            total_contracts: 1
            file: /Users/johnsmith/example/prep.rs
            harnesses: []
        }
    ],
    totals: {
        standard-harnesses: 2,
        contract-harnesses: 5,
        functions-with-contracts: 5,
        contracts: 8,
    }
}
```

All sections will be present in the output, regardless of the result.
If there is no result for a given field (e.g., there are no contracts), Kani will output an empty list (or zero for totals).

## Software Design

### Metdata Changes
We introduce a new `ContractedFunction` struct to `kani_metadata`:
```rust
pub struct ContractedFunction {
    /// The fully qualified name the user gave to the function (i.e. includes the module path).
    pub function: String,
    /// The (currently full-) path to the file this function was declared within.
    pub file: String,
    /// The number of contracts applied to this function
    pub total_contracts: usize,
    /// The pretty names of the proof harnesses (`#[kani::proof_for_contract]`) for this function
    pub harnesses: Vec<String>,
}
```
We extend `KaniMetadata` and `CodegenUnits` with new `contracted_functions: Vec<ContractedFunction>` fields.

### Compiler Changes

This subcommand is concerned with two fields of `KaniMetadata`: `proof_harnesses` and `contracted_functions`.
In `codegen_crate()`, `kani-compiler` will check if we are running the list subcommand, and, if so, it constructs a new `CodegenUnits` object.
The `CodegenUnits` constructor handles initializing the `proof_harnesses` field for us.
We add new functionality to populate the `contracted_functions` field, which we explain in two parts:

#### Part 1: Map Functions to Harnesses

First, we iterate through each local item in the crate and construct a map of functions to contract harnesses.
The keys in this map are functions that either 1) have contracts or 2) are targets of contract harnesses.
These are not necessarily identical sets; functions under contract may not have harnesses, and targets of contract harnesses may not have contracts.

Observe that we iterate through each local item in the crate (`stable_mir::CrateItem`), not each local *instance* (`stable_mir::Instance`).
This is so that we can include generic functions with contracts in the output.
`Instances` are monomorphized.
When we're verifying a contract harness, this monomorphization assumption is fine;  if the harness calls the function under contract, a monomorphized version of the function must exist.
However, if we are just trying to list metadata, we cannot rely on this assumption that the function under contract gets called, and therefore cannot assume that a monomorphized version of the generic function exists.
For example, imagine running `kani list` on a file with only these contents:
```rust
#[kani::requires(true)]
fn foo<T>(x: T) -> T { x }
```
Kani should be able to find `foo` and report it has a contract,
but we cannot construct a `stable_mir::Instance` from `foo` because it requires monomorphization.

#### Part 2: Count Contracts
For each function in the map from Part 1, we count its contracts, then construct a `ContractedFunction` object for it.

Since we are counting the contracts at the MIR level, we work with the expanded version of the contract attribute macros.
We locate the body of the `kanitool::checked_with` closure, then count the number of `kani::assume()` and `kani::assert()` calls.
For example, given the following code (example taken from `kani_macros` contracts documentation):

```rust
#[kani::requires(divisor != 0)]
#[kani::ensures(|result : &u32| *result <= dividend)]
fn div(dividend: u32, divisor: u32) -> u32 {
    dividend / divisor
}
```

The generated `check` closure is:

```rust
let mut __kani_check_div =
    || -> u32
        {
            kani::assume(divisor != 0);
            let _wrapper_arg = ();
            #[kanitool::is_contract_generated(wrapper)]
            #[allow(dead_code, unused_variables, unused_mut)]
            let mut __kani_modifies_div =
                |_wrapper_arg| -> u32 { dividend / divisor };
            let result_kani_internal: u32 =
                __kani_modifies_div(_wrapper_arg);
            kani::assert(kani::internal::apply_closure(|result: &u32|
                        *result <= dividend, &result_kani_internal),
                "|result : &u32| *result <= dividend");
            result_kani_internal
        };
;
```

Observe that there is one `kani::assume()` call for the `requires` contract and one `kani::assert()`
call for the `ensures` contract, so we can obtain the total number of contracts by counting these calls.

Once these parts are complete, `CodegenUnits` contains all of the required metadata.
We use an existing method (`CodegenUnits::write_metadata`) to write this metadata to a file.

### Driver Changes
We add a new subcommand to `kani-driver`.
This subcommand exists for both `cargo kani` and `kani` invocations.
The driver constructs a `Project` representing the input.
(For `kani` invocations, the driver either constructs a `standalone_project` or a `std_project` depending on whether the use passed the `--std` flag).
The `Project` is populated with `metadata: Vec<KaniMetadata>` from `kani-compiler`.
We iterate through this metadata to print a table with the results or output a `kani-list.json` file, depending on the user-specified `format` argument.

## Rationale and alternatives

Users of Kani may have many questions about their project--not only where their contracts and harnesses are, but also where their stubs are, what kinds of contracts they have, etc. Rather than try to answer every question a user might have, which would make the output quite verbose, we focus on these four:

1. Where are the harnesses?
2. Where are the contracts?
3. Which contracts are verified, and by which harnesses?
4. How many harnesses and contracts are there?

We believe these questions are the most important for our use cases of tracking verification progress for customers and the standard library. The UX is designed to answer these questions clearly and concisely.

We could have a more verbose or granular output, e.g., printing the metadata on a per-crate or per-module level, or including stubs or other attributes. Such a design would have the benefit of providing more information, with the disadvantage of being more complex to implement and more information for the user to process.

If we do not implement this feature, users will have to obtain this metadata through manual searching, or by writing a script to do it themselves. This feature will improve our internal productivity by automating the process.

## Open questions

1. Do we want to include more contracts information? We could print more granular information about contracts, e.g., the text of the contracts, the number of `requires`, `ensures`, or `modifies` contracts, or the locations of the contracts.
2. More generally, we could introduce additional options that collect information about other Kani attributes (e.g., stubs). The default would be to leave them out, but this way a user could get more verbose output if they so choose.
3. Do we want to add a filtering option? For instance, `--harnesses <pattern>` and `--contracts <pattern>`, where `pattern` corresponds to a Rust-style path. For example, `kani list --harnesses "my_crate::my_module::*"` would include all harnesses with that path prefix, while `kani list --contracts "my_crate::my_module::*"` would include all functions under contract with that path prefix. (If we do this work, we could use it to improve our `--harness` [pattern handling for verification](https://github.com/model-checking/kani/blob/main/kani-driver/src/metadata.rs#L187-L189)).

## Out of scope / Future Improvements

It would be nice to differentiate between regular Kani harnesses and Bolero harnesses. Bolero harnesses invoke Kani using conditional compilation, e.g.:

```rust
#[cfg_attr(kani, kani::proof)]
fn check() {
    bolero::check!()...
}
```

See [this blog post](https://model-checking.github.io/kani-verifier-blog/2022/10/27/using-kani-with-the-bolero-property-testing-framework.html) for more information.

There's no easy way for us to know whether a harness comes from Bolero, since Bolero takes care of rewriting the test to use Kani syntax and invoking the Kani engine. By the time the harness gets to Kani, there's no way for us to tell it apart from a regular harness. Fixing this would require some changes to our Bolero integration.