- **Feature Name:** List (`list`)
- **Feature Request Issue:** *Link to issue*
- **RFC PR:** *Link to original PR*
- **Status:** Under Review
- **Version:** 0

-------------------

## Summary

Add a subcommand `kani list` that lists metadata about Kani's application to a project.

## User Impact

Currently, there is no automated way for a user to gather metadata about Kani's integration with their project. If, for example, a user wants a list of verified function contracts, they must:
    - Search for the relevant contract attributes (currently `#[requires]`, `#[ensures]`, or `#[modifies]`),
    - Compile a list of functions under contract based on the results of the above, then
    - Search for all harnesses marked (`#[kani::proof_for_contract]`).

If done manually, this process is tedious, especially for large projects. It is also error-prone--if, for example, we introduce a new type of contract attribute, users would have to account for it when searching their project.

Internally, this feature will be useful for tracking our customers' use of Kani and our progress with standard library verification.

Externally, users can leverage this feature to get a high-level view of which areas of their projects have Kani attributes (and, by extension, which areas are still in need of verification). This feature can act as a complement to our existing line-by-line coverage feature--one can imagine, for example, using this feature to *informally* identify which areas seem to have few to no harnesses, then using the coverage feature to *formally* identify which areas remain unverified.

This feature will not cause any regressions for exisiting users.

## User Experience

Users run a `kani list` subcommand, which prints to the terminal metadata about the harnesses and contracts, and stubs in each reachable module.
For `cargo kani`, this will be every module in the package; for `kani`, it is every module in the crate.
This subcommand will not run verification; it will exit after printing the information.

Kani will print the package's modules as a tree. The leaves of the tree are functions with Kani attributes. 
After printing the tree, Kani will print the total count of certain attributes.
For example:

```
crate example
├── mod implementation:
│   └── fn foo 
|       └── requires-contracts: #[requires::ub_checks::can_dereference(x)], #[requires::ub_checks::can_write(x)]
|       └── ensures-contracts: #[ensures(|result| *result == *x + 1)]
|       └── modifies-contracts: #[modifies(x)]
|       └── proofs-for-contracts: verify_foo::check_foo_u32, verify_foo::check_foo_u64
├── mod verify:
|   └── fn check_foo_u32: HARNESS
|       └── kani-attributes: #[kani::proof_for_contract(foo)]
|   └── fn check_foo_u64: HARNESS
|       └── kani-attributes: #[kani::proof_for_contract(foo)]
│   └── fn check_func: HARNESS
|       └── kani-attributes: #[kani::proof], #[kani::should_panic], #[kani::stub(rand::random, mock_random)]
|   └── fn check_bar: HARNESS (BOLERO)
|       └── kani-attributes: #[kani::proof], #[kani::unwind(5)]

Totals:
    - Harnesses (including Bolero): 4
    - Bolero Harnesses: 1
    - Requires Contracts: 2
    - Ensures Contracts: 1
    - Modifies Contracts: 1
    - Stubs: 1
```

There will be two options:
- `--filter=[harnesses|contracts]`: Only output the information specified. In the example above, `--filter harnesses` would output the `mod verify` entry and `--filter contracts` would output the `mod implementation` entry. In the case where harnesses and contracts are in the same module, Kani will output only the functions that are harnesses or have contracts, depending on the filter.
- `--message-format=[human|json]`: Specify the output format. The default is `human`, which prints to the terminal. The `json` option creates and writes to a JSON file instead.

This subcommand will not fail. In the case that it does not find any Kani attributes, it will print a message informing the user of that fact.

## Software Design

This is the beginning of the technical portion of the RFC.
From now on, your main audience is Kani developers, so it's OK to assume readers know Kani architecture.

Please provide a high level description your design.

We will add a new subcommand to `kani-driver`, which, when invoked, follows the normal verification workflow of invoking `kani-compiler` and constructing a `Project` from the result. Then, instead of verifying the project, Kani will iterate over the `KaniMetadata` in the `Project` to construct the output.

For each function with contracts, I would like to store the fully qualified path and the contract text (e.g `core::num::add -> [requires(x == 1), ensures(result == 2)]`). I want the fully qualified path to uniquely identify the function--if I just stored `add`, then I wouldn't be able to tell multiple `add` functions apart. However, macro expansion happens before name resolution, so AFAIK by the time the fully qualified function name is available, the contract has already been expanded and the text the user wrote is gone. Does anyone have ideas for how to achieve what I want?

### Constructing the Tree

just iterate through the pretty names



- What are the main components that will be modified? (E.g.: changes to `kani-compiler`, `kani-driver`, metadata, proc-macros, installation...)
- Will there be changes to the components interface?
- Any changes to how these components communicate?
- What corner cases do you anticipate?



**We recommend you to leave this empty for the first version of your RFC**.

## Rationale and alternatives

This is the section where you discuss the decisions you made.

- What are the pros and cons of the UX? What would be the alternatives?
- What is the impact of not doing this?
- Any pros / cons on how you designed this?

## Open questions

List of open questions + an optional link to an issue that captures the work required to address the open question.
Capture the details of each open question in their respective issue, not here.

Example:
- Is there any use case that isn't handled yet?
- Is there any part of the UX that still needs some improvement?

Make sure all open questions are addressed before stabilization.

## Out of scope / Future Improvements

*Optional Section*: List of extensions and possible improvements that you predict for this feature that is out of
the scope of this RFC.

Feel free to add as many items as you want, but please refrain from adding too much detail.
If you want to capture your thoughts or start a discussion, please create a feature request.
You are welcome to add a link to the new issue here.

[^unstable_feature]: This unique ident should be used to enable features proposed in the RFC using `-Z <ident>` until the feature has been stabilized.
