<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Failures that Kani can spot - The Kani Rust Verifier</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install-guide.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build-from-source.html"><strong aria-hidden="true">1.1.1.</strong> Building from source</a></li><li class="chapter-item expanded "><a href="install-github-ci.html"><strong aria-hidden="true">1.1.2.</strong> GitHub CI Action</a></li></ol></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">1.2.</strong> Using Kani</a></li><li class="chapter-item expanded "><a href="verification-results.html"><strong aria-hidden="true">1.3.</strong> Verification results</a></li></ol></li><li class="chapter-item expanded "><a href="crates/index.html"><strong aria-hidden="true">2.</strong> Crates Documentation</a></li><li class="chapter-item expanded "><a href="kani-tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial-first-steps.html"><strong aria-hidden="true">3.1.</strong> First steps</a></li><li class="chapter-item expanded "><a href="tutorial-kinds-of-failure.html" class="active"><strong aria-hidden="true">3.2.</strong> Failures that Kani can spot</a></li><li class="chapter-item expanded "><a href="tutorial-loop-unwinding.html"><strong aria-hidden="true">3.3.</strong> Loop unwinding</a></li><li class="chapter-item expanded "><a href="tutorial-nondeterministic-variables.html"><strong aria-hidden="true">3.4.</strong> Nondeterministic variables</a></li></ol></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">4.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/arbitrary.html"><strong aria-hidden="true">4.1.</strong> Arbitrary Trait</a></li><li class="chapter-item expanded "><a href="reference/attributes.html"><strong aria-hidden="true">4.2.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="reference/bounded_arbitrary.html"><strong aria-hidden="true">4.3.</strong> Bounded Non-deterministic variables</a></li><li class="chapter-item expanded "><a href="reference/list.html"><strong aria-hidden="true">4.4.</strong> List Kani Metadata</a></li><li class="chapter-item expanded "><a href="reference/experimental/experimental-features.html"><strong aria-hidden="true">4.5.</strong> Experimental features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/experimental/autoharness.html"><strong aria-hidden="true">4.5.1.</strong> Automatic Harness Generation</a></li><li class="chapter-item expanded "><a href="reference/experimental/coverage.html"><strong aria-hidden="true">4.5.2.</strong> Coverage</a></li><li class="chapter-item expanded "><a href="reference/experimental/stubbing.html"><strong aria-hidden="true">4.5.3.</strong> Stubbing</a></li><li class="chapter-item expanded "><a href="reference/experimental/contracts.html"><strong aria-hidden="true">4.5.4.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="reference/experimental/loop-contracts.html"><strong aria-hidden="true">4.5.5.</strong> Loop Contracts</a></li><li class="chapter-item expanded "><a href="reference/experimental/concrete-playback.html"><strong aria-hidden="true">4.5.6.</strong> Concrete Playback</a></li><li class="chapter-item expanded "><a href="reference/experimental/quantifiers.html"><strong aria-hidden="true">4.5.7.</strong> Quantifiers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">5.</strong> Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool-comparison.html"><strong aria-hidden="true">5.1.</strong> Comparison with other tools</a></li><li class="chapter-item expanded "><a href="tutorial-real-code.html"><strong aria-hidden="true">5.2.</strong> Where to start on real code</a></li><li class="chapter-item expanded "><a href="debugging-slow-proofs.html"><strong aria-hidden="true">5.3.</strong> Debugging slow proofs</a></li></ol></li><li class="chapter-item expanded "><a href="dev-documentation.html"><strong aria-hidden="true">6.</strong> Developer documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conventions.html"><strong aria-hidden="true">6.1.</strong> Coding conventions</a></li><li class="chapter-item expanded "><a href="cbmc-hacks.html"><strong aria-hidden="true">6.2.</strong> Working with CBMC</a></li><li class="chapter-item expanded "><a href="rustc-hacks.html"><strong aria-hidden="true">6.3.</strong> Working with rustc</a></li><li class="chapter-item expanded "><a href="stable-mir.html"><strong aria-hidden="true">6.4.</strong> Migrating to StableMIR</a></li><li class="chapter-item expanded "><a href="cheat-sheets.html"><strong aria-hidden="true">6.5.</strong> Command cheat sheets</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.6.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="regression-testing.html"><strong aria-hidden="true">6.6.1.</strong> Regression testing</a></li></ol></li><li class="chapter-item expanded "><a href="performance-comparisons.html"><strong aria-hidden="true">6.7.</strong> Performance comparisons</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="benchcomp-cli.html"><strong aria-hidden="true">6.7.1.</strong> benchcomp command line</a></li><li class="chapter-item expanded "><a href="benchcomp-conf.html"><strong aria-hidden="true">6.7.2.</strong> benchcomp configuration file</a></li><li class="chapter-item expanded "><a href="benchcomp-parse.html"><strong aria-hidden="true">6.7.3.</strong> Custom parsers</a></li></ol></li><li class="chapter-item expanded "><a href="profiling.html"><strong aria-hidden="true">6.8.</strong> Profiling Kani</a></li></ol></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">7.</strong> Limitations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="undefined-behaviour.html"><strong aria-hidden="true">7.1.</strong> Undefined behaviour</a></li><li class="chapter-item expanded "><a href="rust-feature-support.html"><strong aria-hidden="true">7.2.</strong> Rust feature support</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-feature-support/intrinsics.html"><strong aria-hidden="true">7.2.1.</strong> Intrinsics</a></li><li class="chapter-item expanded "><a href="rust-feature-support/unstable.html"><strong aria-hidden="true">7.2.2.</strong> Unstable features</a></li></ol></li><li class="chapter-item expanded "><a href="overrides.html"><strong aria-hidden="true">7.3.</strong> Overrides</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kani Rust Verifier</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani/edit/main/docs/src/tutorial-kinds-of-failure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="failures-that-kani-can-spot"><a class="header" href="#failures-that-kani-can-spot">Failures that Kani can spot</a></h1>
<p>In the <a href="./tutorial-first-steps.html">last section</a>, we saw Kani spot two major kinds of failures: assertions and panics.
If the proof harness allows some program execution that results in a panic, then Kani will report that as a failure.
In addition, we saw (very briefly) a couple of other kinds of failures: null pointer dereferences and overflows.
In this section, we're going to expand on these additional checks, to give you an idea of what other problems Kani will find.</p>
<h2 id="bounds-checking-and-pointers"><a class="header" href="#bounds-checking-and-pointers">Bounds checking and pointers</a></h2>
<p>Rust is safe by default, and so includes dynamic (run-time) bounds checking where needed.
Consider this Rust code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/bounds_check.rs">here</a>):</p>
<pre><code class="language-rust">/// Wrap &quot;too-large&quot; indexes back into a valid range for the array
fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    if a.len() == 0 {
        return 0;
    }
    return a[i % a.len() + 1];
}
</code></pre>
<p>We can again write a simple property test against this code:</p>
<pre><code class="language-rust">    proptest! {
        #[test]
        fn doesnt_crash(i: usize, a: Vec&lt;u32&gt;) {
            get_wrapped(i, &amp;a);
        }
    }
</code></pre>
<p>This property test will immediately find a failing case, thanks to Rust's built-in bounds checking.</p>
<p>But what if we change this function to use unsafe Rust?</p>
<pre><code class="language-rust">return unsafe { *a.as_ptr().add(i % a.len() + 1) };
</code></pre>
<p>Now the error becomes invisible to this test:</p>
<pre><code># cargo test
[...]
test bounds_check::tests::doesnt_crash ... ok
</code></pre>
<p>The property test still causes an out-of-bounds access, but this undefined behavior does not necessarily cause an immediate crash.
(This is part of why undefined behavior is so difficult to debug.)
Through the use of unsafe code, we removed the runtime check for an out of bounds access.
It just turned out that none of the randomly generated tests triggered behavior that actually crashed.
But if we write a Kani proof harness:</p>
<pre><code class="language-rust">#[cfg(kani)]
#[kani::proof]
fn bound_check() {
    let size: usize = kani::any();
    kani::assume(size &lt; 4096);
    let index: usize = kani::any();
    let array: Vec&lt;u32&gt; = vec![0; size];
    get_wrapped(index, &amp;array);
}
</code></pre>
<p>And run this proof with:</p>
<pre><code class="language-bash">cargo kani --harness bound_check
</code></pre>
<p>We still see a failure from Kani, even without Rust's runtime bounds checking.</p>
<blockquote>
<p>Also, notice there were many checks in the verification output.
(At time of writing, 345.)
This is a result of using the standard library <code>Vec</code> implementation, which means our harness actually used quite a bit of code, short as it looks.
Kani is inserting a lot more checks than appear as asserts in our code, so the output can be large.</p>
</blockquote>
<p>We get the following summary at the end:</p>
<pre><code>SUMMARY: 
 ** 1 of 345 failed (8 unreachable)
Failed Checks: dereference failure: pointer outside object bounds
 File: &quot;./src/bounds_check.rs&quot;, line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
<p>Notice that, for Kani, this has gone from a simple bounds-checking problem to a pointer-checking problem.
Kani will check operations on pointers to ensure they're not potentially invalid memory accesses.
Any unsafe code that manipulates pointers will, as we see here, raise failures if its behavior is actually a problem.</p>
<p>Consider trying a few more small exercises with this example:</p>
<ol>
<li>Exercise: Switch back to the normal/safe indexing operation and re-try Kani.
How does Kani's output change, compared to the unsafe operation?
(Try predicting the answer, then seeing if you got it right.)</li>
<li>Exercise: Try Kani's experimental <a href="reference/experimental/concrete-playback.html">concrete playback</a> feature on this example.</li>
<li>Exercise: Fix the error, run Kani, and see a successful verification.</li>
<li>Exercise: Try switching back to the unsafe code (now with the error fixed) and re-run Kani. Does it still verify successfully?</li>
</ol>
<details>
<summary>Click to see explanation for exercise 1</summary>
<p>Having switched back to the safe indexing operation, Kani reports a bounds check failure:</p>
<pre><code>SUMMARY:
 ** 1 of 343 failed (8 unreachable)
Failed Checks: index out of bounds: the length is less than or equal to the given index
 File: &quot;src/bounds_check.rs&quot;, line 11, in bounds_check::get_wrapped

VERIFICATION:- FAILED
</code></pre>
</details>
<details>
<summary>Click to see explanation for exercise 2</summary>
<p><code>cargo kani -Z concrete-playback --concrete-playback=inplace --harness bound_check</code> produces the following test:</p>
<pre><code>rust
#[test]
fn kani_concrete_playback_bound_check_4752536404478138800() {
    let concrete_vals: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        // 1ul
        vec![1, 0, 0, 0, 0, 0, 0, 0],
        // 18446744073709551615ul
        vec![255, 255, 255, 255, 255, 255, 255, 255],
    ];
    kani::concrete_playback_run(concrete_vals, bound_check);
}
</code></pre>
<p>which indicates that substituting the concrete values <code>size = 1</code> and <code>index = 2^64</code> in our proof harness will produce the out of bounds access.</p>
</details>
<h2 id="overflow-and-math-errors"><a class="header" href="#overflow-and-math-errors">Overflow and math errors</a></h2>
<p>Consider a different variant on the function above:</p>
<pre><code class="language-rust">fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    return a[i % a.len()];
}
</code></pre>
<p>We've corrected the out-of-bounds access, but now we've omitted the &quot;base case&quot;: what to return on an empty list.
Kani will spot this not as a bound error, but as a mathematical error: on an empty list the modulus operator (<code>%</code>) will cause a division by zero.</p>
<ol>
<li>Exercise: Try to run Kani on this version of <code>get_wrapped</code>, to see what this kind of failure looks like.</li>
</ol>
<p>Rust can also perform runtime safety checks for integer overflows, much like it does for bounds checks.
(<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">Though Rust disables this by default in <code>--release</code> mode, it can be re-enabled.</a>)
Consider this code (available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow.rs">here</a>):</p>
<pre><code class="language-rust">fn simple_addition(a: u32, b: u32) -&gt; u32 {
    return a + b;
}
</code></pre>
<p>A trivial function, but if we write a property test for it, we immediately find inputs where it fails, thanks to Rust's dynamic checks.
Kani will find these failures as well.
Here's the output from Kani:</p>
<pre><code># cargo kani --harness add_overflow
[...]
SUMMARY: 
 ** 1 of 2 failed
Failed Checks: attempt to add with overflow
 File: &quot;./src/overflow.rs&quot;, line 7, in overflow::simple_addition

VERIFICATION:- FAILED
</code></pre>
<p>This issue can be fixed using Rust's alternative mathematical functions with explicit overflow behavior.
For instance, if the wrapping behavior is intended, you can write <code>a.wrapping_add(b)</code> instead of <code>a + b</code>.
Kani will then report no issues.</p>
<h3 id="exercise-classic-overflow-failure"><a class="header" href="#exercise-classic-overflow-failure">Exercise: Classic overflow failure</a></h3>
<p>A classic example of a subtle bug that persisted in many implementations for a very long time is &quot;finding the midpoint&quot; in quick sort.
This often naively looks like this (code available <a href="https://github.com/model-checking/kani/blob/main/docs/src/tutorial/kinds-of-failure/src/overflow_quicksort.rs">here</a>):</p>
<pre><code class="language-rust">fn find_midpoint(low: u32, high: u32) -&gt; u32 {
    return (low + high) / 2;
}
</code></pre>
<pre><code>cargo kani --harness midpoint_overflow
</code></pre>
<p>Kani immediately spots the bug in the above code.</p>
<ol>
<li>Exercise: Fix this function so it no longer overflows.
(Hint: depending on which approach you take, you may need to add the assumption that <code>high &gt; low</code> to your proof harness.
Don't add that right away, see what happens if you don't. Just keep it in mind.)</li>
<li>Exercise: Prove your new implementation actually finds the midpoint correctly by adding an assertion to the test harness.</li>
</ol>
<details>
<summary>Click to see solutions for these exercises</summary>
<p>A very common approach for resolving the overflow issue looks like this:</p>
<pre><code class="language-rust">return low + (high - low) / 2;
</code></pre>
<p>But if you naively try this (try it!), you'll find a new underflow error: <code>high - low</code> might result in a negative number, but has type <code>u32</code>.
Hence, the need to add the assumption we suggested above, to make that impossible.
(Adding an assumption, though, means there's a new way to &quot;use it wrong.&quot; Perhaps we'd like to avoid that! Can you avoid the assumption?)</p>
<p>After that, you might wonder how to &quot;prove your new implementation correct.&quot;
After all, what does &quot;correct&quot; even mean?
Often we're using a good approximation of correct, such as the equivalence of two implementations (often one much &quot;simpler&quot; than the other somehow).
Here's one possible assertion we could write in the proof harness:</p>
<pre><code class="language-rust">assert!(result as u64 == (a as u64 + b as u64) / 2);
</code></pre>
<p>You might have even come up with this approach to avoiding the overflow issue in the first place!
Having two different implementations, using different approaches, but proven to yield the same results, gives us greater confidence that we compute the correct result.</p>
</details>
<h2 id="failures-that-kani-cannot-spot"><a class="header" href="#failures-that-kani-cannot-spot">Failures that Kani cannot spot</a></h2>
<p>Check out <a href="./limitations.html">Limitations</a> for information on the checks that Kani does not perform.
Notably, Kani is not prioritizing all Rust-specific notions of undefined behavior.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani spot out-of-bounds accesses.</li>
<li>We saw Kani spot actually-unsafe dereferencing of a raw pointer to invalid memory.</li>
<li>We saw Kani spot a division by zero error and an overflowing addition.</li>
<li>As an exercise, we tried proving an assertion (finding the midpoint) that was not completely trivial.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tutorial-first-steps.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="tutorial-loop-unwinding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tutorial-first-steps.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="tutorial-loop-unwinding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
