#!/usr/bin/env python3
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0 OR MIT

import argparse
import glob
import sys
import rmc
import rmc_flags
import os
import pathlib
import toml

MY_PATH = pathlib.Path(__file__).parent.parent.absolute()
RMC_C_LIB = MY_PATH / "library" / "rmc" / "rmc_lib.c"
EXIT_CODE_SUCCESS = 0
CBMC_VERIFICATION_FAILURE_EXIT_CODE = 10

def main():
    args = parse_args()

    if args.crate is not None:
        rmc.ensure(args.crate_flag is None, "Please provide a single crate to verify.")
    elif args.crate_flag is not None:
        args.crate = args.crate_flag
    else:
        args.crate = "."

    if args.quiet:
        args.verbose = False

    rmc.ensure_dependencies_in_path()

    rmc.cargo_build(args.crate, args.target_dir,
                    args.verbose, args.debug, args.mangler, args.dry_run, [])

    pattern = os.path.join(args.target_dir, "debug", "deps", "*.json")
    jsons = glob.glob(pattern)
    rmc.ensure(len(jsons) == 1, "Unexpected number of json outputs.")

    cbmc_filename = os.path.join(args.target_dir, "cbmc.out")
    c_filename = os.path.join(args.target_dir, "cbmc.c")
    symbols_filename = os.path.join(args.target_dir, "cbmc.symbols")
    if EXIT_CODE_SUCCESS != rmc.symbol_table_to_gotoc(jsons[0], cbmc_filename, args.verbose, args.keep_temps, args.dry_run):
        return 1

    args.c_lib.append(str(RMC_C_LIB))

    if EXIT_CODE_SUCCESS != rmc.link_c_lib(cbmc_filename, cbmc_filename, args.c_lib, args.verbose, args.quiet, args.function, args.dry_run):
        return 1

    if args.gen_c:
        if EXIT_CODE_SUCCESS != rmc.goto_to_c(cbmc_filename, c_filename, args.verbose, args.dry_run):
            return 1

    if args.gen_symbols:
        if EXIT_CODE_SUCCESS != rmc.goto_to_symbols(cbmc_filename, symbols_filename, args.verbose, args.dry_run):
            return 1

    if "--function" not in args.cbmc_args:
        args.cbmc_args.extend(["--function", args.function])

    if args.visualize:
        # Use a separate set of flags for coverage checking (empty for now)
        cover_args = []
        retcode = rmc.run_visualize(cbmc_filename, args.cbmc_args, cover_args, \
                                 args.verbose, args.quiet, args.keep_temps, \
                                 args.function, args.srcdir, args.wkdir, args.target_dir, args.dry_run)
    else:
        retcode = rmc.run_cbmc(cbmc_filename, args.cbmc_args, args.verbose, args.quiet, args.dry_run)

    if retcode == CBMC_VERIFICATION_FAILURE_EXIT_CODE and args.allow_cbmc_verification_failure:
        retcode = EXIT_CODE_SUCCESS

    return retcode

def parse_args():
    # Create parser
    def create_parser():
        parser = argparse.ArgumentParser(prog="cargo rmc", description="Verify a Rust crate. For more information, see https://github.com/model-checking/rmc.")

        crate_group = parser.add_argument_group("Crate", "You can pass in the rust crate positionally or with the --crate flag.")
        crate_group.add_argument("crate", help="crate to verify", nargs="?")
        crate_group.add_argument("--crate", help="crate to verify", dest="crate_flag", metavar="CRATE")

        config_group = parser.add_argument_group("Config", "You can configure cargo rmc with your Cargo.toml file.")
        config_group.add_argument("--config-toml", help="Where to read configuration from; defaults to crate's Cargo.toml")
        config_group.add_argument("--no-config-toml", action="store_true", help="Do not use any configuration toml")

        exclude_flags = [
            # This should be able to be supported; https://github.com/model-checking/rmc/issues/359
            "--gen-symbols",
            # This should be able to be supported; https://github.com/model-checking/rmc/issues/360
            "--allow-cbmc-verification-failure",
        ]
        rmc_flags.add_flags(parser, {"default-target": "target"}, exclude_flags=exclude_flags)
        
        return parser

    # Check for conflicting flags
    def validate(args):
        rmc.ensure(not (args.crate and args.crate_flag), "Please provide a single crate to verify.")   
        rmc.ensure(not (args.no_config_toml and args.config_toml), "Incompatible flags: --config-toml, --no-config-toml")

    # Fix up args before returning
    def post_process(args):
        # Combine positional and flag argument for input
        cl_args.crate = cl_args.crate or cl_args.crate_flag or "."

        # --quiet overrides --verbose
        if args.quiet:
            args.verbose = False

        # Add some CBMC flags by default unless `--no-default-checks` is being used
        if args.default_checks:
            rmc.add_selected_default_cbmc_flags(args)

    # Combine args set by config toml and provided on command line
    def get_combined_args(config_toml, crate, cl_args):
        # Check that config toml exists, or set to default (<crate>/Config.toml)
        if config_toml is not None:
            rmc.ensure(pathlib.Path(config_toml).is_file(), f"Invalid config file: {config_toml}")
        else:
            crate_cargo_toml = pathlib.Path(crate).joinpath("Cargo.toml")
            if crate_cargo_toml.is_file():
                config_toml = crate_cargo_toml
            else:
                # If no config_toml is given and we can't find Cargo.toml
                # then just use command line arguments
                print(f"WARNING: Could not find Cargo.toml in project {pathlib.Path(crate).absolute()}")
                return cl_args
        
        # Extract flags from config toml
        toml_args = extract_args_from_toml(config_toml)

        # Parse args from both toml and command line
        # but let command line args override toml args
        combined_args = argparse.Namespace()
        parser.parse_args(toml_args, namespace=combined_args)
        parser.parse_args(namespace=combined_args)

        return combined_args

    # Remove "rmc" from arg if invoked `cargo rmc ...`
    if len(sys.argv) >= 2 and sys.argv[1] == "rmc":
        del sys.argv[1]

    # Parse command line args to find crate and check for config flags
    parser = create_parser()
    cl_args = parser.parse_args()
    validate(cl_args)

    # Load flags from config toml
    if cl_args.no_config_toml:
        final_args = cl_args
    else:
        crate = cl_args.crate or cl_args.crate_flag or "."
        final_args = get_combined_args(cl_args.config_toml, crate, cl_args)
        validate(final_args)

    post_process(final_args)
    return final_args

# Try to load Cargo.toml from dir, and update args
def extract_args_from_toml(path):
    # Load the flag data from toml
    data = toml.load(path)
    rmc_data = data["rmc"]
    flag_data = rmc_data["flags"]

    # Extract nested flags
    flags = dict()
    def find_flags(map):
        for key in map:
            if type(map[key]) == dict:
                find_flags(map[key])
            else:
                flags[key] = map[key]
    find_flags(flag_data)

    # Add flags to args
    success = True
    args = []
    def add_flag(flag, value):
        if type(value) == bool:
            if value:
                args.append(f"--{flag}")
            else:
                if flag.startswith("no-"):
                    args.append(f"--{flag[3:]}")
                else:
                    args.append(f"--no-{flag}")
        elif type(value) == list:
            args.append(f"--{flag}")
            assert all(map(lambda arg: type(arg) == str, value)), f"ERROR: Invalid config: {flag} = {value}"
            args.extend(value)
        elif type(value) == str:
            args.append(f"--{flag}")
            args.append(value)
        else:
            print(f"ERROR: Invalid config: {flag} = {value}")
            success = False
    for flag in flags:
        add_flag(flag, flags[flag])
    
    rmc.ensure(success)
    return args

if __name__ == "__main__":
    sys.exit(main())