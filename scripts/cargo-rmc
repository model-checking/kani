#!/usr/bin/env python3
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0 OR MIT

import argparse
import glob
import sys
import rmc
import os
import pathlib

MY_PATH = pathlib.Path(__file__).parent.parent.absolute()
RMC_C_LIB = MY_PATH / "library" / "rmc" / "rmc_lib.c"
EXIT_CODE_SUCCESS = 0


def main():
    # Remove "rmc" from arg if invoked `cargo rmc ...`
    if len(sys.argv) >= 2 and sys.argv[1] == "rmc":
        del sys.argv[1]

    parser = argparse.ArgumentParser(description="Verify a Rust crate")
    parser.add_argument("crate", help="crate to verify", nargs="?")
    parser.add_argument("--crate", help="crate to verify", dest="crate_flag")
    parser.add_argument("--verbose", "-v", action="store_true")
    parser.add_argument("--quiet", "-q", action="store_true")
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("--keep-temps", action="store_true")
    parser.add_argument("--gen-c", action="store_true")
    parser.add_argument("--mangler", default="v0")
    parser.add_argument("--visualize", action="store_true")
    parser.add_argument("--c-lib", nargs="*", default=[], action="extend")
    parser.add_argument("--srcdir", default=".")
    parser.add_argument("--target-dir", default="target",
                        help="Directory for all generated artifacts")
    parser.add_argument("--wkdir", default=".")
    parser.add_argument("--function", default="main")
    parser.add_argument("--no-default-checks", action="store_true", help="Disable all default checks")
    parser.add_argument("--no-memory-safety-checks", action="store_true", help="Disable default memory safety checks")
    parser.add_argument("--no-overflow-checks", action="store_true", help="Disable default overflow checks")
    parser.add_argument("--no-unwinding-checks", action="store_true", help="Disable default unwinding checks")
    parser.add_argument("--dry-run", action="store_true", help="Print commands instead of running them")
    parser.add_argument("--cbmc-args", nargs=argparse.REMAINDER,
                        default=[], help="Pass through directly to CBMC")
    args = parser.parse_args()

    if args.crate:
        assert args.crate_flag is None, "Please provide a single crate to verify."
    else:
        assert args.crate_flag is not None, "Please provide a crate to verify."
        args.crate = args.crate_flag

    if args.quiet:
        args.verbose = False

    if not rmc.dependencies_in_path():
        return 1

    # Add some CBMC flags by default unless `--no-default-checks` is being used
    if not args.no_default_checks:
        rmc.add_selected_default_cbmc_flags(args)

    rmc.cargo_build(args.crate, args.target_dir,
                    args.verbose, args.debug, args.mangler, args.dry_run, [])

    pattern = os.path.join(args.target_dir, "debug", "deps", "*.json")
    jsons = glob.glob(pattern)
    if len(jsons) != 1:
        print("ERROR: unexpected number of json outputs")
        return 1
    cbmc_filename = os.path.join(args.target_dir, "cbmc.out")
    c_filename = os.path.join(args.target_dir, "cbmc.c")
    if EXIT_CODE_SUCCESS != rmc.symbol_table_to_gotoc(jsons[0], cbmc_filename, args.verbose, args.keep_temps, args.dry_run):
        return 1

    args.c_lib.append(str(RMC_C_LIB))

    if EXIT_CODE_SUCCESS != rmc.link_c_lib(cbmc_filename, cbmc_filename, args.c_lib, args.verbose, args.quiet, args.function, args.dry_run):
        return 1

    if args.gen_c:
        if EXIT_CODE_SUCCESS != rmc.goto_to_c(cbmc_filename, c_filename, args.verbose, args.dry_run):
            return 1

    if "--function" not in args.cbmc_args:
        args.cbmc_args.extend(["--function", args.function])

    if args.visualize:
        # Use a separate set of flags for coverage checking (empty for now)
        cover_args = []
        return rmc.run_visualize(cbmc_filename, args.cbmc_args, cover_args, \
                                 args.verbose, args.quiet, args.keep_temps, \
                                 args.function, args.srcdir, args.wkdir, args.target_dir, args.dry_run)
    else:
        return rmc.run_cbmc(cbmc_filename, args.cbmc_args, args.verbose, args.quiet, args.dry_run)


if __name__ == "__main__":
    sys.exit(main())
