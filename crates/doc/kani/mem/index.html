<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains functions useful for checking unsafe memory access."><title>kani::mem - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="kani" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (646a3f8c1 2025-12-02)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module mem</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../kani/index.html">kani</a><span class="version">0.67.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module mem</a></h2><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate kani</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">kani</a></div><h1>Module <span>mem</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/kani/lib.rs.html#57">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains functions useful for checking unsafe memory access.</p>
<p>Given the following validity rules provided in the Rust documentation:
<a href="https://doc.rust-lang.org/std/ptr/index.html">https://doc.rust-lang.org/std/ptr/index.html</a> (accessed May 20th, 2025)</p>
<ol>
<li>For memory accesses of size zero, every pointer is valid, including the null pointer.
The following points are only concerned with non-zero-sized accesses.</li>
<li>A null pointer is never valid.</li>
<li>For a pointer to be valid, it is necessary, but not always sufficient, that the pointer
be dereferenceable: the memory range of the given size starting at the pointer must all be
within the bounds of a single allocated object. Note that in Rust, every (stack-allocated)
variable is considered a separate allocated object.</li>
<li>All accesses performed by functions in this module are non-atomic in the sense of atomic
operations used to synchronize between threads.
This means it is undefined behavior to perform two concurrent accesses to the same location
from different threads unless both accesses only read from memory.
Notice that this explicitly includes <code>read_volatile</code> and <code>write_volatile</code>:
Volatile accesses cannot be used for inter-thread synchronization.</li>
<li>The result of casting a reference to a pointer is valid for as long as the underlying
object is live and no reference (just raw pointers) is used to access the same memory.
That is, reference and pointer accesses cannot be interleaved.</li>
</ol>
<p>Kani is able to verify #1, #2, and #3 today.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="fn" href="fn.can_dereference.html" title="fn kani::mem::can_dereference">can_<wbr>dereference</a></dt><dd>Checks that pointer <code>ptr</code> point to a valid value of type <code>T</code>.</dd><dt><a class="fn" href="fn.can_read_unaligned.html" title="fn kani::mem::can_read_unaligned">can_<wbr>read_<wbr>unaligned</a></dt><dd>Checks that pointer <code>ptr</code> point to a valid value of type <code>T</code>.</dd><dt><a class="fn" href="fn.can_write.html" title="fn kani::mem::can_write">can_<wbr>write</a></dt><dd>Check if the pointer is valid for write access according to <a href="index.html" title="mod kani::mem">crate::mem</a> conditions 1, 2
and 3.</dd><dt><a class="fn" href="fn.can_write_unaligned.html" title="fn kani::mem::can_write_unaligned">can_<wbr>write_<wbr>unaligned</a></dt><dd>Check if the pointer is valid for unaligned write access according to <a href="index.html" title="mod kani::mem">crate::mem</a> conditions
1, 2 and 3.</dd><dt><a class="fn" href="fn.checked_align_of_raw.html" title="fn kani::mem::checked_align_of_raw">checked_<wbr>align_<wbr>of_<wbr>raw</a></dt><dd>Compute the size of the val pointed to if safe.</dd><dt><a class="fn" href="fn.checked_size_of_raw.html" title="fn kani::mem::checked_size_of_raw">checked_<wbr>size_<wbr>of_<wbr>raw</a></dt><dd>Compute the size of the val pointed to if it is safe to do so.</dd><dt><a class="fn" href="fn.is_inbounds.html" title="fn kani::mem::is_inbounds">is_<wbr>inbounds</a></dt><dd>Checks that <code>ptr</code> points to an allocation that can hold data of size calculated from <code>T</code>.</dd><dt><a class="fn" href="fn.same_allocation.html" title="fn kani::mem::same_allocation">same_<wbr>allocation</a></dt><dd>Check if two pointers points to the same allocated object, and that both pointers
are in bounds of that object.</dd></dl></section></div></main></body></html>