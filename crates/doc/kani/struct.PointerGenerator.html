<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Pointer generator that can be used to generate arbitrary pointers."><title>PointerGenerator in kani - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="kani" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (646a3f8c1 2025-12-02)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">PointerGenerator</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../kani/index.html">kani</a><span class="version">0.67.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Pointer<wbr>Generator</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#buffer-size" title="Buffer size">Buffer size</a></li><li><a href="#pointer-provenance" title="Pointer provenance">Pointer provenance</a></li><li><a href="#pointer-generator-vs-pointer-with-any-address" title="Pointer Generator vs Pointer with any address">Pointer Generator vs Pointer with any address</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.any_alloc_status" title="any_alloc_status">any_alloc_status</a></li><li><a href="#method.any_in_bounds" title="any_in_bounds">any_in_bounds</a></li><li><a href="#method.new" title="new">new</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-PointerGenerator%3CBYTES%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-PointerGenerator%3CBYTES%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-PointerGenerator%3CBYTES%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-PointerGenerator%3CBYTES%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-PointerGenerator%3CBYTES%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-PointerGenerator%3CBYTES%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PointerGenerator%3CBYTES%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate kani</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">kani</a></div><h1>Struct <span class="struct">Pointer<wbr>Generator</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/kani/lib.rs.html#57">Source</a> </span></div><pre class="rust item-decl"><code>pub struct PointerGenerator&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Pointer generator that can be used to generate arbitrary pointers.</p>
<p>This generator allows users to build pointers with different safety properties.
This is different than creating a pointer that can have any address, since it will never
point to a previously allocated object.
See <a href="struct.PointerGenerator.html#pointer-generator-vs-pointer-with-any-address" title="struct kani::PointerGenerator">this section</a>
for more details.</p>
<p>The generator contains an internal buffer of a constant generic size, <code>BYTES</code>, that it
uses to generate <code>InBounds</code> and <code>OutOfBounds</code> pointers.
In those cases, the generated pointers will have the same provenance as the generator,
and the same lifetime.
The address of an <code>InBounds</code> pointer will represent all possible addresses in the range
of the generator’s buffer address.</p>
<p>For other allocation statuses, the generator will create a pointer that satisfies the
given condition.
The pointer address will <strong>not</strong> represent all possible addresses that satisfies the
given allocation status.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span><span class="kw-2">mut </span>generator = PointerGenerator::&lt;<span class="number">10</span>&gt;::new();
    <span class="kw">let </span>arbitrary = generator.any_alloc_status::&lt;char&gt;();
    kani::assume(arbitrary.status == AllocationStatus::InBounds);
    <span class="comment">// Pointer may be unaligned, but it should be in-bounds, so it is safe to write to
    </span><span class="kw">unsafe </span>{ arbitrary.ptr.write_unaligned(kani::any()) }</code></pre></div>
<p>The generator is parameterized by the number of bytes of its internal buffer.
See <a href="fn.pointer_generator.html" title="fn kani::pointer_generator">pointer_generator</a> function if you would like to create a generator that fits
a minimum number of objects of a given type. Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">// These generators have the same capacity of 6 bytes.
    </span><span class="kw">let </span>generator1 = PointerGenerator::&lt;<span class="number">6</span>&gt;::new();
    <span class="kw">let </span>generator2 = pointer_generator::&lt;i16, <span class="number">3</span>&gt;();</code></pre></div><h3 id="buffer-size"><a class="doc-anchor" href="#buffer-size">§</a>Buffer size</h3>
<p>The internal buffer is used to generate pointers, and its size determines the maximum
number of pointers it can generate without overlapping.
Larger values will impact the maximum distance between generated pointers.</p>
<p>We recommend that you pick a size that is at least big enough to
cover the cases where all pointers produced are non-overlapping.
The buffer size in bytes must be big enough to fit distinct objects for each call
of generate pointer.
For example, generating two <code>*mut u8</code> and one <code>*mut u32</code> requires a buffer
of at least 6 bytes.</p>
<p>This guarantees that your harness covers cases where all generated pointers
point to allocated positions that do not overlap. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span><span class="kw-2">mut </span>generator = PointerGenerator::&lt;<span class="number">6</span>&gt;::new();
    <span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>u8 = generator.any_in_bounds().ptr;
    <span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>u8 = generator.any_in_bounds().ptr;
    <span class="kw">let </span>ptr3: <span class="kw-2">*mut </span>u32 = generator.any_in_bounds().ptr;
    <span class="comment">// This cover is satisfied.
    </span><span class="macro">cover!</span>((ptr1 <span class="kw">as </span>usize) &gt;= (ptr2 <span class="kw">as </span>usize) + size_of::&lt;u8&gt;()
           &amp;&amp; (ptr2 <span class="kw">as </span>usize) &gt;= (ptr3 <span class="kw">as </span>usize) + size_of::&lt;u32&gt;());
    <span class="comment">// As well as having overlapping pointers.
    </span><span class="macro">cover!</span>((ptr1 <span class="kw">as </span>usize) == (ptr3 <span class="kw">as </span>usize));</code></pre></div>
<p>The first cover will be satisfied, since there exists at least one path where
the generator produces inbounds pointers that do not overlap. Such as this scenario:</p>
<div class="example-wrap"><pre class="language-text"><code>+--------+--------+--------+--------+--------+--------+
| Byte 0 | Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 |
+--------+--------+--------+--------+--------+--------+
&lt;--------------- ptr3 --------------&gt;&lt;--ptr2-&gt;&lt;--ptr1-&gt;</code></pre></div>
<p>I.e., the generator buffer is large enough to fit all 3 objects without overlapping.</p>
<p>In contrast, if we had used a size of 1 element, all calls to <code>any_in_bounds()</code> would
return elements that overlap, and the first cover would no longer be satisfied.</p>
<p>Note that the generator requires a minimum number of 1 byte, otherwise the
<code>InBounds</code> case would never be covered.
Compilation will fail if you try to create a generator of size <code>0</code>.</p>
<p>Additionally, the verification will fail if you try to generate a pointer for a type
with size greater than the buffer size.</p>
<p>Use larger buffer size if you want to cover scenarios where the distance
between the generated pointers matters.</p>
<p>The only caveats of using very large numbers are:</p>
<ol>
<li>The value cannot exceed the solver maximum object size (currently 2^48 by default), neither Rust’s
maximum object size (<code>isize::MAX</code>).</li>
<li>Larger sizes could impact performance as they can lead to an exponential increase in the number of possibilities of pointer placement within the buffer.</li>
</ol>
<h2 id="pointer-provenance"><a class="doc-anchor" href="#pointer-provenance">§</a>Pointer provenance</h2>
<p>The pointer returned in the <code>InBounds</code> and <code>OutOfBounds</code> case will have the same
provenance as the generator.</p>
<p>Use the same generator if you want to handle cases where 2 or more pointers may overlap. E.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span><span class="kw-2">mut </span>generator = pointer_generator::&lt;char, <span class="number">5</span>&gt;();
    <span class="kw">let </span>ptr1 = generator.any_in_bounds::&lt;char&gt;().ptr;
    <span class="kw">let </span>ptr2 = generator.any_in_bounds::&lt;char&gt;().ptr;
    <span class="comment">// This cover is satisfied.
    </span><span class="macro">cover!</span>(ptr1 == ptr2)</code></pre></div>
<p>If you want to cover cases where two or more pointers may not have the same
provenance, you will need to instantiate multiple generators.
You can also apply non-determinism to cover cases where the pointers may or may not
have the same provenance. E.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span><span class="kw-2">mut </span>generator1 = pointer_generator::&lt;char, <span class="number">5</span>&gt;();
    <span class="kw">let </span><span class="kw-2">mut </span>generator2 = pointer_generator::&lt;char, <span class="number">5</span>&gt;();
    <span class="kw">let </span>ptr1: <span class="kw-2">*const </span>char = generator1.any_in_bounds().ptr;
    <span class="kw">let </span>ptr2: <span class="kw-2">*const </span>char = <span class="kw">if </span>kani::any() {
        <span class="comment">// Pointers will have same provenance and may overlap.
        </span>generator1.any_in_bounds().ptr
    } <span class="kw">else </span>{
        <span class="comment">// Pointers will have different provenance and will not overlap.
        </span>generator2.any_in_bounds().ptr
    };
    <span class="comment">// Invoke the function under verification
    </span><span class="kw">unsafe </span>{ my_target(ptr1, ptr2) };</code></pre></div><h2 id="pointer-generator-vs-pointer-with-any-address"><a class="doc-anchor" href="#pointer-generator-vs-pointer-with-any-address">§</a>Pointer Generator vs Pointer with any address</h2>
<p>Creating a pointer using the generator is different than generating a pointer
with any address.</p>
<p>I.e.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">// This pointer represents any address, and it may point to anything in memory,
    // allocated or not.
    </span><span class="kw">let </span>ptr1 = kani::any::&lt;usize&gt;() <span class="kw">as </span><span class="kw-2">*const </span>u8;

    <span class="comment">// This pointer address will either point to unallocated memory, to a dead object
    // or to allocated memory within the generator address space.
    </span><span class="kw">let </span><span class="kw-2">mut </span>generator = PointerGenerator::&lt;<span class="number">5</span>&gt;::new();
    <span class="kw">let </span>ptr2: <span class="kw-2">*const </span>u8 = generator.any_alloc_status().ptr;</code></pre></div>
<p>Kani cannot reason about a pointer allocation status (except for asserting its validity).
Thus, the generator was introduced to help writing harnesses that need to impose
constraints to the arbitrary pointer allocation status.
It also allow us to restrict the pointer provenance, excluding for example the address of
variables that are not available in the current context.
As a limitation, it will not cover the entire address space that a pointer can take.</p>
<p>If your harness does not need to reason about pointer allocation, for example, verifying
pointer wrapping arithmetic, using a pointer with any address will allow you to cover
all possible scenarios.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-PointerGenerator%3CBYTES%3E" class="impl"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><a href="#impl-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Create a new PointerGenerator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.any_alloc_status" class="method"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><h4 class="code-header">pub fn <a href="#method.any_alloc_status" class="fn">any_alloc_status</a>&lt;'a, T&gt;(&amp;'a mut self) -&gt; <a class="struct" href="struct.ArbitraryPointer.html" title="struct kani::ArbitraryPointer">ArbitraryPointer</a>&lt;'a, T&gt;<div class="where">where
    T: <a class="trait" href="trait.Arbitrary.html" title="trait kani::Arbitrary">Arbitrary</a>,</div></h4></section></summary><div class="docblock"><p>Creates a raw pointer with non-deterministic properties.</p>
<p>The pointer returned is either dangling or has the same provenance of the generator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.any_in_bounds" class="method"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><h4 class="code-header">pub fn <a href="#method.any_in_bounds" class="fn">any_in_bounds</a>&lt;'a, T&gt;(&amp;'a mut self) -&gt; <a class="struct" href="struct.ArbitraryPointer.html" title="struct kani::ArbitraryPointer">ArbitraryPointer</a>&lt;'a, T&gt;<div class="where">where
    T: <a class="trait" href="trait.Arbitrary.html" title="trait kani::Arbitrary">Arbitrary</a>,</div></h4></section></summary><div class="docblock"><p>Creates a in-bounds raw pointer with non-deterministic properties.</p>
<p>The pointer points to an allocated location with the same provenance of the generator.
The pointer may be unaligned, and the pointee may be uninitialized.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span><span class="kw-2">mut </span>generator = PointerGenerator::&lt;<span class="number">6</span>&gt;::new();
    <span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>u8 = generator.any_in_bounds().ptr;
    <span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>u8 = generator.any_in_bounds().ptr;
    <span class="comment">// SAFETY: Both pointers have the same provenance.
    </span><span class="kw">let </span>distance = <span class="kw">unsafe </span>{ ptr1.offset_from(ptr2) };
    <span class="macro">assert!</span>(distance &gt; -<span class="number">5 </span>&amp;&amp; distance &lt; <span class="number">5</span>)</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-PointerGenerator%3CBYTES%3E" class="impl"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><a href="#impl-Debug-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/kani/lib.rs.html#57">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-Freeze-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section><section id="impl-RefUnwindSafe-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-RefUnwindSafe-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section><section id="impl-Send-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-Send-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section><section id="impl-Sync-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-Sync-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section><section id="impl-Unpin-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-Unpin-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section><section id="impl-UnwindSafe-for-PointerGenerator%3CBYTES%3E" class="impl"><a href="#impl-UnwindSafe-for-PointerGenerator%3CBYTES%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const BYTES: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PointerGenerator.html" title="struct kani::PointerGenerator">PointerGenerator</a>&lt;BYTES&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>