<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Trait that determines the possible sequence of tasks scheduling for a harness."><title>SchedulingStrategy in kani::futures - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="kani" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (646a3f8c1 2025-12-02)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">SchedulingStrategy</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../kani/index.html">kani</a><span class="version">0.67.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Scheduling<wbr>Strategy</a></h2><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.pick_task" title="pick_task">pick_task</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In kani::<wbr>futures</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">kani</a>::<wbr><a href="index.html">futures</a></div><h1>Trait <span class="trait">Scheduling<wbr>Strategy</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/kani/futures.rs.html#74-91">Source</a> </span></div><pre class="rust item-decl"><code>pub trait SchedulingStrategy {
    // Required method
    fn <a href="#tymethod.pick_task" class="fn">pick_task</a>(&amp;mut self, num_tasks: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.SchedulingAssumption.html" title="enum kani::futures::SchedulingAssumption">SchedulingAssumption</a>);
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Trait that determines the possible sequence of tasks scheduling for a harness.</p>
<p>If your harness spawns several tasks, Kani’s scheduler has to decide in what order to poll them.
This order may depend on the needs of your verification goal.
For example, you sometimes may wish to verify all possible schedulings, i.e. a nondeterministic scheduling strategy.</p>
<p>Nondeterministic scheduling strategies can be very slow to verify because they require Kani to check a large number of permutations of tasks.
So if you want to verify a harness that uses <code>spawn</code>, but don’t care about concurrency issues, you can simply use a deterministic scheduling strategy,
such as <a href="struct.RoundRobin.html" title="struct kani::futures::RoundRobin"><code>RoundRobin</code></a>, which polls each task in turn.</p>
<p>Finally, you have the option of providing your own scheduling strategy by implementing this trait.
This can be useful, for example, if you want to verify that things work correctly for a very specific task ordering.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.pick_task" class="method"><a class="src rightside" href="../../src/kani/futures.rs.html#90">Source</a><h4 class="code-header">fn <a href="#tymethod.pick_task" class="fn">pick_task</a>(&amp;mut self, num_tasks: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.SchedulingAssumption.html" title="enum kani::futures::SchedulingAssumption">SchedulingAssumption</a>)</h4></section></summary><div class="docblock"><p>Picks the next task to be scheduled whenever the scheduler needs to pick a task to run next, and whether it can be assumed that the picked task is still running</p>
<p>Tasks are numbered <code>0..num_tasks</code>.
For example, if pick_task(4) returns (2, CanAssumeRunning) than it picked the task with index 2 and allows Kani to <code>assume</code> that this task is still running.
This is useful if the task is chosen nondeterministicall (<code>kani::any()</code>) and allows the verifier to discard useless execution branches (such as polling a completed task again).</p>
<p>As a rule of thumb:
if the scheduling strategy picks the next task nondeterministically (using <code>kani::any()</code>), return CanAssumeRunning, otherwise CannotAssumeRunning.
When returning <code>CanAssumeRunning</code>, the scheduler will then assume that the picked task is still running, which cuts off “useless” paths where a completed task is polled again.
It is even necessary to make things terminate if nondeterminism is involved:
if we pick the task nondeterministically, and don’t have the restriction to still running tasks, we could poll the same task over and over again.</p>
<p>However, for most deterministic scheduling strategies, e.g. the round robin scheduling strategy, assuming that the picked task is still running is generally not possible
because if that task has ended, we are saying assume(false) and the verification effectively stops (which is undesirable, of course).
In such cases, return <code>CannotAssumeRunning</code> instead.</p>
</div></details></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-SchedulingStrategy-for-RoundRobin" class="impl"><a class="src rightside" href="../../src/kani/futures.rs.html#99-105">Source</a><a href="#impl-SchedulingStrategy-for-RoundRobin" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.SchedulingStrategy.html" title="trait kani::futures::SchedulingStrategy">SchedulingStrategy</a> for <a class="struct" href="struct.RoundRobin.html" title="struct kani::futures::RoundRobin">RoundRobin</a></h3></section></div><script src="../../trait.impl/kani/futures/trait.SchedulingStrategy.js" async></script></section></div></main></body></html>